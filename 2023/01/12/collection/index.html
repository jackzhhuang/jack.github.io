<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Rust的容器 | Jack Huang的技术生活</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想： 1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序） 2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历） 3、其它各种先决条件。 总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust的容器">
<meta property="og:url" content="https://www.jackhuang.cc/2023/01/12/collection/index.html">
<meta property="og:site_name" content="Jack Huang的技术生活">
<meta property="og:description" content="今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想： 1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序） 2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历） 3、其它各种先决条件。 总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.jackhuang.cc/svg/Vec.svg">
<meta property="article:published_time" content="2023-01-12T14:42:05.000Z">
<meta property="article:modified_time" content="2023-01-15T15:50:54.750Z">
<meta property="article:author" content="Jack Huang">
<meta property="article:tag" content="C&#x2F;C++,RUST,Python,nodejs,Java,Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.jackhuang.cc/svg/Vec.svg">
  
    <link rel="alternate" href="/atom.xml" title="Jack Huang的技术生活" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jack Huang的技术生活</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些关于技术的思考，想法和积累</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://www.jackhuang.cc"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-collection" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/12/collection/" class="article-date">
  <time class="dt-published" datetime="2023-01-12T14:42:05.000Z" itemprop="datePublished">2023-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rust/">Rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Rust的容器
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：</p>
<p>1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）</p>
<p>2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）</p>
<p>3、其它各种先决条件。</p>
<p>总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。</p>
<p>现在我们就从最常用的容器开始吧。</p>
<span id="more"></span>

<!-- toc -->

<ul>
<li><a href="#1-%E6%95%B0%E7%BB%84vec">1. 数组Vec</a><ul>
<li><a href="#11-%E9%AB%98%E6%95%88%E5%88%9D%E5%A7%8B%E5%8C%96">1.1 高效初始化</a></li>
<li><a href="#12-%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE">1.2 顺序访问</a></li>
<li><a href="#13-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE">1.3 索引访问</a></li>
<li><a href="#14-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">1.4 插入操作</a><ul>
<li><a href="#141-insert%E6%96%B9%E6%B3%95">1.4.1 insert()方法</a></li>
</ul>
</li>
<li><a href="#15-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">1.5 删除操作</a><ul>
<li><a href="#151-pop%E6%96%B9%E6%B3%95">1.5.1 pop()方法</a></li>
<li><a href="#152-swap_remove-%E6%96%B9%E6%B3%95">1.5.2 swap_remove () 方法</a></li>
</ul>
</li>
<li><a href="#16-vec%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6">1.6 Vec内部结构探究</a></li>
</ul>
</li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2string">2. 字符串String</a><ul>
<li><a href="#21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5">2.1 字符串的连接</a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82">2.2 字符串和字节</a></li>
<li><a href="#23-rust%E7%9A%84string%E4%B8%8D%E7%AE%80%E5%8D%95">2.3 Rust的String不简单</a></li>
</ul>
</li>
<li><a href="#3-%E5%93%88%E5%B8%8Chashmap">3. 哈希HashMap</a><ul>
<li><a href="#31-%E6%8F%92%E5%85%A5">3.1 插入</a></li>
<li><a href="#32-%E6%9F%A5%E6%89%BE">3.2 查找</a></li>
<li><a href="#33-%E6%9B%B4%E6%96%B0">3.3 更新</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-数组vec">1. 数组Vec</span></h2><p>数组Vec是最常用的容器，它非常类似C++的std::vector，底层数据结构也是一块连续的内存，内存不足时，会扩大，并把老数据拷贝到新内存上，因此，非常适合顺序访问和索引访问，非常不适合有删除和插入的场景，因为此时暗含着内存移动的低效操作。</p>
<h3><span id="11-高效初始化">1.1 高效初始化</span></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用了最常用的初始化方法，array1是vec!宏来初始化，array2是直接用Vec::new()来初始化，可以看到我们在定义array2的时候并没有去告诉array2将会放上面类型，直到第6行push第一个String对象的时候才告诉编译器，我们要放的对象是String。Vec只能是单一对象。第6行决定了array2必须放String对象。</p>
<p>前面说了，Vec是会因为自身分配的内存空间不足时，增长内存的，因此会有数据移动的低效操作，array2的初始化就是这样，如果我们能事先告诉array2要存放什么类型，已经即将存放的数量，那么Vec就可以事先分配好空间，保证我们后续放入数据时不会有数据移动操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">array2.<span class="title function_ invoke__">reserve</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure>

<p>上面的reserver方法就是告诉array2实现分配至少3个String对象空间，好让后续的3个push方法调用不产生数据移动操作。</p>
<p>如果事先知道需要分配数组的元素数量，且它们的值都是同一个，那么，更高效的方法是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = <span class="built_in">vec!</span>[<span class="number">100</span>; <span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array3 = &#123;:?&#125;&quot;</span>, array3);</span><br></pre></td></tr></table></figure>

<p>上面的[100; 5]就表示，分配长度为5个元素，且每个值都是100的数组，这就比前面使用reserver更高效。</p>
<p>还有with_capacity()方法，可以把Vec::new()和reserve()方法都合成一个，例如array2的初始化可以改成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure>

<p>总之，如果我们实现就能知道有多少元素即将push进Vec里面的话，我们就尽量的把内存分配好，避免数据移动操作。</p>
<h3><span id="12-顺序访问">1.2 顺序访问</span></h3><p>Vec是最适合顺序访问的了，我们可以一个个枚举Vec里面的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> &amp;array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，访问array2时我们用了引用，这样访问里面的String对象时，也都变成了引用，这个规则struct也是这样。因为用了引用，后续array2还是有效的指针。</p>
<h3><span id="13-索引访问">1.3 索引访问</span></h3><p>索引访问也是我们常用的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[2] = &#123;&#125;&quot;</span>, array2[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>这当然会打印“hello jack”，但如果访问一个不存在的索引呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[6] = &#123;&#125;&quot;</span>, array2[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<p>此时会panic：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">6</span>&#x27;, src/main.rs:<span class="number">14</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>还需要非常注意的是，之前也提到过，Vec不允许自己的元素被转移走，即以下代码将编译不通过：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">take</span> = array2[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>因为首先Rust不允许悬空指针的存在，其次如果Vec去维护中间哪一个元素处于悬空指针又实在不合常理，毕竟Vec就是Vec，即向量，向量不应该感知这些东西。因此如果有人打算通过索引访问去取走Vec的资源，那么就会被编译器报错。</p>
<h3><span id="14-插入操作">1.4 插入操作</span></h3><h4><span id="141-insert方法">1.4.1 insert()方法</span></h4><p>相对于push操作，每一次的insert() 的操作就需要大量移动移动数据了，push只有超过capacity的时候才会产生数据转移，而insert每一次都要把需要插入的位置的后面元素往后挪动一个位置，空出来后给新元素放入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure>

<p>如果插入操作真的需要很频繁，那么就应该用 LinkedList&lt;T&gt;。</p>
<h3><span id="15-删除操作">1.5 删除操作</span></h3><h4><span id="151-pop方法">1.5.1 pop()方法</span></h4><p>如果想删去Vec的元素，推荐用的是pop()方法，但注意pop() 方法只能从Vec的最后一个元素开始删除，毕竟前面也说了，试图从中间开始插入或删除一个Vec会引起数据移动操作，这是非常低效的。</p>
<p>例如我们pop出最后一个元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，pop()参数返回的是一个Option&lt;T&gt;，也就是如果array2是空的，那么就会返回None。这里返回的是Some(String)类型。pop之后，array2就只有两个元素在里面了。</p>
<p>但要注意，如果用for in的方式访问array2且没有使用引用的话，还是会把里面的资源转移走的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure>

<p>以上代码编译不通过，因为第1行for in语句中，s会逐次获得array2的资源，第4行再去访问array2的资源会编译失败。</p>
<h4><span id="152-swap_remove-方法">1.5.2 swap_remove () 方法</span></h4><p>如果真的需要删掉其中某一个元素，那么可以使用swap_remove()。它的入参是一个index，即需要删掉的元素的索引。为了避免数据移动，Vec的删除策略是这样的：把最后一个元素的值和需要删掉的index交换，并把Vec的长度减1:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before swap_remove, array1 = [<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line">after swap_remove, array1 = [<span class="number">192</span>, <span class="number">3</span>, <span class="number">231</span>, -<span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，我们打算删掉31，于是传入它的index&#x3D;1，Vec把末尾的3交换到31上，然后长度减1。同时，swap_remove还会把31返回出来，虽然这里程序没有提现。</p>
<h3><span id="16-vec内部结构探究">1.6 Vec内部结构探究</span></h3><p>Vec实际上内部是封装了一个tuple结构，tuple中第一个是指针，指向T资源，第二个是长度len，第三个是容量capacity。Vec保证当容量不足时就会自动懂扩容，因此自动扩容的出现点出现在所需内存大于capacity时。把上面的array2结构画出来，会是这样：</p>
<p><img src="https://www.jackhuang.cc/svg/Vec.svg" alt="Vec内部"></p>
<p>可以看到，上图蓝色的三个元素就是Vec内部主要封装的三个熟悉，用tuple表示为 (p, 3, 6) ，即p表示指向一组连续的内存，放String数组，3则是数组的元素个数，6则表示array2的容量，表示还可以再存放6 - 3 &#x3D; 3个String对象，且保证在此之前不会触发数据移动操作。</p>
<p>String数组后面的灰色部分是未初始化区域，也就是6 -3 &#x3D; 3这个部分。关于未初始化区域，可以详细看这里：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</a> 。</p>
<h2><span id="2-字符串string">2. 字符串String</span></h2><h3><span id="21-字符串的连接">2.1 字符串的连接</span></h3><p>两个字符串连接是最常见的编程场景，最显而易见的就是使用String的push_str和push两个方法，前者入参是一个字符串，后者入参是一个字符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;，&#x27;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure>



<p>另外一个方法，就是直接用 + 号来实现字符串的拼接，需要注意的是，+ 号方法，使用的是self而不是&amp;self，也就是说，会有所有权转移：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>

<p>还有需要注意的是，s这个参数是&amp;str，也就是它接受一个引用，也就是被加的字符串不会有所有权转移，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;，&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，s1 + &amp;s2 + &amp;s3会使得s1丢失所有权，所幸又还给了s1。这里Rust之所以这么干，其实是避免了拷贝，其内部只是通过引用拿到s2和s3的内容，拷贝到s1的后面，避免了拷贝一块新的区域来存放s1。</p>
<h3><span id="22-字符串和字节">2.2 字符串和字节</span></h3><p>String是和Vec类似的，内部结构也是一个tuple，同样放着p指向字符串，另外两个是字符串的长度和容量。这里不展开讲太多String的功能方法，稍有编程经验的人都应该知道String会提供哪些典型的方法，具体可以参考官方文档。</p>
<p>和其它语言不同，需要特别注意的是，Rust的String对象是一个UTF8格式的，这就意味着一个问题，就是如果我们索引访问一个String对象，会是返回什么？</p>
<p>如果String内容是“hello world!”，那么[0]是否应该是h，如果是h，那么它的大小就是一个字节。</p>
<p>如果String内容是“你好，世界！”，那么[0]是否应该是“你”，如果是“你”，那么它的大小就是三个字节。</p>
<p>那么到底索引访问一个String要返回多少个字节呢？Rust觉得这是一个模糊的问题，于是拒绝编译这种代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>编译器报错如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br><span class="line">  |             ^^^^ `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br></pre></td></tr></table></figure>

<p>Rust 需要使用方明确知道自己在干什么，是要返回一个字符，还是要返回某个字节，所以，如果想拿到某个字符，就明确的告诉String，我要以字符方式访问你：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>chars() 方法返回一个迭代器，即我们熟悉的iterator，可以看到做为迭代器，它是有状态的，即封装了一个当前所处位置的指针，因此需要加上mut，这样后面的nth() 方法才可以得以调用，因为nth() 方法会把当前位置往前移动，这相当于修改了状态。</p>
<p>nth返回Option&lt;Char&gt;，调用unrawp() 方法可以拿到里面的字符。</p>
<p>我们当然也可以用字节访问String对象，但这样，打印出来的就不是字符形式了，而是字节数字：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = s.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>输入出如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">189</span></span><br><span class="line">s = <span class="string">&quot;你好，世界！&quot;</span></span><br></pre></td></tr></table></figure>

<p>189其实是“你”这个字符的第二个字节数。</p>
<h3><span id="23-rust的string不简单">2.3 Rust的String不简单</span></h3><p>Rust的String并不简单，这里只是主要提了最重要的一点，即String需要我们时刻知道我们到底是造操作字符还是字节，未来遇到String的使用，还是需要多翻阅文档，这里就不去一句句翻译文档内容了。</p>
<h2><span id="3-哈希hashmap">3. 哈希HashMap</span></h2><p>hash也是日常中最常用的数据结构，Rust的HashMap使用了SpiHash算法，避免了哈希碰撞的攻击，详见：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> 。当然，其效率就有所下降。</p>
<p>这里主要讲的是我们常使用的方法，第一个当然是插入了。</p>
<h3><span id="31-插入">3.1 插入</span></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1 = &#123;:#?&#125;&quot;</span>, h1);</span><br></pre></td></tr></table></figure>

<p>可以看到，首先HashMap和Vec不一样，需要我们显式引入，其次，它的key和value类型可以在insert的时候指定，当然一旦指定好类型，之后都不允许更改了。</p>
<p>注意，由于我们没有使用引用，因此，一旦对象呗插入到HaspMap中，HashMap就有了对象的所有权，如果使用引用，那么我们就必须保证所插入的数据的生命周期大于HashMap对象的生命周期，这在后一节讲到。</p>
<h3><span id="32-查找">3.2 查找</span></h3><p>使用get方法可以获得一个Optional&lt;T&gt;，如果不存在，返回None，否则返回Somel&lt;T&gt;：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这里调用了copied方法，因为返回的是Optional&lt;&amp;i32&gt;，最后调用unwrap_or() 方法，并且提供了若是None，则返回0。</p>
<p>这里的错误处理下一节会专门讲到。</p>
<p>当然除了用ge() t方法，还是使用for语句去遍历所有的HashMap数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> h1 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="33-更新">3.3 更新</span></h3><p>如果我们在插入同样的key会发生什么呢？比如再插入一条key为”hello rust!”，value为80的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p> 输出为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>可以看到，原来的20被80给覆盖了，因此，插入同样的key会产生覆盖结果。</p>
<p>但如果我们并不想去覆盖，如果已经存在就不要去动它了，怎么办呢？此时应该调用Entry() 方法，Entry() 方法返回一个枚举，如果有值，则返回那条记录的引用，否则返回新的记录的引用，新记录的枚举中，调用它的or_insert() 方法就可以插入新值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>此时输出为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>20没有再被80覆盖。</p>
<p>如果我们要针对老值来更新新值呢？比如统计“how many word in this word ?” ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;how many word in this word ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">key</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">count</span> = h.<span class="title function_ invoke__">entry</span>(key).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">     *count += <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:#?&#125;&quot;</span>, h);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h = &#123;</span><br><span class="line">    <span class="string">&quot;in&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;this&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;how&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;?&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;many&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;word&quot;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到由于word这个词已经存在，所以，第二次调用的时候，entry()  方法返回了老的记录的音乐，此时若调用or_insert()  方法并不会更新，并且返回value的引用，后面的*count +&#x3D; 1对word这个词进行了 + 1 统计。</p>
<p>以上就是我们常用的HashMap方法，当然，还是那句话，我们使用容器的时候应该多考虑开篇说的两个问题，即什么场景使用，会怎么使用，并且应该常翻阅文档，在里面看看有没有合适的方法供我们选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.jackhuang.cc/2023/01/12/collection/" data-id="clct7a2jp0000cqulaucta5ix" data-title="Rust的容器" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/01/10/mod-and-crate/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Rust的模块化管理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%B3%E6%B3%95/">想法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/12/collection/">Rust的容器</a>
          </li>
        
          <li>
            <a href="/2023/01/10/mod-and-crate/">Rust的模块化管理</a>
          </li>
        
          <li>
            <a href="/2023/01/08/enum-and-match/">Rust中的enum和match</a>
          </li>
        
          <li>
            <a href="/2023/01/07/RustStruct/">Rust的struct类型</a>
          </li>
        
          <li>
            <a href="/2023/01/05/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/">C++右值引用场景分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jack Huang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">关于我</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>