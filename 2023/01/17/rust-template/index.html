<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Rust的模版和trait编程 | Jack Huang的技术生活</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="要开始学习Rust比较高级的内容了。 今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。 那么，今天就好好看看Rust的模板编程吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust的模版和trait编程">
<meta property="og:url" content="https://www.jackhuang.cc/2023/01/17/rust-template/index.html">
<meta property="og:site_name" content="Jack Huang的技术生活">
<meta property="og:description" content="要开始学习Rust比较高级的内容了。 今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。 那么，今天就好好看看Rust的模板编程吧。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-17T05:13:33.000Z">
<meta property="article:modified_time" content="2023-01-18T14:42:49.382Z">
<meta property="article:author" content="Jack Huang">
<meta property="article:tag" content="C&#x2F;C++,RUST,Python,nodejs,Java,Mysql">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jack Huang的技术生活" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jack Huang的技术生活</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些关于技术的思考，想法和积累</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://www.jackhuang.cc"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-rust-template" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/17/rust-template/" class="article-date">
  <time class="dt-published" datetime="2023-01-17T05:13:33.000Z" itemprop="datePublished">2023-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rust/">Rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Rust的模版和trait编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>要开始学习Rust比较高级的内容了。</p>
<p>今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。</p>
<p>那么，今天就好好看看Rust的模板编程吧。</p>
<span id="more"></span>

<!-- toc -->

<ul>
<li><a href="#%E6%A8%A1%E6%9D%BF">模板</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF">函数模板</a></li>
<li><a href="#struct%E6%A8%A1%E6%9D%BF">struct模板</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%A8%A1%E6%9D%BF">方法的模板</a></li>
</ul>
</li>
<li><a href="#trait%E7%BC%96%E7%A8%8B">trait编程</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFtrait">什么是trait</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0trait">实现trait</a></li>
<li><a href="#dispatch%E6%9C%BA%E5%88%B6">dispatch机制</a></li>
<li><a href="#trait-bond">trait bond</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<!-- tocstop -->

<h2><span id="模板">模板</span></h2><h3><span id="函数模板">函数模板</span></h3><p>假设我们需要做查处整型和字符型数组中，最大的那个元素，那么需要两个函数分别处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_int</span>(array: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_char</span>(array: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，两个函数都差不多，更抽象的写法是使用模板，即不管什么类型，都执行加法运算：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find_largest_template&lt;T&gt;的T表示T是一个种类型的模板，即模板声明， array: &amp;[T]则表示array是一种类型的slice引用，返回值这是一种类型的引用。具体类型在编译确定的代码时会确定。目前为止没错。</p>
<p>但在第4行，会报一个错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">26</span> |         <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">   |            ------- ^ - &amp;T</span><br><span class="line">   |            |</span><br><span class="line">   |            &amp;T</span><br><span class="line">   |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T`</span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> | <span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">   |                           ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `greeting` due to previous error</span><br></pre></td></tr></table></figure>

<p>意思是，需要确保调用者知道，这个模板T类型需要实现std::cmp::PartialOrd这个trait（partial order），即这个模板类型需要能做&lt;，&gt;，&lt;&#x3D;和&gt;&#x3D;的运算。这个用法相当于函数对调用方的要求，限制。也就是trait bond，即想调用这个函数，调用方必须保证模板类型能满足指定的trait。我们按照编译器的指示，加上对应的trait bond后，编译器检查无误，可以通过编译并正常运行了：</p>
<p>这个例子我们可以看出三点：</p>
<p>1、通过函数入参来推断模板类型；</p>
<p>2、返回值也可以用于模版；</p>
<p>3、函数设计方可以对模板进行trait bond设计，保证使用方知道这个trait需要满足什么特性（trait）。</p>
<h3><span id="struct模板">struct模板</span></h3><p>和函数模板差不多，我们在struct名称前加上模板声名就可以声明一个模板struct了，后面的字段可以定义对应的类型字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    number: T,</span><br><span class="line">    coord: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时，我们也和函数模板一样（函数模板通过入参来推断T），在初始化struct的字段时，推断出各个字段的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">postion</span> = Point &#123;</span><br><span class="line">    number: <span class="number">100</span>,   <span class="comment">// 表明Point的T是i32</span></span><br><span class="line">    coord: Coord &#123; <span class="comment">// 表明Point的U是Coord</span></span><br><span class="line">        x: <span class="number">23</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">        y: <span class="number">84</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似的还有enum的模板，这在之前学习Result和Optional的时候遇到过，不多说了。</p>
<h3><span id="方法的模板">方法的模板</span></h3><p>方法的模板稍显复杂，先看一个简单的例子，例如，我们给前面的例子中Coord&lt;T&gt;添加一个方法用以计算坐标到o点的距离，这个方法是针对T为f64的特化版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Coord</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">distance_to_o</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果要写特化，只需要在impl Coord后面实例化T即可。</p>
<p>当然也可以不特化，但如果需要支持运算就要加上trait bond，这里用打印x和y来举例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: std::fmt::Display&gt; Coord&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">show</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到相对特化版本，泛型版本需要在impl&lt;T&gt;中对T进行trait bond指定，让调用方知道，想使用这个方法，T必须实现了std::fmt::Display，因为方法实现中调用了println!宏。</p>
<p>总结来说，特化需要放在struct名中指定具体类型，而泛型需要放在impl中指定trait bond。</p>
<p>我们还可以对泛型为T的struct加上泛型为U的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>, U&gt; Coord&lt;T, U&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>&lt;P, Q: <span class="built_in">Copy</span>&gt;(&amp;<span class="keyword">self</span>, other: &amp;Coord&lt;P, Q&gt;) <span class="punctuation">-&gt;</span> Coord&lt;T, Q&gt; &#123;</span><br><span class="line">        Coord &#123; x: <span class="keyword">self</span>.x, y: other.y &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">3.14</span>,</span><br><span class="line">        y: <span class="number">2.718</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">mix</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:#?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是把两个泛型类型不一样的Coord合成第三种泛型类型不一样的过程，可以看到，impl&lt;T: Copy, U&gt;可以指定对某一类struct进行添加方法，即对struct这一层的模板声明，而 mix&lt;P, Q: Copy&gt;则是对方法的参数进行某一类的指定，即对方法这一层的声明，最后在返回值的地方返回混合类型的Coord&lt;T, Q&gt;。</p>
<p>这里还需要注意的时候我们在一些类型后面加上了Copy trait，因为mix的入参都是引用，但返回的Coord&lt;T, Q&gt;不是，所以值必须通过拷贝来赋值而不是直接赋值。否则，如果是直接赋值，也就是返回值的T和Q类型分别是引用的话，那么引用入参可能生命周期不如返回参数长，返回值中的字段引用的数据资源可能已经被销毁了，造成悬空指针。</p>
<h2><span id="trait编程">trait编程</span></h2><h3><span id="什么是trait">什么是trait</span></h3><p>trait英文原意是特性的意思，这里有一个很好的比喻，可以快速理解计算机编程语言的trait的特性和用法。我们怎么知道某个东西是一只兔子？兔子的trait是：</p>
<p>1、耳朵长；</p>
<p>2、眼睛红；</p>
<p>3、跑起来像跳；</p>
<p>4、吃胡萝卜。</p>
<p>假设我们总结出来兔子的trait如上四条，那么，如果遇到满足以上四条trait的东西，我们就认为它是兔子，哪怕我把我的MacBook笔记本按照这四个trait伪装起来，那我的MacBook笔记本就是一只兔子。因为实际上，我们关心并不是到底是兔子还是笔记本，而是它是否有这些trait。</p>
<p>也就是说，其实我们并不关心某个东西是什么？我们只关心的是某个东西是否满足某个或者某些trait，满足了，那就行了，具体是什么，其实关系不大。</p>
<p>这就是我们在面向对象编程里面说的，我们要面向接口编程。这里，就是说成：我们要面向trait编程。</p>
<h3><span id="实现trait">实现trait</span></h3><p>了解了什么是trait，那么就知道trait是做什么的了，其实就是给各种类型定义行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    headline: <span class="type">String</span>,</span><br><span class="line">    location: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    reply: <span class="type">bool</span>,</span><br><span class="line">    retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.headline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">        username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        reply: <span class="literal">true</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用了一个简单的例子，Article和Tweet有不同的字段，同时定义了一个trait Summary，然后针对Article和Tweet分别写出了不同的summarize方法实现。这样，不管Article和Tweet字段怎么样，他们都有Summary这个trait，都可以调用这个trait下的方法。自然有人问，各自定义自己的summarize方法不就行了吗？这个例子的确如此，但假设我们有一个函数去专门处理Summary，做这个事情的人不想关心具体是什么东西，也许是Article，或者是Tweet，甚至可能是一只兔子？总之，对他来说，只要是Summary就行，想使用他的服务的人去想办法把自己变成Summary吧，也就是，只要有Summary这个trait，他的函数就能处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: &amp;<span class="keyword">dyn</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> collect_summary这个函数入参是&amp;dyn Summary，是一个引用，其次dyn是表示运行时动态（dynamic）类型，即编译时不知道Summary背后的东西是什么，需要运行时才能确定，Summary就是我们的trait。加起来表示：collect_summary函数接受一个Summary trait动态引用。</p>
<p>这样，编写trait和对trait进行再封装再处理的两个人可以解藕编程了，他们之间只需要约定好trait即可。</p>
<h3><span id="dispatch机制">dispatch机制</span></h3><p>顺带一提，这里把dyn改成impl也可以正常运行，那么dyn和impl有什么区别呢？还有，为什么dyn前面那里需要用引用 &amp; 呢？本小节讲明白。</p>
<p>其实这里是Rust的动态运行机制，当涉及到多态编程时，Rust有一种机制来决定到底应该用哪个具体类型来执行，这个机制叫“dispatch”。而dispatch机制分为静态和动态两种，静态dispatch，即编译时期就知道具体是哪个类型了，动态dispatch，则需要在运行时期才能知道是什么类型。</p>
<p>impl trait则是静态dispatch，也即，Rust编译器在编译的时候就会知道都有哪些类型会使用impl trait，并把这些impl trait代码都生成好，运行时直接调过去就行，运行时不需要判断。例如上面的例子中，我们修改collect_summary函数为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在调用的时候，直接传实现了Summary trait的对象指针进去即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">    headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">    author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">    username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    reply: <span class="literal">true</span>,</span><br><span class="line">    retweet: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(a);</span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(t);</span><br></pre></td></tr></table></figure>

<p>因为是静态dispatch，Rust编译器需要在编译的时候就确定到底谁调用了collect_summary，当看到collect_summary(a)和collect_summary(t)会分别生成对应的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Article) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Tweet) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是这样就实现了编译器的多态，即静态dispatch。（额外提示，此处a和t会失去所有权）</p>
<p>而动态dispatch，即dyn trait，编译时期编译器无需关心具体是谁调用了collect_summary，它只需要记得，collect_summary接受一个实现了Summary trait的类型做为参数即可，由于编译时期无需关心collect_summary的入参具体类型，也就不知道这个入参的大小，即sizeof大小，此时若不是用引用，那么在不知道sizeof大小的情况下，是无法生成collect_summary函数的代码的（因为要确定内存栈大小）。因此，此时必须使用&amp;dyn。编译器也不会生成各种类型入参的collect_summary版本，这些事情都要放到运行时期才确定。</p>
<h3><span id="trait-bond">trait bond</span></h3><p>trait bond前面已经用到，就是对模板 T 进行有所限制，只有满足特定trait的类型才能实例化。如果需要多个trait限定，就用 + 号来增加trait限定。比如，给Coord增加一个方法，只有实现了对比trait和现实trait的类型才能实例化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">ShowMax</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; ShowMax <span class="keyword">for</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;max = &#123;&#125;&quot;</span>, c.<span class="title function_ invoke__">show_max</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中可以看到，我们对实现ShowMax这个trait进行了trait bond限定，只有能做到Display（进行格式化显示）和PartialOrd（进行大小判断）的类型才能调用。trait bond有助于编译器检查类型是否满足条件。</p>
<h2><span id="总结">总结</span></h2><p>本章内容比较抽象，有一定的编程经验的人才能看懂，总结几个细节小点：</p>
<p>1、注意模板声明的位置。想使用模板必须先声明，函数模板在函数名称后面声明，struct在struct类型名称后面声明，方法模板则在impl后面声明；</p>
<p>2、struct模板和方法模板可以是两个不同的维度各自声明自己的模板；</p>
<p>3、对trait编程，实现模块间解藕；</p>
<p>4、区分impl trait（静态dispatch，编译时确定）和dyn trait（动态dispatch，运行时确定）两种dispatch机制，已经此时引用的含义；</p>
<p>5、使用trait bond保证模板能有某种trait，帮助编译器检查前置条件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.jackhuang.cc/2023/01/17/rust-template/" data-id="cld1skus2000ax9ulbfdd8zht" data-title="Rust的模版和trait编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/01/16/rust-err/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Rust的错误处理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%B3%E6%B3%95/">想法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/17/rust-template/">Rust的模版和trait编程</a>
          </li>
        
          <li>
            <a href="/2023/01/16/rust-err/">Rust的错误处理</a>
          </li>
        
          <li>
            <a href="/2023/01/12/collection/">Rust的容器</a>
          </li>
        
          <li>
            <a href="/2023/01/10/mod-and-crate/">Rust的模块化管理</a>
          </li>
        
          <li>
            <a href="/2023/01/08/enum-and-match/">Rust中的enum和match</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jack Huang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">关于我</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>