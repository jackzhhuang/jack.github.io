<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack 热爱积累与沉淀</title>
  
  <subtitle>这里将记录一些关于技术的积累和沉淀</subtitle>
  <link href="https://www.jackhuang.cc/atom.xml" rel="self"/>
  
  <link href="https://www.jackhuang.cc/"/>
  <updated>2023-06-10T09:26:22.392Z</updated>
  <id>https://www.jackhuang.cc/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust异步编程(五)—— buffer 和 flatten</title>
    <link href="https://www.jackhuang.cc/2023/06/10/rust-async-flatten/"/>
    <id>https://www.jackhuang.cc/2023/06/10/rust-async-flatten/</id>
    <published>2023-06-10T07:47:30.000Z</published>
    <updated>2023-06-10T09:26:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>日积跬步，慢慢积累异步编程的知识。</p><p>未来异步编程将朝两个方向：</p><p>1、异步编程的应用，主要对 futures 等 Rust 库进行探索，比如今天要讲的 buffer 函数和 flatten 函数；</p><p>2、对底层异步实现进行探索，比如实现自己的Arc，Mutex。</p><span id="more"></span><h2 id="buffer-函数"><a href="#buffer-函数" class="headerlink" title="buffer 函数"></a>buffer 函数</h2><p>futures 库中的 buffer 函数上一次讲过，它其实是一个特殊的 stream，一般 stream 调用 next（这里顺带一提，next 会取出元素），返回的是其中的元素，而 buffer 调用 next，则是返回元素调用 await 后的返回值，因此，stream 想变成 buffer 这个特殊的 stream，必须保证其中元素是一种 future。</p><p>关于 buffer 函数，有三个需要注意的：</p><h3 id="buffered-self-n-usize-函数"><a href="#buffered-self-n-usize-函数" class="headerlink" title="buffered(self, n: usize) 函数"></a>buffered(self, n: usize) 函数</h3><p>它是一个按顺序执行 future 的函数，即前一个 future 没有结果前，后面的 future 都处于等待状态，从这点上讲，它没有并发效果。但能保证任务顺序执行，对于有任务顺序执行的异步需求是一个不错的函数。</p><p>其中的 n 表示 buffer 的大小，个人目前觉得这个大小对于顺序执行来说没有太大的影响。</p><h3 id="buffer-unordered-self-n-usize-函数"><a href="#buffer-unordered-self-n-usize-函数" class="headerlink" title="buffer_unordered(self, n: usize) 函数"></a>buffer_unordered(self, n: usize) 函数</h3><p>和 buffered 相比，<code>buffer_unordered(self, n: usize)</code> 则是并发执行，即我们的 executor 会遍历 buffer 中的所有 future，并询问其执行状态。因此，n 将表示其并发执行的数目。因此，如果 n = 1，此时就相当于顺序执行了。</p><h3 id="buffer-的大小与-channel-的大小"><a href="#buffer-的大小与-channel-的大小" class="headerlink" title="buffer 的大小与 channel 的大小"></a>buffer 的大小与 channel 的大小</h3><p>上一节说了 future-stream-sink 模型（<a href="https://www.jackhuang.cc/2023/05/31/rust-async/），其中有两个地方需要设置">https://www.jackhuang.cc/2023/05/31/rust-async/），其中有两个地方需要设置</a> buffer 大小，一个是 stream 生成 buffer 的时候的大小，一个是 sink 在异步接收结果的时候 buffer 的大小。</p><p>这两个大小有什么联系呢？前者表示并发数量，后者表示结果缓存的数量，正常情况下，没有绝对的联系，但试想一个极端的情况，如果并发数量远大于 channel 的通道 buffer，那么 channel 的 buffer 会被瞬间塞满，出现处理结果遭遇瓶颈。由于 buffer 的结果不能发送给 channel，stream 这边的 buffer 也遭遇瓶颈，最终阻塞整个异步流程，继续以上一节为例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bob</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;bob&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ryn</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;ryn&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey, bob, ryn]).<span class="title function_ invoke__">buffer_unordered</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> sender, <span class="keyword">mut</span> receiver) = futures_channel::mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = receiver.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">send_result</span> = sender.<span class="title function_ invoke__">send_all</span>(&amp;<span class="keyword">mut</span> buffer).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sending is done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 上面的代码中，<code>buffer_unordered</code>  的大小为2，而 <code>channel</code> 大小为 1，此时有5个 future 等待执行，在处理结果的 loop 中，我加了一个死循环，使其只能处理一个结果，造成两个 buffer 堆积，首先 channel 的 buffer 结果得不到处理，造成 send 阻塞，接着 stream 这边的 buffer 产生结果后无法送给 channel，也阻塞，最终整个系统都停止运转了。可见，如果两边的处理效率不同，较慢的那一个会成为整个系统的瓶颈。</p><h2 id="flatten-函数"><a href="#flatten-函数" class="headerlink" title="flatten 函数"></a>flatten 函数</h2><p>buffer 函数会触发 stream 的 future，返回 future 的结果。而 flatten 函数结合 buffer 的使用，还可以处理 future 返回 future 的情景。即，如果一个 future 返回了另一个 future，我们可以使用 flatten 函数获得最后的 结果，而忽略中间过程。例如我们多增加一层 future，套用在原来的 future 上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyFuture2</span> &#123;</span><br><span class="line">    duration: <span class="type">u64</span>,</span><br><span class="line">    start_time: <span class="type">u64</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyFuture2</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(duration: <span class="type">u64</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyFuture2 &#123;</span><br><span class="line">            duration,</span><br><span class="line">            start_time: SystemTime::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_secs</span>(),</span><br><span class="line">            name,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">MyFuture2</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Pin::&lt;<span class="type">Box</span>&lt;MyFuture&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">now</span> = SystemTime::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_secs</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pass</span> = now - <span class="keyword">self</span>.start_time;</span><br><span class="line">        <span class="keyword">if</span> pass &lt; <span class="keyword">self</span>.duration &#123;</span><br><span class="line">            cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>();</span><br><span class="line">            <span class="keyword">return</span> std::task::Poll::Pending;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::task::Poll::<span class="title function_ invoke__">Ready</span>(<span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(MyFuture::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.duration, <span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>()))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，MyFuture2 返回了之前的 Future，此外，我们的 MyFuture 的结果需要修改成标准的 Result<T, SendError>，这样我们的 flatten 函数才能处理最后一个 future 结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = anyhow::<span class="type">Result</span>&lt;<span class="type">String</span>, SendError&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">now</span> = SystemTime::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_secs</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pass</span> = now - <span class="keyword">self</span>.start_time;</span><br><span class="line">        <span class="keyword">if</span> pass &lt; <span class="keyword">self</span>.duration &#123;</span><br><span class="line">            cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>();</span><br><span class="line">            <span class="keyword">return</span> std::task::Poll::Pending;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is completed, &#123;now&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="keyword">return</span> std::task::Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>())); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的 main 函数变成了这样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture2::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture2::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture2::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey]).<span class="title function_ invoke__">map</span>(|fut| fut.<span class="title function_ invoke__">flatten</span>()).<span class="title function_ invoke__">buffer_unordered</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> sender, <span class="keyword">mut</span> receiver) = futures_channel::mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = receiver.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = sender.<span class="title function_ invoke__">send_all</span>(&amp;<span class="keyword">mut</span> buffer).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sending is done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和之前相比，我们在从 stream 转为 buffer 的时候，多了一步 map，即 stream 的 MyFuture2 对象调用 一次 flatten，这样 buffer 就会返回最终的 future 结果，不需要我们外部再处理一层 future 逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日积跬步，慢慢积累异步编程的知识。&lt;/p&gt;
&lt;p&gt;未来异步编程将朝两个方向：&lt;/p&gt;
&lt;p&gt;1、异步编程的应用，主要对 futures 等 Rust 库进行探索，比如今天要讲的 buffer 函数和 flatten 函数；&lt;/p&gt;
&lt;p&gt;2、对底层异步实现进行探索，比如实现自己的Arc，Mutex。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（四）—— 基本的 future， stream 和 sink 应用</title>
    <link href="https://www.jackhuang.cc/2023/05/31/rust-async/"/>
    <id>https://www.jackhuang.cc/2023/05/31/rust-async/</id>
    <published>2023-05-31T15:20:28.000Z</published>
    <updated>2023-06-02T16:10:54.776Z</updated>
    
    <content type="html"><![CDATA[<p>futures 库是 Rust 最最基本的异步编程库，这篇文章将总结大部分 futures 库的使用方法，其底层原理将一带而过，见前面的文章。我们将从最简单的 Future 开始，最后到最复杂的应用。其过程是我们在实际项目中最常用的。本节需对前面的异步编程底层模型有所了解，且对 Rust 基本的用法有所了解（刷 leetcode 容易题没有觉得特别难就能用 Rust 的方法写出来的水平即可。）</p><p>网上很多这方面的文章，但要么复杂庞大，导致难以理解（比如官方文档，或者一些一股脑堆代码的长篇博文），要么过于简单，讲不出重点。这里力求用最最最简单的代码去把最最最核心的异步编程基础应用讲出来，相信我，看完这篇文章，对 Rust 的异步编程绝对有核心的理解。</p><span id="more"></span><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>获得一个 Future 对象有两种方法，最简单的就是定义一个 async 开头的函数，其函数体就是 Future 执行的内容。但遇到复杂的流程，还是需要自己去 impl Future trait 的，下面我们实现一个 Future trait，其功能很简单，就是过一段时间返回一个 String 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    duration: <span class="type">u64</span>,</span><br><span class="line">    start_time: <span class="type">u64</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(duration: <span class="type">u64</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyFuture &#123;</span><br><span class="line">            duration,</span><br><span class="line">            start_time: SystemTime::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_secs</span>(),</span><br><span class="line">            name,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">now</span> = SystemTime::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_secs</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pass</span> = now - <span class="keyword">self</span>.start_time;</span><br><span class="line">        <span class="keyword">if</span> pass &lt; <span class="keyword">self</span>.duration &#123;</span><br><span class="line">            cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>();</span><br><span class="line">            <span class="keyword">return</span> std::task::Poll::Pending;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is completed, &#123;now&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="keyword">return</span> std::task::Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>())); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 poll 函数，获取当前时间，然后和初始化时间相比，若超过特定时间，则返回 name，否则调用 <code>cx.waker().wake_by_ref()</code> 将这个 Future 对象放回就绪队列待下一次 executor 取出来重新执行 poll 函数，直到返回 Ready 为止。也就是说，如果 <code>pass &lt; self.duration</code> 不满足，这这个 Future 对象会一直被放回就绪队列， poll 函数会不停的被调用，直到 ready 返回。</p><p>此时，调用方会一直阻塞在 await 上，直到 ready可以返回：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">        jack.<span class="keyword">await</span>;</span><br><span class="line">        rose.<span class="keyword">await</span>;</span><br><span class="line">        janey.<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，会顺序执行 jack， rose 和 janey，也就是一共需要 3 + 5 + 2 = 10 秒钟执行完，且是顺序执行。因为 await 会触发对应的 poll 调用，而 poll 中不被重新返回就绪队列的路径是 <code>pass &lt; self.duration</code> 不成立，返回 ready。</p><p>那么这就是基本的异步编程。</p><p>于是很多人就会有疑惑：这不是异步编程， 因为 jack，rose 和 janey 是顺序执行的，这只是换个法子在同步执行。这么说是完全正确的，的确这是同步的，jack 没有完成是轮不到 rose 的。这里不去过多的解释，我们先把 Future 的能力记下，继续往下。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>stream 是什么？我们最熟悉的 iterator 就是 stream：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(|item| item &lt;&lt; <span class="number">1</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure><p>那么我们用 stream 实现一次：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = futures::stream::<span class="title function_ invoke__">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).<span class="title function_ invoke__">map</span>(|item| item &lt;&lt; <span class="number">1</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;().<span class="keyword">await</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出是和之前一样的，总之，stream 就是 iterator，和之前唯一不同的是，我们的 collect 调用有一个 await 尾巴。这是因为 Stream 是异步编程，它是基于 Future 实现的，所以只有调用了 await 才干活，否则，只是返回一个 Future 对象。</p><p>所以，stream 就是 iterator，我们把 future 对象放到 stream 就可以使用 stream 的方法调用里面的 future await 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey]).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;().<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> result &#123;</span><br><span class="line">            item.<span class="keyword">await</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把 stream 转成一个集合，然后遍历这个集合，因为里面是 future，所以可以调用 await。</p><p>但这么写好像没获得什么好处。其实还是有好处的，就是上面的 3 到 5 行和 7 到 10 行解藕了，也就是写 stream 的人并不需要知道 jack，rose 和 janey。这就是 stream 带来的第一个好处：只需要知道里面的东西是一个 future 和其返回值就行，至于具体是什么 future（是 jack，rose还是 bob， bill 统统无需关心。），怎么实现的，不需要关心。</p><p>这个好处似乎和异步编程没什么关系，我们继续往下。</p><p>如果 stream 是专门为 future 设计的 iterator，那应该有写特殊方法帮我们出发 future，比如 buffered：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buffer</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey]).<span class="title function_ invoke__">buffered</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = buffer.collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;().<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前直接用 collect 把 future 打包进 Vec 相比，这里先用 buffered 函数转成 buffer 对象，然后再去 collect，这时的 result 就是 future ready 返回的结果了，也就是说我们只需要调用一次 await，就可以把 stream 的 future 都触发，并且把结果放进一个 collect 里面。</p><p>如果运行上面的代码，会发现一个现象，stream 的 future 同时运行了，不再是先运行前一个再触发后一个了。我们终于得到了一个并发编程的代码，关键是，我们没有使用线程。这得益于之前讲的异步编程模型，简单说，就是三个 future 都被放到就绪队列，executor 去不停的检查它们的返回值，若 pending，由于前面说的 wake 调用会被重新放回就绪队列，若 ready 则返回结果放入 Vec。这三个 future 不停的被遍历，这也就实现了并发。</p><p>尽管现在已经是并行执行三个 future，但我们可以不可以做到，先完成的 future 先输出呢？当然可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buffer</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey]).<span class="title function_ invoke__">buffer_unordered</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = buffer.collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;().<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前，我们用了 <code>buffer_unordered</code> 这个方法，也就是无序的收集结果，因此，像 janey 这样只需要 2 秒钟就完成的任务就先输出了。</p><p>上面的 1024 表示 buffer 可以并发执行多少 future，若改成 1，那么就相当于顺序执行了，而改成 0，相当于就绪队列放不下任何 future，这样将永远阻塞。实际上， buffer 是一个特殊的 stream，stream 能做的它也能做，不同点是，buffer 直接给出的是 future 的运行结果。</p><h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>前面我们用了 stream 去并发执行 future，但有个问题需要解决，即结果都是所有的 future 都运行完后才返回的（尽管它们是并发执行），是否可以做到来一个结果就输出一次呢？当然可以，我们需要 sink 这个概念帮我们完成。</p><p>sink 不是什么特殊的东西，它其实是我们入门 Rust 时学习的、最熟悉不过的 <code>mpsc::channel</code> 概念相关，即 sender 和receiver。而 sink 其实就是 sender。我们下面就把 sink 换成 sender 来说，会发现其实 sink 很好理解。</p><p>既然是 sender，那么就知道 sender 一边发结果，receiver 一边收结果，只要有结果，就及时 send 给 receiver：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">jack</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rose</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">janey</span> = MyFuture::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="string">&quot;janey&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = futures::stream::<span class="title function_ invoke__">iter</span>([jack, rose, janey]).<span class="title function_ invoke__">buffer_unordered</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> sender, <span class="keyword">mut</span> receiver) = futures_channel::mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = receiver.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;result:?&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    sender.<span class="title function_ invoke__">send_all</span>(&amp;<span class="keyword">mut</span> buffer).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前相比，我们加入了 <code>futures_channel::mpsc::channel(1024)</code> 来生成 sender 和 receiver，同时开启一个线程用于接受结果，而主线程，调用 <code>send_all</code>  方法将我们的 future 执行并把结果发送出去，哪个 future 有了结果，哪个就被发送。</p><p>如果运行，会发现 future 的结果都能及时打印出来了。</p><p>这里有几个要说的：</p><p>1、这里开启了线程，当然可以把 sender 和 receiver 统一封装到一个 future 类里面去在同一个线程中并发执行，但并发如果头铁就是不想多线程，那么是很僵化的，多线程可以利用多 CPU 的能力，future await 的引入，主要是1、解决 IO 阻塞导致上下文切换的问题；2、降低编写并发代码的复杂度。</p><p>2、上面的 <code>mpsc::channel(1024)</code> 表示发送队列的大小。这里要注意以下三者的关系：buffer 的大小，channel 的大小和 receiver 的处理能力。假设有这么个极端情况，receiver 忙死了，那么 channel 通道就会被塞满，进而导致 buffer 的并发量下降到 0，虽然有 <code>unbounded</code> 替代 channel，但个人认为这比较危险，因为如果整个系统堵死了，可以被监控到，但使用 <code>unbounded</code> 是要等到内存耗尽才可能触发到系统异常，这个时候再去处理已经晚了。</p><p>3、注意一个小细节，即 future 的返回值从 String 变成了 <code>Result&lt;String, SendError&gt;</code> ，这里没贴出这个变化的代码。因为我们要时刻监控 channel 队列，如果 send 失败，应该有所处理，因此 sender 要求 future 必须用 Result 来做 future 的返回值。</p><p>4、不要自己实现 sink trait。尽管可以这么做，但不要这么做，因为大概率，我们写的代码都不如官方的实现优秀。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章引入了 stream（一个异步 iterator），buffer（一个特殊的 stream，collect 返回的是 future 的结果） 和 sink（sender，让我们使用 receiver 及时处理 future 的输出结果） 的概念，是 Rust 异步编程基本概念，后面会分享更多细节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;futures 库是 Rust 最最基本的异步编程库，这篇文章将总结大部分 futures 库的使用方法，其底层原理将一带而过，见前面的文章。我们将从最简单的 Future 开始，最后到最复杂的应用。其过程是我们在实际项目中最常用的。本节需对前面的异步编程底层模型有所了解，且对 Rust 基本的用法有所了解（刷 leetcode 容易题没有觉得特别难就能用 Rust 的方法写出来的水平即可。）&lt;/p&gt;
&lt;p&gt;网上很多这方面的文章，但要么复杂庞大，导致难以理解（比如官方文档，或者一些一股脑堆代码的长篇博文），要么过于简单，讲不出重点。这里力求用最最最简单的代码去把最最最核心的异步编程基础应用讲出来，相信我，看完这篇文章，对 Rust 的异步编程绝对有核心的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>并发开发模型</title>
    <link href="https://www.jackhuang.cc/2023/04/16/concurrency-basic/"/>
    <id>https://www.jackhuang.cc/2023/04/16/concurrency-basic/</id>
    <published>2023-04-16T10:46:39.000Z</published>
    <updated>2023-05-31T15:24:13.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发，英文 concurrency，直译就是同时发生。并行，parallelism，直译就是平行。所以虽然一字之差，意思却是不同的，但也很好理解，前者是同时发生，后者是一起做事情。</p><p>最简单的比喻就是肯德基点餐场景——几个顾客同时点餐，服务员们一个准备汉堡，一个准备咖啡。顾客同时点餐就是并发，服务员们分工去满足顾客就是并行。</p><p>有了清楚的认识并行并发概念后，在处理异步问题的时，应该考虑，我们是解决了并行问题，还是解决了并发问题亦或都能解决？</p><p>当然，为了不啰嗦或者咬文嚼字，偶尔我们可能会只用“并发”或者“并行”来代表“并发和并行”两个概念。</p><span id="more"></span><h3 id="从大到小的并发场景"><a href="#从大到小的并发场景" class="headerlink" title="从大到小的并发场景"></a>从大到小的并发场景</h3><p>我们先从小到大的看一下我们都会遇到什么样的并行场景。</p><h4 id="位级并行"><a href="#位级并行" class="headerlink" title="位级并行"></a>位级并行</h4><p>即 8 位或者 16 位等基本指令位数，例如相对于 8 位的 CUP，64 位的CPU 可以一次并行处理 8 个 8 位的数字。</p><h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>CPU 执行指令的时候实际上会预先判断后续分支，先把可能的分支给执行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> is_set = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number = <span class="number">99</span>;</span><br><span class="line">  is_set = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_set) &#123;</span><br><span class="line">    <span class="built_in">print</span>(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">start_thread</span>(set_number);</span><br><span class="line"><span class="built_in">start_thread</span>(check_number);</span><br></pre></td></tr></table></figure><p> 上述伪代码中，check_number 有可能优先执行，且因为 is_set 和 number 没有必然的逻辑联系， CPU 可能会异步执行第 5 和第 6 行代码，即可能先执行 <em>is_set = true</em> ，因此 CPU 会先看到 is_set 是 true 了，然后打印 number 值，因此，有可能会输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这就是指令集的并行优化。</p><h4 id="任务级并行"><a href="#任务级并行" class="headerlink" title="任务级并行"></a>任务级并行</h4><p>即每个 CPU 或者每台服务器并行处理。</p><p>CPU，cache 和内存的并行：</p><p><img src="https://www.jackhuang.cc/svg/concurrency-memeory-cpu.drawio.svg" alt="CPU, cache 和 内存"></p><p>网络各台服务器其实也是一个特大型计算机，它们的结构和计算机内部有点相似：</p><p><img src="https://www.jackhuang.cc/svg/concurrency-network-task.svg" alt="网络的并行任务"></p><h3 id="学习的过程应该考虑什么问题"><a href="#学习的过程应该考虑什么问题" class="headerlink" title="学习的过程应该考虑什么问题"></a>学习的过程应该考虑什么问题</h3><p>市面上五花八门的并行（并发）模型，几乎每个人都有他们看家秘诀去解决各种并行并发问题，但软件没有银弹，没有灵丹妙药，因此，过去，现在和将来，无论遇到什么并发模型，都应该谨慎而不是直接拥抱，每一种模型都一定是一种取舍方案，我们获得了什么好处，由此带来什么问题都应该考虑到，因此，我们学习完一个并发模型，都应该考虑：</p><p>1、这个模型解决了并发还是并行还是都解决了？</p><p>2、这个模型属于上述三级的哪个架构？</p><p>3、这个模型是否有利于写出容错性强货解决分布式问题的代码？</p><h2 id="锁与线程"><a href="#锁与线程" class="headerlink" title="锁与线程"></a>锁与线程</h2><h3 id="简单锁"><a href="#简单锁" class="headerlink" title="简单锁"></a>简单锁</h3><p>我们最常见的就是使用一把锁来控制资源的访问，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ++number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">get_number</span>() &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">incr_number</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_large_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">get_number</span>() &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;it is large than 100&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">start_thread</span>(<span class="built_in">loop_incr_number</span>());</span><br><span class="line"><span class="built_in">start_thread</span>(<span class="built_in">check_large_number</span>());</span><br></pre></td></tr></table></figure><p>我们的本意是，一个线程增加 number，另一个线程看 number 是否大于等 100，满足条件后，第一个线程退出，第二个线程打印 “it is large than 100” 后也退出。</p><p>目前看似乎这么写没什么问题。但有人会问：为什么第 11 行和第 17 行要写成不等式而不是等式呢？</p><p>这就是前面说的，我们在处理多线程问题的时候，需要做到易于写出难以写错的代码，即使写错了，也要让错误尽早的暴露出来。这里，使用不等号就是为了防止当有多个线程调用 incr_number 时，while (get_number() != 100) 将有可能进入死循。</p><p>因为假设 A 和 B 线程都调用 loop_incr_number，它们都通过 while (get_number() != 100) 的检查，此时假如 number 为 99，那么，A 和 B 都要去调用 incr_number，最后将可能导致 number 为 101。此时，while (get_number() != 100) 不可能再会满足，AB 线程都要进入死循环。</p><p>是的，我们的代码对使用方没有任何限制，使用方可能会用多个线程来调用我们的 loop_incr_number，我们作为 loop_incr_number 的设计方，应该有所设计，而不能仅仅只是在文档上写出 —— 这个函数不允许多个线程调用（虽然我知道早期 C 函数有这样的做法，但这个不是挡箭牌。）</p><p>那么，是不是使用不等号就没问题了呢？也未必。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ++number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，number 可能因为线程 cache 的原因，导致若有两个线程都在跑 incr_number 函数的话，可能前一个函数的结果被后一个函数的结果覆盖的情况。细节是，每一个线程都有自己的 cache，若第一个线程 number 的 cache 是 10，第二个也是 10，第一个线程执行 ++，变为 11，第二个也因为是 10 执行 ++，结果也是 11，那么最后虽然两个线程执行了两次 ++，但结果却是 11。</p><p>为了告诉线程， number 是有多线程访问的，不要使用 cache 优化，需要给 incr_number 函数加锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">synchronized</span> <span class="title">incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ++number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去对写操作进行加锁操作就可以了，但若读操作若不加锁，也是会被 cache 影响，所以，即使是读操作，也应该加上同步锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="keyword">synchronized</span> <span class="title">get_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这时，loop_incr_number 和 check_large_number 应该都不会有问题了，但使用 synchronized 这样的基于代码的锁是非常有局限性的，因为它不能主动解锁，实际上最好使用 mutex 这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex.<span class="built_in">lock</span>();</span><br><span class="line">  ++number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 mutex 用 RAII 的管理锁方式去加锁，可以主动释放锁。使用 mutex 的好处是可以探测是否会被阻塞，从而减少了死锁的风险：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">incr_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Lock lock = mutex.<span class="built_in">trylock</span>();</span><br><span class="line">  <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Lock lock = mutex.<span class="built_in">trylock</span>();</span><br><span class="line">  <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">start_thread</span>(incr_number);</span><br><span class="line"><span class="built_in">start_thread</span>(get_number);</span><br></pre></td></tr></table></figure><p>使用 trylock 可以给我们机会探测是否加锁成功。 相比最开始的 synchronize 就灵活很多。</p><h3 id="两个锁引起的死锁"><a href="#两个锁引起的死锁" class="headerlink" title="两个锁引起的死锁"></a>两个锁引起的死锁</h3><p>一般来说，一个资源就需要一把锁，若两个资源，那么就需要两把锁来控制对它们的访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_set = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_number.<span class="built_in">lock</span>();</span><br><span class="line">  number++;</span><br><span class="line">  mutex_is_set.<span class="built_in">lock</span>();</span><br><span class="line">  is_set = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_is_set.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (is_set) &#123;</span><br><span class="line">    mutex_number.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">start_thread</span>(check);</span><br><span class="line"><span class="built_in">start_thread</span>(print);</span><br></pre></td></tr></table></figure><p>上面的伪代码中，严格遵循了一个资源一把锁的原则，这当然是好的，但 check 和 print 加锁顺序正好相法，若两个线程各跑一个函数，极有可能造成死锁：check 线程获得了 mutex_number 锁，等 mutex_is_set，而 print 线程获得了 mutex_is_set 锁，等 mutex_number 锁，两边互等。</p><p>当然可以用 trylock 的方式避免，但这样相当于加大了失败的概率，有一定的损耗。</p><h3 id="好的并发编程建议"><a href="#好的并发编程建议" class="headerlink" title="好的并发编程建议"></a>好的并发编程建议</h3><p>以上算是简单的过了一遍使用简单锁和原始线程函数来解决问题的流程。可以看到，在实践编程中，若使用原始的锁和线程，往往会滋生很多潜在的危险：</p><p>1、加锁没有考虑全面，造成出现由于 cache 优化的机制而有幻读的风险；</p><p>2、使用 synchronize 这样的锁缺少灵活性；</p><p>3、两个线程加锁顺序的不一致造成死锁。</p><p>因此，一般情况下，尤其是应对复杂编程上下文环境时，不建议直接使用语言提供的原生 API 接口进行加锁和生成线程。应该使用有保障，封装优秀的并发编程库。</p><p>此外，跑线程加锁这样的事情应该有章法可循。这里引入最经典最简单的模型：生产者和消费者模型。一方面标准化并发模型，另一方面杜绝了以上讨论到的坑点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  producer.<span class="built_in">lock</span>();</span><br><span class="line">  nunmber++;</span><br><span class="line">  producer.<span class="built_in">send</span>(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  consumer.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="type">int</span> number = consumer.<span class="built_in">receive</span>();</span><br><span class="line">  <span class="built_in">print</span>(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，原来简单使用 mutex 来做同步控制，现在使用了生产者-消费者（producer- consumer）来同步，其和原来最本质区别是，number 这个对象不再是两个函数共享，而是彻底解藕。这种编程模型相比使用原生的锁和线程来控制，更易于理解，维护，当然也就容易避免了潜在的 cache 优化和死锁问题。</p><p>当然，不管怎么样，异步编程都是有潜在的死锁问题的。生产者消费者模型并不是灵丹妙药，我们还是要注意逻辑上的死锁问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前置概念&quot;&gt;&lt;a href=&quot;#前置概念&quot; class=&quot;headerlink&quot; title=&quot;前置概念&quot;&gt;&lt;/a&gt;前置概念&lt;/h2&gt;&lt;h3 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h3&gt;&lt;p&gt;并发，英文 concurrency，直译就是同时发生。并行，parallelism，直译就是平行。所以虽然一字之差，意思却是不同的，但也很好理解，前者是同时发生，后者是一起做事情。&lt;/p&gt;
&lt;p&gt;最简单的比喻就是肯德基点餐场景——几个顾客同时点餐，服务员们一个准备汉堡，一个准备咖啡。顾客同时点餐就是并发，服务员们分工去满足顾客就是并行。&lt;/p&gt;
&lt;p&gt;有了清楚的认识并行并发概念后，在处理异步问题的时，应该考虑，我们是解决了并行问题，还是解决了并发问题亦或都能解决？&lt;/p&gt;
&lt;p&gt;当然，为了不啰嗦或者咬文嚼字，偶尔我们可能会只用“并发”或者“并行”来代表“并发和并行”两个概念。&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency" scheme="https://www.jackhuang.cc/categories/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（三）：Pin 详解</title>
    <link href="https://www.jackhuang.cc/2023/02/26/rust-pin/"/>
    <id>https://www.jackhuang.cc/2023/02/26/rust-pin/</id>
    <published>2023-02-26T08:07:13.000Z</published>
    <updated>2023-05-31T15:28:14.489Z</updated>
    
    <content type="html"><![CDATA[<p>本节不讲异步编程。但 Pin 最先出现的地方就是在我们使用 Future 的时候，因此放入 异步编程里面讲了。</p><p>Pin 的确是一个很特殊的容器，官方文档和其它查到的资料实在晦涩难懂，即使看中文版我也觉得没有解释太清楚（可能自己笨）。还是那一句话，如果文档和各种资料都看不懂的话，那么，看源码就可以了。</p><p>通过对源码的了解，Pin 却又是非常简单的容器，甚至可以这么说，它的特殊之处就是因为它比较简单。Pin 只是实现了这么一个特殊功能的容器：若发现 T 是一个 pinned struct，即禁止内存移动的结构体，则 Pin 禁止返回 &amp;mut T。</p><p>下面，我们把官方文档拆开来讲，深入浅出的彻底搞懂 Pin 吧。</p><span id="more"></span><h2 id="Rust-的原始指针"><a href="#Rust-的原始指针" class="headerlink" title="Rust  的原始指针"></a>Rust  的原始指针</h2><p>在讲 Pin 之前，我们先大概了解一下 Rust 的原始指针，这里会原始到不使用 Rust 的任何函数。比如，我们要获得 String 的指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: *<span class="keyword">const</span> <span class="type">String</span> = &amp;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the address of s is &#123;:?&#125;, its content is &#123;&#125;&quot;</span>, p, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码第 2 行，就是获得字符串 s 的地址，并让 p 存放这个地址，注意这里用的 *const String，和 C++ 语言一样，表示这个 p 不允许修改 s 的内容，当然可以用 mut 指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: *<span class="keyword">mut</span> <span class="type">String</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    (*p).<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; this is greeting to rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the address of s is &#123;:?&#125;, its content is &#123;&#125;&quot;</span>, p, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 *p 是一个危险操作，Rust 需要我们知道这么做是有风险的，于是需要放在 unsafe 块里面。</p><p>好，了解了 Rust 的原始指针后，可以看是 Pin 解析之旅了。</p><h2 id="Pin-的设计思想"><a href="#Pin-的设计思想" class="headerlink" title="Pin 的设计思想"></a>Pin 的设计思想</h2><p>开篇说了，Pin 的目的就是若 struct 是一个被标记为 pinned 的结构体，则它不让我们获得 &amp;mut T。若你现在不理解这句话的意思，我现在开始从头开始讲，回过头来看这句话那么就完全理解 Pin 了。</p><p>首先，Rust 若想移动一块 struct，就需要 &amp;mut T。比如下面这个代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> s, &amp;<span class="keyword">mut</span> t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;, t = &#123;&#125;&quot;</span>, s, t);</span><br></pre></td></tr></table></figure><p>上面的代码会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = hello jack!, t = hello rust!</span><br></pre></td></tr></table></figure><p>即 s 和 t 的内容被交换了，不仅仅是 std::mem::swap 这个函数，只要是内存移动，只要获得 &amp;mut T 就能实现。因此，如果让一个 struct 对象的内存不能移动，那么，就得想办法想获取 &amp;mut T 的时候阻止返回即可，按照 Rust 的哲学，这个阻止动作要发生在编译期。</p><p>那么，怎么阻止呢？这就用到 Pin，只要是放在 Pin 内的 对象，且对象被标记为 pinned，那么都无法返回 &amp;mut T。这样就阻止了内存移动。</p><h2 id="内存移动的坑"><a href="#内存移动的坑" class="headerlink" title="内存移动的坑"></a>内存移动的坑</h2><p>在讲 Pin 的细节前，解释一下，为什么有时我们要阻止内存移动。其实默认情况下，任何 primitive 类型都是可以移动的，由这些 primitive 类型组成的 struct 也当然可以移动，也就是默认情况下，它们都是 unppinned。什么情况下我们要改成 pinned 呢？最典型的的就是 self-reference 的struct，这个在官方文档由详细的列举，这里给一个简单的代码实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    p_name: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Node &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = Node &#123;</span><br><span class="line">            name, </span><br><span class="line">            p_name: std::ptr::<span class="title function_ invoke__">null</span>() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        n</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.p_name = &amp;<span class="keyword">self</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node1</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    node1.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node2</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    node2.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node1, &amp;<span class="keyword">mut</span> node2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node1.name = &#123;&#125;, node1.p_name = &#123;:?&#125;, *node1.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node1.name, node1.p_name, *node1.p_name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node2.name = &#123;&#125;, node2.p_name = &#123;:?&#125;, *node2.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node2.name, node2.p_name, *node2.p_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，有一个小细节要解释一下，就是 Node 的 init 方法为什么不写在 new 方法里面，如果你调试会发现 new 方法是一个静态方法，没有 self 或者 &amp;self，因此里面的对象地址每一次调用的是相同（有可能是出于优化目的，我没有研究），只有绑定到 new 返回的地方的变量上才能拿到 self 或者 &amp;self，因此，此时才能拿到 name 字段的地址。</p><p>接着我们可以看到，node1 和 node2 在调用 swap 后会被交换内容，即 name 字段被交换了，实际上地址也被交换了，但也因此 *p_name 还是指向原来的内容，即它们指向的对象的值没有被交换：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.name = rose, node1.p_name = <span class="number">0x7ffeefbff2f8</span>, *node1.p_name = jack</span><br><span class="line">node2.name = jack, node2.p_name = <span class="number">0x7ffeefbff318</span>, *node2.p_name = rose</span><br></pre></td></tr></table></figure><p>可以看到，node1.name 由原来的 “jack” 变成了 “rose”，但对应的 *p_name 还是 “jack”！</p><p>Pin 的出现，就是让这种误操作变成编译失败。</p><p>但其实细想，这个结果是符合逻辑的，只是不符合在设计这个 struct 的时候的初衷，因为它的设计者认为，p_name 是保存 name 的地址，因此它的内容应该是要和 name 保持一致才对。</p><h2 id="构造-Pin-容器的基本规则"><a href="#构造-Pin-容器的基本规则" class="headerlink" title="构造 Pin 容器的基本规则"></a>构造 Pin 容器的基本规则</h2><p>一个 T 想放入 Pin 中，必须实现 Deref trait，也即能用 * 解引用，因此，能放入 Pin 的，要么是一个生命周期覆盖整个 Pin 对象的 T 对象引用，要么是类似 Box 这种容器。</p><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n1</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node1</span> = Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> n1);</span><br></pre></td></tr></table></figure><p>上面的代码 n1的生命周期覆盖了 node1 的生命周期，因为 node1 作为 Pin&lt;&amp;Node&gt; 引用了 n1。</p><h2 id="Pin-是如何保护我们的-struct-的"><a href="#Pin-是如何保护我们的-struct-的" class="headerlink" title="Pin 是如何保护我们的 struct 的"></a>Pin 是如何保护我们的 struct 的</h2><p>那么 Pin 是如何让 swap 这种误操作变成编译错误的呢？针对不同的 T 所在内存 ，分为两种情况。</p><h3 id="栈数据保护"><a href="#栈数据保护" class="headerlink" title="栈数据保护"></a>栈数据保护</h3><h4 id="get-mut"><a href="#get-mut" class="headerlink" title="get_mut"></a>get_mut</h4><p>get_mut 返回 &amp;mut T，那么如何禁止对于不允许内存移动的 struct 而产生编译错误呢？首先，前面说过，默认情况下 primitive 类型都是 unpinned 的，其组成的 struct 也是 unpinned 的，那么我们必须要有一个 pinned 类型，把这个类型放进 struct 中，于是 struct 就变成了pinned了，这个类型就是 PhantomPinned。于是，我们的例子中，Node 首先增加这个字段，这样 Node 也就是一个 pinned 类型的 T 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    p_name: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">    _ph: PhantomPinned,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们若调用 get_mut 想试图返回 &amp;mut T 其结果将会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n1</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    node1.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node1</span> = <span class="keyword">unsafe</span> &#123;Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> n1)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n2</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    node2.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node2</span> = <span class="keyword">unsafe</span> &#123;Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> n2)&#125;;</span><br><span class="line"></span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(node1.<span class="title function_ invoke__">get_mut</span>(), node2.<span class="title function_ invoke__">get_mut</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node1.name = &#123;&#125;, node1.p_name = &#123;:?&#125;, *node1.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node1.name, node1.p_name, *node1.p_name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node2.name = &#123;&#125;, node2.p_name = &#123;:?&#125;, *node2.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node2.name, node2.p_name, *node2.p_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，第 10 行会收到编译失败，其中会提示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `PhantomPinned` cannot be unpinned</span><br><span class="line">   -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">34</span>:<span class="number">20</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">34</span>  |     std::mem::<span class="title function_ invoke__">swap</span>(node1.<span class="title function_ invoke__">get_mut</span>(), node2.<span class="title function_ invoke__">get_mut</span>());</span><br><span class="line">    |                    ^^^^^ ------- required by a bound introduced by this call</span><br><span class="line">    |                    |</span><br><span class="line">    |                    within `Node`, the <span class="keyword">trait</span> `Unpin` is not implemented <span class="keyword">for</span> `PhantomPinned`</span><br></pre></td></tr></table></figure><p>这个错误是怎么实现的呢？这时因为 Pin 的 get_mut 方法，需要 T 实现 unpinned 这个 trait，但由于 Node 增加了 PhantomPinned 字段，导致不满足这个条件，于是报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Unpin,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，where 中对 T 进行了 Unpin 限制，由于新增字段 PhantomPinned 我们的 Node 是不满足的。</p><p>另外，还有一个地方要注意，我们在初始化 Pin 对象的时候，调用的方法是 new_unchecked，而不是 new，这时因为 Pin 的 new 会检查 T 是否是 unpinned 的，若不是，则编译失败，直接在入口处防止了 pinned 对象的进入，后续也就规避了 swap 内存移动的坑。这里调用 new_unchecked 是相当于把这个 trait bound 检查后置了。</p><h4 id="as-mut"><a href="#as-mut" class="headerlink" title="as_mut"></a>as_mut</h4><p>如果把 get_mut 换成 as_mut 呢？Pin 的as_mut 方法代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;pin&quot;</span>, since = <span class="string">&quot;1.33.0&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">as_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Pin&lt;&amp;<span class="keyword">mut</span> P::Target&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY: see documentation on this function</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.pointer) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，返回的是 Pin 对象而不是我们期待的 &amp;mut T，对比 Box的 as_mut 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">AsMut</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Converts this type into a mutable reference of the (usually inferred) input type.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">as_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回的却是 swap 要的 &amp;mut T，这就是最本质的区别。因此，Pin 可以阻止内存移动，而 Box 不行。因此，换成 as_mut 方法后，会产生如下编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">note: expected `&amp;<span class="keyword">mut</span> _`, found <span class="keyword">struct</span> `Pin`</span><br><span class="line">   -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">34</span>:<span class="number">20</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">34</span>  |     std::mem::<span class="title function_ invoke__">swap</span>(node1.<span class="title function_ invoke__">as_mut</span>(), node2.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line">    |                    ^^^^^^^^^^^^^^</span><br><span class="line">    = note: expected mutable reference `&amp;<span class="keyword">mut</span> _`</span><br><span class="line">                          found <span class="keyword">struct</span> `Pin&lt;&amp;<span class="keyword">mut</span> Node&gt;`</span><br></pre></td></tr></table></figure><p>即入参不符合期望。如果细心看编译错误，还会提示我们应该改成下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    |</span><br><span class="line"><span class="number">49</span>  |     std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node1.<span class="title function_ invoke__">as_mut</span>(), node2.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line">    |                    ~~~~~~~~~~~~~~~~~~~</span><br><span class="line">help: consider mutably borrowing here</span><br><span class="line">    |</span><br><span class="line"><span class="number">49</span>  |     std::mem::<span class="title function_ invoke__">swap</span>(node1.<span class="title function_ invoke__">as_mut</span>(), &amp;<span class="keyword">mut</span> node2.<span class="title function_ invoke__">as_mut</span>());</span><br></pre></td></tr></table></figure><p>如果我们按照提示的方法修改，也即我们取返回值的 &amp;mut 引用，也即我们把 &amp;mut Pin&lt;&amp;T&gt; 给了 swap 函数，那么会发现内存并没有交换：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node1.<span class="title function_ invoke__">as_mut</span>(), &amp;<span class="keyword">mut</span> node2.<span class="title function_ invoke__">as_mut</span>());</span><br></pre></td></tr></table></figure><p>其输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.name = jack, node1.p_name = <span class="number">0x7ffeefbff318</span>, *node1.p_name = jack</span><br><span class="line">node2.name = rose, node2.p_name = <span class="number">0x7ffeefbff2f8</span>, *node2.p_name = rose</span><br></pre></td></tr></table></figure><p>可以看到，内存没有变动，而且符合我们设计 Node 时的初衷，即 name 和 *p_name 内容一致。这是因为 Pin 返回的是一个新对象，老对象放在里面丝毫未动。Pin 虽然无法阻止我们在外面写出 &amp;mut T 这样的代码，但它通过返回一个新对象保护了 T 的内存被移动。</p><h3 id="堆数据保护"><a href="#堆数据保护" class="headerlink" title="堆数据保护"></a>堆数据保护</h3><h4 id="get-mut-1"><a href="#get-mut-1" class="headerlink" title="get_mut"></a>get_mut</h4><p>如果把 T 放入堆里面呢？比如用 Box 容器，此时，我们的 get_mut 讲无法使用，因为 get_mut 是放在这个 Pin 特化下面的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: ?<span class="built_in">Sized</span>&gt; Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T&gt; </span><br></pre></td></tr></table></figure><p>上面的这一行代码， ?Sized 表示 T 必须是一个在编译时期未知具体大小的类型，比如引用，但 Box 是一个编译时期已知大小的类型（它的成员是指针，固定大小），因此，Pin&lt;Box&lt;T&gt;&gt; 无法调用 get_mut。</p><h4 id="as-mut-1"><a href="#as-mut-1" class="headerlink" title="as_mut"></a>as_mut</h4><p>Pin&lt;Box&lt;T&gt;&gt; 中 Box&lt;T&gt; 实际就是一个栈上的数据（ T 在堆上），因此此时 as_mut 的情况和之前讨论在站上的数据保护一样，由于 as_mut 返回的是一个新的 Pin&lt;Box&lt;T&gt;&gt; 对象，因此，无法通过编译，即使通过引用符号转为 &amp;mut T 类型，虽然可以通过编译并运行，但因为是新对象而不会造成原来的 T 对象有内存移动。这种情况完全和栈数据时的情况一样。</p><h2 id="前方高能：直接将-Pin-的引用传给-swap"><a href="#前方高能：直接将-Pin-的引用传给-swap" class="headerlink" title="前方高能：直接将 Pin 的引用传给 swap"></a>前方高能：直接将 Pin 的引用传给 swap</h2><p>前面说的都是 Pin 如何通过 trait bound 或者新创建 Pin 对象的方法防止我们通过 get_mut 和 as_mut 这两个方法获得 &amp;mut T，从而使得 swap 函数编译报错阻止了内存移动的坑。但如果我们直接把 Pin 当作一个对象，直接把这个对象的 &amp;mut 引用传入 swap 呢？</p><h3 id="栈的情况"><a href="#栈的情况" class="headerlink" title="栈的情况"></a>栈的情况</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n1</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    n1.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node1</span> = <span class="keyword">unsafe</span> &#123;Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> n1)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n2</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    n2.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node2</span> = <span class="keyword">unsafe</span> &#123;Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> n2)&#125;;</span><br><span class="line"></span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node1, &amp;<span class="keyword">mut</span> node2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node1.name = &#123;&#125;, node1.p_name = &#123;:?&#125;, *node1.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node1.name, node1.p_name, *node1.p_name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node2.name = &#123;&#125;, node2.p_name = &#123;:?&#125;, *node2.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node2.name, node2.p_name, *node2.p_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如此一来，即使我们的 Node 有 PhantomPinned 字段，变成了 pinned 对象，但我们通过直接把 Pin 对象引用传给了 swap 函数绕过了 Pin 为我们做的检查，编译还是可以顺利通过，运行符合我们的预期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.name = rose, node1.p_name = <span class="number">0x7ffeefbff2f8</span>, *node1.p_name = rose</span><br><span class="line">node2.name = jack, node2.p_name = <span class="number">0x7ffeefbff318</span>, *node2.p_name = jack</span><br></pre></td></tr></table></figure><p>这时因为 Pin&lt;T&gt; 被当作一个整体被 swap 了，也就是 swap 的是 Pin 对象而不是 T 对象， Pin 对象没有self-reference 问题，因此这么做结果是没问题的。</p><h3 id="堆的情况"><a href="#堆的情况" class="headerlink" title="堆的情况"></a>堆的情况</h3><p>轮到堆的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n1</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node1</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(&amp;<span class="keyword">mut</span> n1);</span><br><span class="line">    node1.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n2</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node2</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(&amp;<span class="keyword">mut</span> n2);</span><br><span class="line">    node2.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node1, &amp;<span class="keyword">mut</span> node2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node1.name = &#123;&#125;, node1.p_name = &#123;:?&#125;, *node1.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node1.name, node1.p_name, *node1.p_name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;node2.name = &#123;&#125;, node2.p_name = &#123;:?&#125;, *node2.p_name = &#123;&#125;&quot;</span>,</span><br><span class="line">                node2.name, node2.p_name, *node2.p_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这回我们也是把 Pin 对象当作 T 然后转为 &amp;mut T 传给 swap 函数了。此时结果当然也是令我们满意的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.name = rose, node1.p_name = <span class="number">0x7ffeefbff2e8</span>, *node1.p_name = rose</span><br><span class="line">node2.name = jack, node2.p_name = <span class="number">0x7ffeefbff308</span>, *node2.p_name = jack</span><br></pre></td></tr></table></figure><p>不管是 name 字段还是 p_name 字段，都交换了，之前提到的内存移动的坑没有了。这是因为 Pin&lt;T&gt; 中 T 没有 self-reference 问题，它被整体交换了，于是结果符合预期。</p><h2 id="为什么-Future-要放在-Pin-lt-Box-lt-T-gt-gt-中"><a href="#为什么-Future-要放在-Pin-lt-Box-lt-T-gt-gt-中" class="headerlink" title="为什么 Future 要放在 Pin&lt;Box&lt;T&gt;&gt; 中"></a>为什么 Future 要放在 Pin&lt;Box&lt;T&gt;&gt; 中</h2><p>这是因为，Future 对象相当于是一个函数转过去的对象，如果我们在函数中定义了一个数组，然后调用一个 IO 阻塞函数，函数中引用这个数组并往里填数据，那么这之中将会触发一次 await，也即 Future 对象会在 IO 阻塞完成的时候重新 send 到队列中给 executor 执行，这就是一个内存移动过程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">read_into_buf_fut</span> = <span class="title function_ invoke__">read_into_buf</span>(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面官方的例子，第四行会有 IO 阻塞，此时 poll（回忆上一节讲的，await 相当于调用了 poll 方法）返回 Pending，executor 收到返回值 Pending转去执行别的 Future 了，当 read_into_buf_fut 完成后，会重新被 send 进队列等待 executor 再次 poll 后继续执行第 5 行代码，此时上面的代码中，x 和第三行的 &amp;x 就相当于 self-reference，若没有 Pin，将会产生内存移动的坑。有了 Pin，内存移动就会像上一小节那样符合预期的进行移动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Pin&lt;T&gt; 通过 trait bound 检查（new 和 get_mut 方法）或者返回新的 Pin 对象（as_mut 方法）来防止内存移动的坑；对于 pinned struct 结构产生编译报错，防止我们直接对 T 进行内存移动操作。</p><p>2、由于 Pin 的封装，我们把 Pin&lt;T&gt; 看成一个整体移动内存的话，则符合预期；</p><p>3、由于Pin 一方面阻止了 T 的内存移动bug，另一方面保证了 Pin&lt;T&gt; 可以符合预期的进行内存移动，因此，若出现 self-reference 的情况，我们应该用 Pin 封装一层，并且在 struct 中使用 PhantomPinned 字段协助 Pin 防止踩坑。</p><p>从上面的讨论可以看出， 尽管它的名字叫 Pin，Pin 并不是用来禁止内存移动的，而是保证内存移动能正常进行的类型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节不讲异步编程。但 Pin 最先出现的地方就是在我们使用 Future 的时候，因此放入 异步编程里面讲了。&lt;/p&gt;
&lt;p&gt;Pin 的确是一个很特殊的容器，官方文档和其它查到的资料实在晦涩难懂，即使看中文版我也觉得没有解释太清楚（可能自己笨）。还是那一句话，如果文档和各种资料都看不懂的话，那么，看源码就可以了。&lt;/p&gt;
&lt;p&gt;通过对源码的了解，Pin 却又是非常简单的容器，甚至可以这么说，它的特殊之处就是因为它比较简单。Pin 只是实现了这么一个特殊功能的容器：若发现 T 是一个 pinned struct，即禁止内存移动的结构体，则 Pin 禁止返回 &amp;amp;mut T。&lt;/p&gt;
&lt;p&gt;下面，我们把官方文档拆开来讲，深入浅出的彻底搞懂 Pin 吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    <category term="Concurrency" scheme="https://www.jackhuang.cc/categories/Rust/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（四）：挖矿与脚本校验</title>
    <link href="https://www.jackhuang.cc/2023/02/25/blockchain-mining/"/>
    <id>https://www.jackhuang.cc/2023/02/25/blockchain-mining/</id>
    <published>2023-02-25T08:18:12.000Z</published>
    <updated>2023-02-25T11:01:29.933Z</updated>
    
    <content type="html"><![CDATA[<p>今天再讲讲挖矿和交易校验的一些细节。</p><span id="more"></span><h2 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h2><p>区块链诞生之初，一般的电脑都可以参与挖矿，但现在一般人已经很难参与挖矿了，因为比特币价值很高了（虽然最近一直熊市），参与挖矿的竞争对手越来越多，算力越来越强，大部分区块都是由非常有实力的矿池挖出的，比如写这篇文章时，最近 24 小时的出块前六情况如下（数据来自：<a href="https://www.blockchain.com/explorer/charts/pools">https://www.blockchain.com/explorer/charts/pools</a> ）：</p><div class="table-container"><table><thead><tr><th><strong>Miner / Pool</strong></th><th><strong>Percent</strong></th><th><strong>Blocks Mined</strong></th></tr></thead><tbody><tr><td>Foundry USA</td><td>32.679%</td><td>516</td></tr><tr><td>AntPool</td><td>18.049%</td><td>285</td></tr><tr><td>F2Pool</td><td>15.453%</td><td>244</td></tr><tr><td>Binance Pool</td><td>10.260%</td><td>162</td></tr><tr><td>ViaBTC</td><td>8.043%</td><td>127</td></tr><tr><td>Unknown</td><td>2.723%</td><td>43</td></tr></tbody></table></div><p>可以看到，Foundry USA 这个区块节点已经有 32.679% 的算力了。当算力接近 51% 的时候就相当于有了很大的区块控制权，这样和去中心化的初衷违背，一般会调整难度，使得难度下降，让其它节点更有可能抢到出块权（前面说过，挖矿的概率是独立的，即使算力很强，挖到矿的概率大家都是均等的，这样，降低难度可以让其它节点更有机会挖到矿）。</p><p>另外，即使挖到矿，也有可能不会获得出块奖励，因为如前面所说，区块链有可能出现分叉，这样自己挖到的那个区块可能不是出于最长链中，导致被回滚，这样也降低了区块链被中心化的概率。</p><h3 id="挖矿设备"><a href="#挖矿设备" class="headerlink" title="挖矿设备"></a>挖矿设备</h3><p>第一代挖矿设备就是我们的一般计算机，其主要是靠 CPU 挖矿，在竞争不激烈的时代这么做是没问题的。但随着比特币价值的上升，竞争激烈后，大家升级了挖矿硬件，由 CPU 升级为 GPU，即提高了并行计算的能力。但即使如此， GPU 毕竟是显卡设备，第三代设备则升级为专业的挖矿芯片设备 ASIC： application specific integrated circus。并且，大家也不再单独挖矿，而是以矿池的运作方式进行挖矿。</p><h3 id="矿主和矿工"><a href="#矿主和矿工" class="headerlink" title="矿主和矿工"></a>矿主和矿工</h3><p>所谓矿池，即分为矿主和矿工，矿主主要维护一个全节点，而矿工作为轻节点则只做区块头部的哈希运算，当矿工挖到区块后，就告诉矿主，由矿主提交给区块链。矿池在获得出块奖励后，会给各个矿工一部分奖励。</p><h4 id="激励矿工和防止划水"><a href="#激励矿工和防止划水" class="headerlink" title="激励矿工和防止划水"></a>激励矿工和防止划水</h4><p>那么，这么做会不会有划水矿工呢？矿主为了激励矿工尽可能的挖到区块，除了挖到目标区块以外，还会稍微降低区块的难度，即增大 target 值，并告诉矿工，只要能挖到越过这个降低难度的 target 值，即使最后没有挖到区块而是由其它矿工挖到的，那么也会享受到一部分奖励，这样，矿工就会尽可能的去挖新的区块，如果划水，那么因为没有越过矿主规定的 target 值，也就分不到奖励了。一般来说，矿工提交的次数越多，奖励也就越多。</p><h4 id="防止矿工独自提交区块获得奖励"><a href="#防止矿工独自提交区块获得奖励" class="headerlink" title="防止矿工独自提交区块获得奖励"></a>防止矿工独自提交区块获得奖励</h4><p>矿工挖到矿后，有没有可能自己提交到区块链并获得出块奖励呢？自己提交到区块链是有可能的，但获得出块奖励却不行。因为矿主给到矿工的区块头是包含了 merkle tree 的根哈希值的，这个 merkle tree 中，包含了铸币交易，而铸币交易中，填写的收款人地址（即矿主的公钥哈希值）是矿主，因此矿工如果越过矿主提交到区块链，那么，出块奖励还是会给到矿主而不是矿工。</p><h4 id="矿工攻击"><a href="#矿工攻击" class="headerlink" title="矿工攻击"></a>矿工攻击</h4><p>矿主之间会存在竞争，一种恶性竞争就是，一个矿主给另一个矿主派去大量无用的矿工，这些矿工只是拉那个矿主的后腿，即使挖到了矿也不会提交给矿主，导致矿主分配出去的任务无效。</p><h2 id="交易校验"><a href="#交易校验" class="headerlink" title="交易校验"></a>交易校验</h2><p>这一小节我们讲一下区块链的交易校验细节。我们知道，区块链交易分为两种，一种是出块奖励，此时称为铸币交易，这种交易的比特币是凭空产生的，当然金额是周期性递减直到为0。一种是转账交易，即多对多的转账，此时我们需要交易金额，即最基本的：</p><script type="math/tex; mode=display">上一笔交易的输出金额 = 本次交易的输入金额</script><p>简单来说即“输出 = 输入”。校验是依赖于脚本实现的，上一笔交易中，会指定输出脚本，而本次交易中，会指定输入脚本，分别依次执行输入脚本和输出脚本，脚本不报错则认为交易校验通过。</p><p>一笔简单的交易画成图如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-verify-dealing.svg" alt="交易的校验"></p><p>如上图，A 给 B 转账后，会输出 A 和 B 的余额，已经手续费等信息，同时还会有输出脚本，同样，B 转给 C时，会产生 B 的输入金额和撕咬签名，以及用于校验的输入脚本，区块链系统会依次执行输入脚本和输出脚本，只要不返回异常，那么交易就算通过了。</p><p>交易校验主要分为三种：</p><h3 id="P2PK-Pay-to-Public-Key"><a href="#P2PK-Pay-to-Public-Key" class="headerlink" title="P2PK (Pay to Public Key)"></a>P2PK (Pay to Public Key)</h3><p>这是最简单的一种，虽然现在已经很少用，但实际上确可以易于我们理解，其过程为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig)</span><br><span class="line">output script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey)</span><br><span class="line">CHECKSIG</span><br></pre></td></tr></table></figure><p>其只有三个步骤，第一个步骤即输入脚本的 PUSHDATA(Sig)，即把出钱方的私钥签名压入栈中，然后执行上一个交易的输入脚本第一条语句：PUSHDATA(PubKey)，即把上一个交易的输出方的公钥压入栈中，最后执行 CHECKSIG，即校验栈中的两个私钥签名和公钥是否匹配，若匹配则校验通过。</p><p>可以看出，区块链的这个脚本执行和汇编代码原理很像，即把数据压入栈中，相当于后面调用的函数的参数，然后调用参数同时出栈与之关联的参数。</p><h3 id="P2PKH-Pay-to-Public-Key-Hash"><a href="#P2PKH-Pay-to-Public-Key-Hash" class="headerlink" title="P2PKH (Pay to Public Key Hash)"></a>P2PKH (Pay to Public Key Hash)</h3><p>前面一种仅校验了出款方的私钥，设想，如果有一个恶意用户重放这笔交易，但公私钥签名是恶意用户的，但出款方地址是受害者的，那么 P2PK 方式是无法校验出来的。因此，输入脚本除了需要校验出款方的公私钥签名以外，还需要校验出款方的地址是否和输出脚本中的一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig)</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey)</span><br><span class="line">output script:</span><br><span class="line">DUP </span><br><span class="line">HASH160 </span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKeyHash) </span><br><span class="line">EQUALVERIFY </span><br><span class="line">CHECKSIG</span><br></pre></td></tr></table></figure><p>上面的代码中，首先执行输入脚本的 PUSHDATA(Sig) 将出款方的私钥签名压入栈中，然后 PUSHDATA(PubKey) 压入出款方的公钥。接着执行输出脚本的 DUP，DUP函数会把栈顶数据复制一份，即此时，栈如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key1.svg" alt=""></p><p>接着执行 HASH160，即把顶端的公钥进行哈希，而后 PUSHDATA(PubKeyHash) 压入出款方的公钥哈希，这里特别提示，公钥哈希即出款方的地址：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key2.svg" alt=""></p><p>EQUALVERIFY 指令则是将 栈顶的两个哈希值对比是否相等，即地址校验，成功后栈如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key3.svg" alt=""></p><p>因此，CHECKSIG 即校验公私钥签名完成校验。</p><h3 id="P2SH-Pay-to-Script-Hash-和-P2PKH-结合"><a href="#P2SH-Pay-to-Script-Hash-和-P2PKH-结合" class="headerlink" title="P2SH (Pay to Script Hash) 和 P2PKH 结合"></a>P2SH (Pay to Script Hash) 和 P2PKH 结合</h3><p>P2SH 是在 P2PKH 的基础上增加了 redeem 脚本，即赎回脚本，稍微解释即：出款方在输出的时候会指定校验细节，这个细节写入redeem 脚本供下一次交易校验。简单来说，即想用使用出款方的钱，就必须满足上一次交易时出款方定下的规则，否则不予交易。例如这么一个场景，A 获得比特币时，在输出脚本的 redeem 脚本中指定要想使用 A 的余额，B 也要出钱，如此 redeem 脚本会校验 B 的私钥签名和地址。</p><p>下面拿一个例子讲：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redeemScript：</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig_A)</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig_B)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey_B)</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey_A)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">CHECKSIG</span><br><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(serialized redeemScript)</span><br><span class="line">output script:</span><br><span class="line">HASH160 </span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(redeemScriptHash) </span><br><span class="line">EQUAL</span><br></pre></td></tr></table></figure><p>首先，从输入脚本开始，PUSHDATA(serialized redeemScript) 分别压入出款方的私钥签名和 redeem 脚本，然后 HASH160 将序列化后的 redeem 脚本做一次哈希，然后输出脚本的 PUSHDATA(redeemScriptHash) 指令也把自己的 redeem 脚本哈希压入栈：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key4.svg" alt=""></p><p>此时执行 EQUAL 就可以对比两个 redeem 是否一致，保证本次交易 redeem 的代码时执行出款方的意愿。完成后，进入 redeemScript片段，片段中即将 A 和 B 的私钥及公钥压入栈中，然后进行验签，其原理大致同前不再赘述，通过后交易校验即通过。</p><p>这里有一个小细节，即 redeem 脚本的哈希值，本次交易时，出款方只提供哈希值本身，因为收钱方无需关注 redemm 脚本的内容，因此他只会看到 redeem 脚本的哈希值，区块链系统会去上一次输出那里找到 redeem 内容来计算哈希值和执行里面的内容。</p><h3 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h3><p>有一种特殊的输出脚本，它不管怎么样都会执行 RETURN 语句，这个语句会返回错误，也就是说，如果进行交易校验，那么一定会失败，也即校验不通过。相当于上一个交易的输出金额将无法使用。那么这种脚本有什么用呢？因为 RETURN 语句一定返回失败，因此，RETURN 语句后面的内容无论如何都无法执行，因此可以写入任何东西，例如，某人预测足球比赛的结果，他会把足球比赛的结果取哈希后写入输出脚本中，这个交易就相当于一个用来记一个不可篡改的信息的交易。当然，这样做的话，会给 UTXO 系统造成负担，毕竟， UTXO 是全节点所有的输出记录集合，如果大量写入这种无法使用的输出记录，那么 UTXO 会变得难以维护。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天再讲讲挖矿和交易校验的一些细节。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（三）：挖矿难度和网络部署</title>
    <link href="https://www.jackhuang.cc/2023/02/21/blockchain-target-network/"/>
    <id>https://www.jackhuang.cc/2023/02/21/blockchain-target-network/</id>
    <published>2023-02-21T05:14:27.000Z</published>
    <updated>2023-02-21T07:40:05.920Z</updated>
    
    <content type="html"><![CDATA[<p>上一节讲了区块链的协议，这一节主要讲区块链的挖矿难度和网络部署。</p><span id="more"></span><h2 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h2><p>前面讲了，区块链的安全是依靠挖矿难度来保证的，即依赖工作量证明（proof of work）来获取到写入区块链资格，只有算力很强的节点才能争取到写入区块链的权利。这里进一步细讲挖矿的难度。首先，为什么挖矿难度可以增加比特币的安全性呢？</p><p>假设如果区块链的挖矿难度很低，这样导致的结果就是很多人都可以在短时间内争取到写入区块链的权利，于是区块链就会很容易出现分叉：</p><p><img src="https://www.jackhuang.cc/svg/blokchain-mang-forks.svg" alt="区块链分叉"></p><p>图中，大量红色区块追加在黄色区块中，这种分叉不利于区块链的数据一致性保证，这样就很难保证到底哪一个新节点能成为最长的区块链，很难达到最终一致的结果。而且也很容易造成 doubel spending 攻击。</p><h3 id="double-spending-攻击"><a href="#double-spending-攻击" class="headerlink" title="double  spending 攻击"></a>double  spending 攻击</h3><p>所谓 double spending 攻击，就是恶意节点在完成一笔交易后，强行在交易节点前的同一个节点强行写入一个新节点，造成分叉，只要新节点最后变成最长链，根据前面讲的知识，区块链系统会接受最长链为正式节点，这样之前的交易就会被回滚，从而导致卖家损失，例如下图所示：</p><p><img src="https://www.jackhuang.cc/svg/double-spending-attack.svg" alt="double spending 攻击"></p><p>假设 A 是一个恶意用户，第一次交易，A 给 B 转账，但是 A 作为一个恶意节点，它新创建一个自己的另一个账户 A‘，发起第二次交易，A 给自己的 A‘ 转账，这回交易的输入还是老区块（图中的黄色区块）的输出，那么，图中的蓝色区块交易就有可能会被回滚，特别是如果挖矿难度值低的时候，蓝色的交易区块被回滚的可能性就非常之大，因为恶意节点可以短时间内继续写入更多的区块在红色区块之后，即图中后面的灰色区块，最终使得蓝色区块因为不是最长区块而被回滚。若此时 B 给 A 发货了，那么 B 将造成损失。</p><p>提升难度值可以让出现这种攻击的概率变低。而且一般交易平台，也会等待自己的交易区块之后有 6 个区块写入后才确认交易，进一步降低了区块被回滚的概率。这个概率，根据数学家的计算，是非常接近 0 的，可以信任。（这个世界上没有 100% 分布式数据一致性算法，均是极大接近于 0 而已）</p><h3 id="伯努利过程"><a href="#伯努利过程" class="headerlink" title="伯努利过程"></a>伯努利过程</h3><p>整个区块链的挖矿其实是一个伯努利过程，即类似抛硬币，每一次抛到正面或者反面的概率都是 50%，不会因为抛了 9 次都是正面，那么第 10 次是反面的概率而变得更大。通用点说，伯努利过程是每一次随机试验都是独立的概率，而不会因为前面的结果影响下一次的概率变化。</p><p>因此，挖矿虽然比拼算力，但若算力相当的情况下，每一个矿工节点获得写入区块链权利概率都是一样的。因此，只要大部分节点都是善意节点，那么恶意节点想做恶的可能性就很低，而且，正如上一节所说，有超强算力的节点都是希望系统稳定的，不然，一个不值得信任的区块链是没有价值的。</p><h3 id="挖矿难度的控制"><a href="#挖矿难度的控制" class="headerlink" title="挖矿难度的控制"></a>挖矿难度的控制</h3><p>挖矿难度是区块链安全的基石，那么区块链难度是怎么控制的呢？前面有讲，主要是靠区块头的两个字段：target 和 nonce，这里注意的是，nonce 字段只有 4 个字节，相较于哈希结果 sha256 的空间（2<sup>256</sup>）是很小的，因此，还需要区块的中的交易字段来增大哈希参数的输入空间。</p><p>还有要注意的是，难度值 difficulty 和 target 是反比关系，即 target 越大，难度越低，反之亦然。可见 target 前面的0越多，也就越难。</p><p>那么 target 是怎么控制的呢？中本聪首先他规定了，每隔十分钟要产生一个区块，每 2016 个区块就要产生一次新的 target（即每 14 天调整一次 target），新的 target 和老的 target 值关系如下：<br>$$<br>新 target &#x3D; 老 target * \frac{实际时间}{期望时间}<br>$$<br>上面的公示很容易理解，当实际时间和期望时间相等的时候，那么说明难度值可以不需要改变，因为我们的期望值就是每 14 天调整一次，如果实际时间不足 14 天，那么<font size=5> $\frac{实际时间}{期望时间}$ </font>会小于 1，此时新的 target 就会变小，导致难度值变大。相反如果实际时间比期望值长，说明难度变高了，此时 <font size=5>$\frac{实际时间}{期望时间}$ </font>会大于 1，那么新的 target 变大，难度值就变小了。</p><p>调整难度值的意义在于我们的算力一直都在增强，如果保持一成不变，10 分钟出一次新区块的频率就难以保证。</p><h2 id="区块链网络部署"><a href="#区块链网络部署" class="headerlink" title="区块链网络部署"></a>区块链网络部署</h2><p>区块链的网络部署是基于 p2p 网络的，其网络特点如下：</p><p>1、任何节点都是随意加入和离开区块链 p2p 网络；</p><p>2、节点的传输不依赖实际物理拓扑规则，有可能两个较远的节点也可以成为邻居节点；</p><p>3、区块链的块大小一般为 1 MB；因为区块链这种数据量大的数据库，如果每一块都很大，会非常的耗网络带宽，一些轻节点实际只是关心某一些交易，因此大块的区块是不利于在 p2p 网络传输的，小块传输可以增强传输的可用性；</p><h3 id="区块链的节点"><a href="#区块链的节点" class="headerlink" title="区块链的节点"></a>区块链的节点</h3><p>区块链的网络节点部署大致可以包含以下节点：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-nodes.svg" alt="区块链节点"></p><p>上面的图中，首先要注意的是，路由节点是所有节点必须要有的，因为区块链的任何一个节点不可能与区块链系统断开链接。而其它三个节点，则可有可无，例如手机这种轻客户端，我们可以只有钱包节点和网络节点即可，钱包节点只要能向其它的全节点发起交易和验证交易（即向全节点请求区块头和 merkle 树路径）就行了。</p><h3 id="区块链节点处理交易"><a href="#区块链节点处理交易" class="headerlink" title="区块链节点处理交易"></a>区块链节点处理交易</h3><p>一个区块链节点是如何处理交易的呢？首先，它维护了三个池子，一个是孤儿池，一个是交易池，还有一个是 UTXO 池。</p><p>孤儿池是当节点收到别的节点发来的交易时所存放的临时交易池子，顾名思义，它没有任何交易与之相连，它是等待验证，等待写入区块的。</p><p>交易池则是，当孤儿池有交易与之相连之后，则会被移入交易池中，它等待验证和写入区块。</p><p>UTXO 则是已经确认的交易池，UTXO 是 unspent  transaction output的缩写，即未被花费的交易输出，相当于我们常说的余额。简单回顾之前说的，除了铸币交易外，转账交易必须维持 “输入” 等于 “输出”，即这一次的交易输入是上一次交易的输出，任何输入输出都是可以追溯的，并且最后可以计算出每一个账户的余额，这些余额信息（即输出）会被放入到 UTXO 池中，等待作为下一次的输入。</p><p>孤儿池和交易池是位于内存中的，而 UTXO 则一般放在固化的物理存储文件中。下面是一个交易从处理到成为 UTXO 的过程：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-trade.svg" alt="交易池"></p><p>可以看到，首先交易先落在孤儿池中，等待父交易来验证，当父交易验证孤儿交易没问题后则会被移入交易池。交易池的交易经过写入区块处理，则进入 UTXO 池，可以作为下一次交易输入使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节讲了区块链的协议，这一节主要讲区块链的挖矿难度和网络部署。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（二）：Future 和 Wake</title>
    <link href="https://www.jackhuang.cc/2023/02/20/rust-futures/"/>
    <id>https://www.jackhuang.cc/2023/02/20/rust-futures/</id>
    <published>2023-02-20T01:56:48.000Z</published>
    <updated>2023-05-31T15:27:36.483Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们大概知道了一些异步编程概念，我们快速简单的复习一下：</p><p>1、Rust 依靠生产者和消费者模型来实现异步编程；</p><p>2、被定义为asyn 的函数，其返回值为一个 future，调用它的 await 方法会触发函数的执行；</p><p>3、 因此，IO 线程完成工作后给主线成发送消息，触发 await，从而实现异步。</p><p>以上是上一节讲的最最简单的异步编程模型，但 Rust 异步编程并不是这么简单，因为上一节的模型中，我们没有模拟 IO 阻塞，因此，await 实际上是不会阻塞的，但 Rust 异步编程中，恰恰是因为 await 中有 IO 操作会产生阻塞而设计的。</p><p>那么，await 到底是怎么用的呢？更关键的是，如果 await 是阻塞的，那么是怎么做到一个线程的情况下切换上下文的呢？如何做 await 的 IO 操作完成后继续往下执行的呢？</p><p>本节将会把 await 展开，引入关键的两个 trait： Future 和 Wake，把 Rust 的异步编程模型说清楚。</p><span id="more"></span><h2 id="异步函数改写成-Future"><a href="#异步函数改写成-Future" class="headerlink" title="异步函数改写成 Future"></a>异步函数改写成 Future</h2><p>上一节中，我们在函数前加了一个 async 关键字，此时会发现函数会变成一个feture，即我们的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">SayHelloInPending</span> <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>实际上，编译器会把它变成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) </span><br><span class="line">  <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>也就是，任何一个异步函数，都会被化成一个个 future。future trait 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键的函数就是poll，poll 主要是返回一个Poll enum，它要么是 Ready(T)，表示阻塞完成，可以继续执行，T 即函数的返回值，或者Pending 表示函数依然在等待 IO 完成。</p><p>因此，我们只需要把定义的函数写成一个 struct，struct 实现 Future trait，并实现函数需要的阻塞 IO 逻辑即可，当然这个逻辑是在线程中执行，因为不能阻塞 main 线程，main 线程调用 Future trait 的 poll 的会检查阻塞的状态，若未完成，这个 poll 返回 Pending，否则返回 Ready(T)。</p><p>例如我们要实现一个 n 毫秒后返回 completed 字符串的函数，main 主线成会不等这个 n 毫秒，而是继续处理其它已经就绪的 Future，当 n 毫秒完过后，会把 Future 放入队列等待主线程 调度。</p><p>我们的异步函数会被写成这样（此时不再使用 async）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    shared_data: Arc&lt;Mutex&lt;SharedData&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    completed: <span class="type">bool</span>,</span><br><span class="line">    waker: <span class="type">Option</span>&lt;Waker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">new</span>(millis: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>  &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = SayHelloInPending &#123; </span><br><span class="line">            shared_data: Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedData &#123; </span><br><span class="line">                completed: <span class="literal">false</span>, </span><br><span class="line">                waker: <span class="literal">None</span> </span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_data_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;task.shared_data);</span><br><span class="line">        std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(millis));</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = shared_data_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            data.completed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(w) = data.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                w.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        task</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) </span><br><span class="line">  <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_data</span> = <span class="keyword">self</span>.shared_data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(<span class="keyword">mut</span> data) = shared_data &#123;</span><br><span class="line">            <span class="keyword">if</span> data.completed &#123;</span><br><span class="line">                <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(<span class="string">&quot;completed&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        Poll::Pending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SayHelloInPending 就是我们的异步函数，现在换成了用 struct 实现，它的成员被放在了 SharedData 里面，并用 Arc 和 Mutex 保护起来，因为 Future 一来被 IO 线程读写，二来也会被主线程读写，因此需要这两个异步容器保护。SharedData 保护了 completed 字段，表示 IO 是否已经完成，初始值为 false。至于 waker 我们待会再说。</p><p>在 new 出 SayHelloInPending 的时候，我们启动了一个线程 sleep 了 n 毫秒用以模拟 IO 操作所需要的时间，可以看到，当 sleep 结束的时候，我们会调用 waker 的 wake 函数，这个名字看上去是要唤醒什么，实际上即触发我们之前提到的 sender 讲就绪的 Future 发给队列，等待 main 线程再次调用 poll 获得返回值。我们待会再说 waker 的更进一步细节。</p><p>之后的 impl Future for SayHelloInPending 块中，即实现了 Future trait，我们先不看 pin 和 context，就看里面的实现细节，可以看到，主要就是检查线程是否 completed，如果是，则返回 completed，否则返回 Pending状态。</p><p>这样我们就封装好了一个异步“函数” （Future）。</p><h2 id="封装Task"><a href="#封装Task" class="headerlink" title="封装Task"></a>封装Task</h2><p>那么主线程怎么调用上面封装的 Future 呢？这里封装了一个 Task，毕竟 Future 可以很多，但是我们需要抽象出 Task 方便 sender 发消息给到队列。</p><p>我们看看 Task 的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    fut: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;&gt;&gt;,</span><br><span class="line">    sender: SyncSender&lt;Arc&lt;Task&lt;T&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Task&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(sender: SyncSender&lt;Arc&lt;Task&lt;T&gt;&gt;&gt;, f: BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            fut: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(f)),</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; ArcWake <span class="keyword">for</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        arc_self.sender.<span class="title function_ invoke__">send</span>(arc_self.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to send task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的返回值我用了模板实现，不必太在意。主要看的是，Task 首先有一个 fut 成员，也即我们的 Future，因为是多线程，因此需要 Mutex 保护，Box 也变成了 BoxFuture，这个我们以后说，现在只需要知道这个字段是 Future 即可，它要等待调度的。另一个当然是 sender，因为当 我们的 fut 就绪的时候，需要 sender 把这个 Task 发到队列，可以看到，sender 实际上放着的是 Arc\<Task\<T\>>，因为 Task 在队列中，可能被其它线程共享，当然本例中只有两个线程（IO 线程和主线程），但我们还是习惯加上了 Arc 容器。</p><p>Task 的 new 方法接受一个 Future 和 sender，这当然是为了初始化。重点是 impl\<T\> ArcWake for Task\<T\> 。是的，这个 Task 就是上面提到的 waker 的实现，只要调用 waker 的 wake 方法，那么就会触发 wake_by_ref 的调用，在 wake_by_ref 里面，会看到， Task 的 sender 给队列发送了 Task。</p><h2 id="总结-Future-和-Task"><a href="#总结-Future-和-Task" class="headerlink" title="总结 Future 和 Task"></a>总结 Future 和 Task</h2><p>可见，Rust 的异步是这么实现的：</p><p>0、主线程不停的在监听队列，取出等待调用的 Future，调用 Future 试图获得这个“函数”的返回值；</p><p>1、但Future 实现了阻塞 IO 逻辑，当 IO 逻辑未完成时，若调用其 poll 方法，会返回 pending。主线程第一次调用发现是 Pending 返回，于是忽略继续处理下一个队列中的 Task；</p><p>2、当 Future 的 IO 逻辑完成后，状态会被改成就绪，此时调用 waker 的 wake 方法触发后续操作；</p><p>3、waker 其实就是 Task，Task 的 wake_by_ref 是被 waker 的 wake 方法触发的，其中会调用 sender 的 send 方法把 Task 放入队列；</p><p>4、主线程不停的在监听队列，又遇到了刚才的 Task，于是又去 poll 了一下，发现此时可以返回 Ready 了，于是拿到了“函数”的返回值。</p><p>画成图是这样：</p><p><img src="https://www.jackhuang.cc/svg/rust-future-poll.svg" alt="异步调用示例"></p><p>可以看到，Future 在处理阻塞的 IO 逻辑时，是采用线程来完成的，因为不能阻塞主线程，主线程需要处理下一个 Future（Task）。还可以看到，Task 和 Future 是相互包含，引用的。</p><p>Task 实现了 Wake trait，放在 Future 中，当 Future 完成 IO 阻塞操作后，通过 Wake trait 调用 Task 的 wake_by_ref 函数激发 sender把 Task 重新放入队列中等待调度。</p><p>Future trait 同样也包含在 Task 中，因为 Task 被放入队列后会被 Receiver 调度，即调用其 poll 方法，获得 Pending 状态或者 Ready。Pending 状态则 Task 一边执行去，不阻塞 Receiver，而 Ready 状态则绑定了返回值。</p><p><img src="https://www.jackhuang.cc/svg/rust-future-task.svg" alt="Task 和 Future 的关系"></p><h2 id="Context-出场"><a href="#Context-出场" class="headerlink" title="Context 出场"></a>Context 出场</h2><p>了解上面的关系后，现在该讲讲 Context 了。为什么 Future 在获取 Task，也即 waker 的时候没有直接去使用 waker 呢？这是因为 Context 封装了上下文，目前的确只有 waker，但这也为以后扩展留下了更好的封装。</p><h2 id="executor-驱动"><a href="#executor-驱动" class="headerlink" title="executor 驱动"></a>executor 驱动</h2><p>现在，可以写我们的 executor 函数了，它无非就是把上面提到的receiver做的时候做一遍：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">excutor</span>(queue: Receiver&lt;Arc&lt;Task&lt;<span class="type">String</span>&gt;&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">           <span class="title function_ invoke__">Ok</span>(task) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_ref</span>(&amp;task);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">contex</span> = &amp;<span class="keyword">mut</span> Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker);</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fut</span> = task.fut.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> f) = fut.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">result</span> = f.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(contex);</span><br><span class="line">                    <span class="keyword">if</span>  result.<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                        *fut = <span class="title function_ invoke__">Some</span>(f);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(s) = result &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;finish and receive: &#123;&#125;&quot;</span>, s);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="title function_ invoke__">Err</span>(_) =&gt;  &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">let</span> (sender, queue) = sync_channel::&lt;Arc&lt;Task&lt;<span class="type">String</span>&gt;&gt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建任务，即我们的异步函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Task::&lt;<span class="type">String</span>&gt;::<span class="title function_ invoke__">new</span>(sender.<span class="title function_ invoke__">clone</span>(), SayHelloInPending::<span class="title function_ invoke__">new</span>(<span class="number">2</span> * <span class="number">1000</span>).<span class="title function_ invoke__">boxed</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送到队列，开始调度</span></span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(Arc::<span class="title function_ invoke__">new</span>(task)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 执行调度</span></span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">executor</span>(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，executor 执行的就是前面讲的内容，注意 Task 是如何转为 waker 的，以及 Context 对象的生成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上可见，Rust 的异步编程是靠 Future 这个关键 trait 实现的，通过调用 poll 方法知道“函数”的状态，若是阻塞，则我们的主线程也即executor 会处理下一个 Task，若就绪，则获得函数的返回值。</p><p>我们日常编程当然不需要写这么复杂的代码，这里主要是在学习 Rust 的异步编程模型，实际上，Rust 的异步库都帮我们封装好了以上这些内容，我们在使用各个异步库的时候，只需要像前面一节课讲的那样，调用 Future 的 await 即可实现异步编程了。我们看看，如果把本节内容实现的东西写成 await 是什么样子，以下是伪代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">SayHelloInPending</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;   </span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">SayHelloInPending</span>().<span class="keyword">await</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;result = &#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><p> 就一行 await 即可。当执行到 await 时，由于 SayHelloInPending 需要等待 IO 完成，此时主线程不会阻塞在 await 这个地方，此时相当于调用了 Future 的 poll 方法，主线程发现是Pending于是跑去执行别的 aysnc 函数（即下一个 Task 的 Future）去了，等到 await 返回才又继续往下执行println（即这个 Task wake 方法调用了 sender 把 Task 放入队列继续给调度器执行）。这段代码后面的奥妙，正是本节讲的内容。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>前面提到了一些我们直接忽略的东西，比如：Pin 这个类型，Pin 到底是什么，为什么 Future 放入 Box 的时候要变成 Pin\<Box\<T\>>，也即 BoxFuture 呢？下一节我们继续前进吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们大概知道了一些异步编程概念，我们快速简单的复习一下：&lt;/p&gt;
&lt;p&gt;1、Rust 依靠生产者和消费者模型来实现异步编程；&lt;/p&gt;
&lt;p&gt;2、被定义为asyn 的函数，其返回值为一个 future，调用它的 await 方法会触发函数的执行；&lt;/p&gt;
&lt;p&gt;3、 因此，IO 线程完成工作后给主线成发送消息，触发 await，从而实现异步。&lt;/p&gt;
&lt;p&gt;以上是上一节讲的最最简单的异步编程模型，但 Rust 异步编程并不是这么简单，因为上一节的模型中，我们没有模拟 IO 阻塞，因此，await 实际上是不会阻塞的，但 Rust 异步编程中，恰恰是因为 await 中有 IO 操作会产生阻塞而设计的。&lt;/p&gt;
&lt;p&gt;那么，await 到底是怎么用的呢？更关键的是，如果 await 是阻塞的，那么是怎么做到一个线程的情况下切换上下文的呢？如何做 await 的 IO 操作完成后继续往下执行的呢？&lt;/p&gt;
&lt;p&gt;本节将会把 await 展开，引入关键的两个 trait： Future 和 Wake，把 Rust 的异步编程模型说清楚。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    <category term="Concurrency" scheme="https://www.jackhuang.cc/categories/Rust/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（二）：区块链的交易协议</title>
    <link href="https://www.jackhuang.cc/2023/02/18/blockchaion-protocol/"/>
    <id>https://www.jackhuang.cc/2023/02/18/blockchaion-protocol/</id>
    <published>2023-02-18T12:24:26.000Z</published>
    <updated>2023-03-07T16:13:14.625Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要讲区块链的交易协议细节，即一笔交易是如何写入区块链的交易数据中的。</p><span id="more"></span><h2 id="去中心化的交易需要解决的问题"><a href="#去中心化的交易需要解决的问题" class="headerlink" title="去中心化的交易需要解决的问题"></a>去中心化的交易需要解决的问题</h2><p>我们先看看中心化的交易是怎么样的。中心化的交易，货币是靠央行发行的，发行货币和发行多少货币一切都是它说的算，交易的清结算也是以它的账簿为准，任何交易数据只要写进它的账簿那么就是生效的。相比下，去中心化的交易系统因此有两个问题需要解决：</p><p>1、如何发行货币；</p><p>2、交易怎么进行才能做到可信。</p><p>因为是去中心化的，谁都可以有机会去更新区块链的数据，那么，货币发行怎么控制呢？同样，因为谁都可以有机会去写入交易数据，那么谁写入的数据才算是真实有效的呢？这些问题就需要区块链的交易协议去解决。</p><p>为了讲清楚交易协议，我们会提出一个个问题，然后看看区块链的去中心化交易协议是如何解决的。</p><h2 id="区块链中的交易过程"><a href="#区块链中的交易过程" class="headerlink" title="区块链中的交易过程"></a>区块链中的交易过程</h2><p>抛开货币的发行问题，先看看交易是如何做到可信的，即一笔交易数据，如何保证双方都是出于真实意图的交易呢？</p><p>区块链两大加密技术之一就是公私钥，公私钥对就代表了一个区块链账户。其中公钥用于个人 ID 的标识，私钥用于签名，保证某一笔交易行为是这个人的意愿。我们举个例子，假设 A 需要转账给 B 和 C，那么交易记录就需要至少记录：</p><p>1、使用 A 的私钥签名交易数据，保证 A 的转账行为是 A 真实发起的。这个签名大家都认可，因为 A 的公钥是公开的，可以验证 A 的私钥签名；</p><p>2、交易记录中还需要 B 和 C 的公钥，因为此时想表达 B 和 C 这两个身份，就必须用他们的公钥，公钥此时就相当于区块链的身份 ID；</p><p>3、交易货币数量。</p><p>似乎以上数据就够了，但试想这样一个场景：</p><p>一个恶意用户，自己生成了公私钥对，告诉 B 和 C 说他是 A，那么，按照上面的三条数据要求，这个恶意用户是可以完全自己伪造出 A 转钱给 B 和 C 用户的。因此，这里就需要一些额外的信息，保证 B 和 C 是知道对方是不是 A。自然想到的是验证 A 的公钥，但 B 和 C 如何验证恶意用户出示的 A 的公钥是否真的是 A 的公钥呢？</p><p>这就需要上一节讲的区块链性质了——区块链上的信息都难以修改，因此是可信的。B 和 C 看到恶意用户出示 A 的公钥后，会去查区块链对应的公钥信息，即对应的余额，看是否有足够的钱支付本次转账，如果足够，那么这次交易就是安全的，这样，哪怕恶意用户不是 A，但他出示的公钥在区块链上的确有足够的余额，那就没问题。</p><p>因此，区块链只认公私钥对，只要交易时有足够的余额，那么交易就可以促成，是不是 A 也就无所谓了。</p><p>上面的文字，如果画成图形，那么看起来就是这样：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-deal-verify.svg" alt="交易时，需要校验身份和资金来源"></p><p>简单来说，就是每次交易，都需要能完成以下重要步骤：</p><p>1、出示付款发公钥和收款方的公钥；</p><p>2、付款方的公钥在区块链中能被找到；</p><p>3、在区块链中对应的付款方公钥下的余额足够支付本次交易；</p><p>4、付款方的公钥能验证交易签名。</p><p>校验通过后，交易信息将被写到区块中，交易就正式生效。如果此后 B 要转账给 D 和 E，那么同样也会进行上面的操作，画成图形，看起来像这这样：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-deal-verify-another.svg" alt="再一次交易"></p><p>由此可见，每一次交易，都有输入和输出双方，每一个输入都是上某次的输出，每一个输出都是下某次的输入，这样就保证的“输入 = 输出” ，账目是平的。</p><h2 id="记账权的争夺——共识机制"><a href="#记账权的争夺——共识机制" class="headerlink" title="记账权的争夺——共识机制"></a>记账权的争夺——共识机制</h2><p>以上，当然会有不少问题，即，因为任何人都可以往区块链写入交易数据，那么，</p><p>1、到底谁去做这个写入操作呢？</p><p>2、如果大家都写，那么势必会造成数据不一致，如果数据不一致了，那么又怎么做到以谁写入的为准呢？</p><p>3、如果有恶意用户争夺到写入权但拒绝写入某个交易从而使某个人无法完成交易怎么办呢？</p><p>这里就需要获得写入权的争夺了。在上一节讲到，区块头部有两个字段，一个是“目标难度值”，即 target，一个是随机字符串，即  nonce，它们就是用于控制记账权争夺的。</p><p>其算法思想如下：为了获取记账权，必须找到一个 nonce值，使得头部的 sha256 值小于 target。由于找到这样一个 nonce 值计算出的  sha256 需要枚举 nonce，因此对争夺记账权的 就依赖于争夺者的算力，算力越高，获得记账权的机会就越大。</p><p>这种依赖算力而不依赖投票的算法，我们叫做比特币的共识机制，它有一个好处就是规避了恶意用户制造大量僵尸账户进行投票影响正常结果的攻击。当然有人会问，如果恶意用户有很强的算力怎么办，要知道，算力很高的用户意味着有很强大的计算机系统，绝非个人所能做到，而拥有强大计算机系统的用户都是希望系统稳定的，就好像一个有权势的国王，他肯定是希望他的国家泰平，不然他自己也就当不成国王了，所以，需要算力极强的计算机系统用户才能写入区块链，保证了区块链的稳定，单个恶意用户是无法撼动区块链的。</p><p>总之，只要找到了 nonce，满足 sha256(区块链头部) &lt; target，那么这个用户就可以写入区块链，他就会把结果广播给其它全节点。其它节点很快就可以验证他的结果，从而接受他的写入结果。</p><h2 id="铸币交易"><a href="#铸币交易" class="headerlink" title="铸币交易"></a>铸币交易</h2><p>前面提到，交易的时候，算力高的用户会写入区块链，一般都是算力高的用户，他们绝非等闲之辈，因为能有这么高算力的人，现实中肯定也是很有能力的（不管是金钱还是权利），他们希望区块链系统稳定，以获取更多的好处，这个好处之一，就是铸币权。</p><p>铸币权就是每次写入交易时，都可以收取交易的手续费和创造出额外的货币，这类似中心化的央行印钱。手续费不用说，额外的货币即每次都可以往区块链的池子里加更多的余额，这个余额不需要像转账那样通过上一次的输出获得，而是直接创造出来，只需要记录记账者本人的公钥和余额即可。像比特币的规则，初始阶段，每次写入交易都可以创造出 50 个比特币，而后每 21 万个区块后则减半，即只能创造出 25 个比特币了，然后如此循环递减，直至为 0。</p><p>这就是区块链货币创造货币的规则。可见，区块链中主要有两种交易，一个是前面提到的转账交易，一个就是这里说的铸币交易。</p><h2 id="区块链的分叉"><a href="#区块链的分叉" class="headerlink" title="区块链的分叉"></a>区块链的分叉</h2><p>前面说了通过算力来解决争夺的两个问题（记账权提出的 1 和 3 问题），问题 2 如果有两个算力都很强大的用户都算出 nonce，都往区块链中写怎么办？</p><p>一种情况，是往中间写，例如下图中，红色节点也是一个找到对应 nonce 值的节点，也打算往区块链中写入，但它的前置节点是在区块链的中间而不是末尾，按照记账权的规则，它是有权写入的，但又很明显，如果允许红色节点写入，那么原本黄色节点后面的蓝色节点将会失效，这对于已经确认交易的用户来说是不可接受的。</p><p><img src="https://www.jackhuang.cc/svg/blockchain-fork.svg" alt="区块链的分叉"></p><p>对于这种想在中间插入的动作，由于其比较短，因此会被认为是孤儿节点（orphan block），这样的孤儿节点是不会被接受的。采用最长的分叉区块链是防止恶意用户插入恶意节点的方法。那么等长的插入呢？即同时都想往区块链中的最后一个节点插入新的区块，比如下图两个红色节点都想往最后一个黄色插入：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-fork-end.svg" alt="等长区块插入"></p><p>此时就属于分布式事务中的未决事务，即只能同时存在两个交易数据，那么什么时候能解决这个分叉呢？一般认为，某一个分叉后有超过 6 个区块节点，则认为另一个分叉的区块无法再超越它，因此短的分叉将会被大家舍弃掉（这种结论，是基于概率学得出来的，实际上，世界上没有 100% 能保证事务最终一致的设计，或者说数学上无法证明某个算法设计能 100% 保证数据最终一致，但实际经验告诉我们反超概率趋近于 0 的设计是可靠的），因此，区块链交易时，收入方会等待 6 个节点确认写入（只需要一小时的时间，因为区块的写入难度控制在每 10 分钟一个区块）或 T + 1日后，即保证交易已经写入区块链中且有了足够长的深度才会放心发货给出款方，这种在交易数额很大的时候会比较常见。</p><h3 id="软分叉"><a href="#软分叉" class="headerlink" title="软分叉"></a>软分叉</h3><p>由上面可以看出，区块链分叉主要有两种形态，其中之一即为软分叉，即临时分叉。分叉除了可能是因为恶意节点攻击产生的意外，更多是因为各个矿工在竞争而引起的，这是区块链的常态，以太坊由于产生区块的频率更高，分叉的几率更大。</p><p>产生软分叉的原因一般是因为区块链程序升级，大部分节点升级成新节点后，挖出来的区块都会集中在新区块节点链条上，这样新节点的区块链足够长的时候，另一条旧节点分叉就会被废除，挖到被废除的分叉得不到承认，因此无法获得出块奖励，此时被废除的节点矿工会主动升级程序以挖到新的区块。</p><h3 id="硬分叉"><a href="#硬分叉" class="headerlink" title="硬分叉"></a>硬分叉</h3><p>硬分叉则是永久性的分叉，即区块链一分为二，一部分矿工升级程序，另一部分矿工不升级，导致两条区块都在增长，且由于新老程序不兼容，导致两边互不承认对方的分叉的区块链，久而久之，就永久分家了。</p><p>这种情况一般是因为一些升级程序的规则没有统一导致的，比如，区块链的大小一般是 1 MB，这是因为区块链的传播是靠 flooding broadcast 的，即每一个节点向其它节点广播大量区块信息，小区块更容易传播，如果是大区块，则完整传播一个区块就相对比较耗时。但有些节点认为 1 MB还是太小了，会升级成更大的区块，这样区块链社区就分裂成了两个阵营，一个认为 1 MB 最合适，另一个认为可以调大一点，于是升级了程序，最终导致区块链永久性分叉。</p><p>永久性分叉带来一个问题，就是如何解决 double spending，即 A 的输出是在原始链路上，由于硬分叉，那么就会出现一条链路 A 交易一次，另一条链路 A 也交易一次，那么 A 相当于余额变成了两倍，如图：</p><p><img src="https://www.jackhuang.cc/svg/hardfork.svg" alt="硬分叉问题"></p><p>从上图中可以看出，A 的钱给了 B 和 C 两次。为了防止这种情况发生，实际上，区块链会有一个 ID 号来标识区块，即如果出现硬分叉，那么，两边的区块信息由于 ID 不同，是互不承认的，相当于两条不同的区块链了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要讲区块链的交易协议细节，即一笔交易是如何写入区块链的交易数据中的。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（一）：基本结构</title>
    <link href="https://www.jackhuang.cc/2023/02/12/block-chain-basic/"/>
    <id>https://www.jackhuang.cc/2023/02/12/block-chain-basic/</id>
    <published>2023-02-12T12:47:38.000Z</published>
    <updated>2023-02-17T17:39:47.388Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们就开始总结一下区块链方面的知识吧，从最基本的区块链结构讲起。</p><span id="more"></span><h2 id="区块链基本信息"><a href="#区块链基本信息" class="headerlink" title="区块链基本信息"></a>区块链基本信息</h2><p>顾名思义，区块链，即一个个块连接起来的链表，但的确加了不少附加信息在上面，我们先看三个最基本的信息：</p><p>1、创世区块；</p><p>2、区块的高度；</p><p>3、区块链难以修改的特性。</p><p>我们先直观的看一下区块链的样子吧：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-first-view.svg"></p><p>我们最先看到的是这是一个链表，但要注意，这个链表的增长方式是从创世区块开始的，也就是区块链和普通链表不一样，是反向增长的，即新增的区块指向最后一个区块，第一个区块是图中的创世区块。</p><p>创世区块是一个很特殊的区块，它一般硬编码在代码中，万事总是要有一个起头，所以创世区块作为区块链的头，要特殊编码，再往后，每一个区块的加入都必须遵循区块链的规则了。</p><p>区块中会分为区块头和与之相关的区块交易体，我们先关注一下区块头。可以看到每一个区块都有一个区块头，即上图红色框框部分，其中一个字段是前一个区块头的sha256结果，也即，每一个区块的标识符都用区块头的sha256来表示，这个结果会写在下一个区块的区块头的字段中，这样，这些区块就组成了一个有序且难以更改的区块链了。</p><p>有序，是因为每一个区块的头部字段都记录前一个区块的头部sha256，因此区块顺序不能变。</p><p>难以修改，是因为区块头一旦被修改，那么其sha256也被跟着改，也即区块的标识符被修改，这会影响下一个区块的区块头内容，也就导致下一个区块的标识也要修改，于是如此串联下去，一处改则处处改。随着区块的增多，修改难度会越来越大，这也就是难以修改的原因。也可以看出，越是古老的区块，修改的难度越大。</p><p>尾部的区块它的头部sha256值，也即其标识符可以保存起来，这样，我们就可以验证整条区块链是否有被修改。例如轻客户端（比如手机）很难去保存所有的区块，但它又想验证最近几个区块是否被修改，这样只需要从全区块链那里获取最近几个区块的头部，然后验证区块链标识是否和所持有的区块链标识是否相等，即可知道这些区块是否被修改，是否信得过了。</p><p>最后讲一下区块链的高度，区块链的高度即区块的多少，当然要注意，创世区块的高度是 0，也就是说，如果有 n 个区块，那么其高度是 n - 1。我们引用一个区块时，除了可以用它的标识符以外，还可以用它的所处高度来表达。例如高度为 0 的区块即创世区块。</p><h2 id="区块头部"><a href="#区块头部" class="headerlink" title="区块头部"></a>区块头部</h2><p><img src="https://www.jackhuang.cc/svg/blockchain-head.svg" alt="区块头部"></p><p>上面的头部是被我们简化的，区块链的头部不仅仅有前块标识字段，还有其它字段，我们放大看看：</p><p>首先是版本，似乎没什么可说的。</p><p>接着就是前面提到的前块区块的头部 sha256，即其区块标识。</p><p>默克尔（merkle）值，是用于检验交易数据的，我们马上讲到。由于有了默克尔值，后面的交易数我们就可以校验，这样我们标识一个区块的时候只需要头部sha256即可，并不需要整个区块 sha256。</p><p>随机难度值和随机数是用于挖矿的，我们将来讲到。</p><h2 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>当我们有很多交易数据时，我们怎么校验它们是否被修改信得过呢？一种直观的方法当然是把它们放在一起然后算一次 sha256，如果有 n 个交易，那么算法时间和空间复杂度为 O(n)。</p><p>默克尔树提供了一个更快更省空间的方案，即将每一笔交易数据做一次 sha256（比特币中是连续计算两次 sha256，以下简称算 sha256 不特地强调），然后这些结果两两做一组再算一次 sha256，再两两做一组算 sha256，如此循环，最后只剩下一个 sha256 值，这个值就是默克尔树根值，有了这个值，我们就可以很快的校验交易是否被修改。其计算过程和结构如下：</p><p><img src="https://www.jackhuang.cc/svg/merkle-tree.svg" alt="默克尔（merkle）树"></p><p>从上面看出，默克尔树树叶节点即我们的交易数据，往上每一层都是下一层数据两两结合计算 sha256 的结果，直到我们算出默克尔树根为止。</p><h3 id="校验交易"><a href="#校验交易" class="headerlink" title="校验交易"></a>校验交易</h3><p>我们需要校验某个交易是否被修改时，尤其是手机这种轻节点，只需要从全节点处拿到从下往上算的路径上的 sha256 节点即可去验证某个交易是否在这个区块中或者是否被修改过。</p><p>例如我们需要计算下图红色节点是否在区块交易数据中，轻节点只需要请求全节点下发黄色 sha256数据给它，它依次从下往上计算出蓝色节点的 sha256 值，直至计算出默克尔树树根值，对比区块头的默克尔树根值是否一致就可以知道交易是否在此区块中（区块头的sha256 我们是由区块标识符保证不被串改的，前面已经讨论）。</p><p><img src="https://www.jackhuang.cc/svg/merkle-tree-verify.svg" alt="默克尔树校验交易过程"></p><p>由于不需要全节点所有的交易数据，此时算法复杂度和空间复杂度只有 O(log<sub>2</sub>n) 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们就开始总结一下区块链方面的知识吧，从最基本的区块链结构讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（一）：基本概念和编程模型</title>
    <link href="https://www.jackhuang.cc/2023/02/10/rust-futures-basic-concept/"/>
    <id>https://www.jackhuang.cc/2023/02/10/rust-futures-basic-concept/</id>
    <published>2023-02-10T15:41:58.000Z</published>
    <updated>2023-05-31T15:29:42.018Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 的异步编程内容太庞大了，从最基础的 futures，到各种第三方库，都有很多内容可讲，今天开始，Rust 编程会聚集到异步编程上，当然，异步编程不仅仅是异步，实际也会涵盖比如网络编程等方面。现在，先来个最基础的开胃菜，基本概念和简单的异步编程。</p><span id="more"></span><h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>现在的服务器操作系统都是多任务可打断式的，即多个任务同时在跑，任务之间会争夺CPU和内存资源。操作系统会有一套算法来调度这些任务，Linux 系统中最经典的就是公平调度算法，算法的思想很简单，就是每次总是运行获得CPU时间最小的那个任务。</p><p>那么什么时候触发这个调度算法呢？有两个时间点：</p><p>1、周期性的调度；即操作系统总是周期性的做一些事情，这个是不可打断的，比如周期性的更新系统时间，周期性的看看IO是否OK，当然也就包括周期性的执行任务的调度算法；</p><p>2、系统调用的时候；即用户态在调用系统调用的时候，会陷入内核态，内核态除了完成用户态的请求，还会执行一次任务调度。</p><p>周期性的执行是不可打断的事情，属于实时调度，这方面我们的进程作为用户态的程序，一般没有机会去优化。</p><p>但系统调用却是靠我们用户态的程序来触发的。所谓系统调用，就是调用操作系统的原生接口，比如sleep，poll等，也就是说，如果我们的程序调用系统调用，会触发一些列的操作系统操作：</p><p>1、切换上下文到内核态；</p><p>2、完成用户态请求；</p><p>3、进行任务调度；</p><p>4、切换上下文回到用户态。</p><p>可能还有其它更多的事情，因此，系统调用代价是很大的。如果有两个线程，那么这两个线程的争夺将触发一系列的代价。</p><h2 id="IO密集型和CPU密集型任务"><a href="#IO密集型和CPU密集型任务" class="headerlink" title="IO密集型和CPU密集型任务"></a>IO密集型和CPU密集型任务</h2><p>我们从系统资源的角度去看线程任务的话，那么主要分为两种：IO 密集型任何和CPU 密集型任务。前者主要会有大量的 IO 操作，因为需要 IO，因此会产生大量的系统调用，比如 read，write，accept 等等，按前面所说，这里将有巨大的上下文切换代价；后者则主要占用 CPU 资源，几乎没有系统调用，但会有大量的应用代码，比如 for， while ，loop，以及对 cache 对内存的频繁访问。</p><p>因此，分离 IO 密集型的任务和 CPU 密集型任务到不同的线程，就有助于提高线程的执行效率，比如一个请求，需要算一算，再读一下DB，最后再算一算，再返回给客户端，一共四个步骤，如果我们按照 IO 密集型和 CPU 密集型任务分离，那么就是两类操作，即读 DB 和返回客户端是 IO密集型任务，算一算则是 CPU 密集型任务，我们的思路是：遇到 IO 任务，则挂起，去做别的事情，保证我们的工作线程跑满 CPU，这样分离后，CPU 利用率就能极大提高，而且，因为遇到 IO 任务，我们去做别的事情不是线程切换，而是应用层的一种调度，这样减少了上下文的切换，减少了系统调度的代价。</p><h2 id="Rust-的异步trait库——futures"><a href="#Rust-的异步trait库——futures" class="headerlink" title="Rust 的异步trait库——futures"></a>Rust 的异步trait库——futures</h2><p>futures 库提供了最基本的上面说的任务模型最基本的trait，官方文档中给了一个比较复杂的例子（其实不复杂，但对于最初的学习者来说，可能会遇到大量的信息应付不过来，工程上，已经有很成熟的 tokio 库实现，这个库以后再讲，我们先把底层原理学清楚），我这里打算从一个更简单的例子开始慢慢演化成 Rust 官方文档案例的样子，有助于理解。</p><p>其实，Rust 的 futures 库并不完整，更多是在定义一个 trait，虽然给了一些实现宏，但还是留有大量的空间给我们去实现，好在第三方库tokio 给出了很好的实现，但正如官方文档所说，你的确可以直接去学习那些库的用法，但最后总是要回过头来了解，futures 库做了什么，或者说定义了什么，Rust 期待的异步模型是什么样子的，这些底层原理还是要搞懂的。</p><p>不像官方文档直接拿出futures trait做例子，这一节，暂时不细讲 futures trait 都定义了什么，我们先把最基础的异步模型讲清楚，再引入 futures trait ，以及其它更多概念，这样，我们先引入一个基本模型，然后再逐个引入各种概念（比如futures trait）从而理解引入的概念解决了什么问题，或者用于做什么的，这样比官方文档直接把大量概念加入进来更容易理解。</p><p>为了更简单更容易理解，我的例子甚至不使用网络库，文件库这些 IO 库，只留下最精简的模型代码，这样我们可以完全聚焦在异步编程模型上，后面我们再加入 IO 库，从而理解 IO 任务和 CPU 任务分离模型基础。</p><p>当我们把这些事情都完全展现出来后，再去看 tokio 库，就有了然于胸的感觉了。</p><h2 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h2><p>异步编程最经典的模型就是生产者和消费者模型，它的原理非常简单：即生产者生产消息，消息放入队列，队列的消息先进先出，因此消费者在队列另一头读出消息然后处理。把这个模型套到上面提到的 IO 任务和 CPU 任务上，那就是，生产者是 IO 任务，而 消费者是 CPU 任务，中间用队列通信，当 CPU 任务遇到 IO 时因为要被阻塞了，因此，会把任务放回队列中，待下次调度，自己会去做其它的CPU任务，用一张简单的图画出来就是这个样子：</p><p><img src="https://www.jackhuang.cc/svg/basic-async-task.svg" alt="基本生产者消费者模型"></p><p>这个模型中，除了 IO 线程会陷入内核态（因为需要调用系统的 IO 接口，属于系统调用），其它地方一般不会再有系统调用，至少不会再有明显阻塞式的 IO 系统调用，保证了 CPU 线程再各个任务间切换时，没有系统调用产生的上下文切换代价。</p><p>那么我们就开始实现这个最基本的模型吧。当然我这里不是实现一个通用的生产者消费者异步处理库，因此代码会比较偏硬，属于教学代码，我们重点放在模型的理解，以及后续各个概念引入时我们可以很方便的理解这些东西的作用，或解决了什么问题。</p><h3 id="Rust-的消息队列模型"><a href="#Rust-的消息队列模型" class="headerlink" title="Rust 的消息队列模型"></a>Rust 的消息队列模型</h3><p>Rust 提供了原生的消息队列模式，这个在之前提到过：</p><p><a href="https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/#channel">https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/#channel</a></p><p>这里我们打算使用 sync_channel。sync_channel 和 channel 都是用于实现生产者消费者模型的，不同之处是：</p><p>1、channel 的队列是“无限”大的，当然不可能是“无限大”，因此为了限制队列的大小，应该使用 sync_channel，它接受一个参数，若队列满了，那么 send 会被阻塞；由于 channel 的队列 “无限大”，因此理论上 send 是不会被阻塞的。</p><p>2、而sync_channel 维护了一个 buffer 队列，接受一个参数控制队列大小。参数可以是 0，当参数为 0 的情况下，send 会被阻塞，知道receive 取走消息。因此，sync_channel 的send 是会被阻塞的。</p><p>我们实现生产者消费者模型，就是利用 sync_channel 来为我们维护中间的消息队列。</p><h3 id="async-函数和-wait调用"><a href="#async-函数和-wait调用" class="headerlink" title="async 函数和 wait调用"></a>async 函数和 wait调用</h3><p>这里，我们开始引入第一个 Rust 异步编程概念，即 async 函数。函数这个概念我们很熟悉了，函数前面加上 async 关键字相当于表示，这个函数会被异步调度执行。</p><p>记住，是异步调度执行，即：函数不会马上执行，是由我们调度后才能执行，举个简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">print_helloworld</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fut</span> = <span class="title function_ invoke__">print_helloworld</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = fut.<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;return: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看第一行，是一个函数，打印 hello world 后返回一个 hello world 字符串，和之前不同的是，函数前面有一个 关键字 async。先暂时不管它，往下看，第 7 行，来了一个 block_on 调用，这是因为所有的异步编程都必须用异步的方式调用，而main 函数是同步函数，那么异步和同步函数之间，必须用像 block_on 这样的同步函数连接，实际上 block_on 帮我们做了一件简单的事情：即等待异步调用结束，避免异步调用还未结束 main 函数就退出了，这样进程就没有了。</p><p>block_on 中有一个 async 块，表示里面的代码将会是异步执行的，可以看到，里面调用了 print_helloworld，但实际上，因为是异步执行，此时 print_helloworld 并没有执行，至于什么时候触发呢？就是第 9 行的 fut.await。</p><p>但 print_helloworld 不是返回一个 String 吗？String 没有 await 字段。这就是 async 的作用，当函数前被加上 async 后，函数的返回值会变成—— future，future 封装了返回值和一些特性，但之前说了，这一节我们暂时不深入到 future，这一节，我们关键去理解生产者消费者模型，此处，我们只需要认为， async 的 出现，使得函数返回值变成了future，而 future 封装了函数的返回值就行。</p><p>future 提供了一个 await 调用，我们一旦调用 await 函数就会被触发执行，正如第 9 行那样，它将会触发 print_helloworld 的执行。await 的返回值就是函数的返回值。</p><p>网上看到很多疑问，就是这并不是异步执行啊，只是单个线程延迟执行了函数而已，类似闭包。</p><p>的确如此，我们并没有开启多线程，一个线程怎么可能会异步执行呢？Rust 没有这种魔力。所以这里我就要提醒一下我已经说的话：</p><p>1、Rust 没有完全实现异步调用模型，它留下了很多空白，tokio 库补上了；这里的 asyn 和 await 只是提供了能异步调用某个函数的能力，并不是实现了异步调用。</p><p>2、想异步执行函数，需要生产者消费者模型，async 和 await 只是给生产者和消费者模型提供了语言上的工具，剩下的我们还是需要自己去实现，当然，tokio 已经为我们实现很多常用场景了，我们后面再说，现在我们需要做的是：理解 Rust 提供的 async 和 await 做了什么即可，后面我们将会看到，它们在生产者消费者这个异步模型中的作用。</p><p>运行上面的代码，程序会按照调用顺序打印出两个hello world：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line"><span class="keyword">return</span>: hello world!</span><br></pre></td></tr></table></figure><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>有了消息队列和 async/await 特性，我们可以去实现生产者消费者模型了。其思路是：创建一个任务类Task，Task 封装 上面提到的future，因此，我们的生产者生产 Task 对象，放入队列，消费者从队列取出 Task 对象，然后调用 await 执行，就是这么简单，往后我们会把这个模型引入更多概念和做法，最终理解整个 Rust 异步编程都有什么内容，现在，就从这个简单的模型开始吧。</p><p>我们先说一下我们的任务：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    fut: Mutex&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Task&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(f: BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            fut: Mutex::<span class="title function_ invoke__">new</span>(f),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，任务只有一个字段 fut，即我们之前提到过的 future，它有await字段可以触发函数的执行。其中，Mutex 我们已经很熟悉，而 BoxFuture\<T\> 是 Pin\<Box\<T\>>  的 type 别名。Box 我们也很熟悉了，但 Pin 是什么呢？现在我们简单理解 Pin 是帮我们实现内存拷贝的一个辅助结构，后面我会提出一个问题，并用 Pin 解决它，那个时候就很好理解了，总之我们现在还是先聚焦在生产者消费者模型吧。</p><p>总之，Task 是一个任务，它的 fut 保存着 async 函数，在 CPU 线程中等待 await 的调用。我们的生产者会生产 Task 对象，即调用上面的 new 方法，然后 send 到队列中，等待消费者调用 await 实现异步。泛型 T 是函数的返回值，用于限定 let x = fut.await; 中的 x 类型的。</p><h3 id="将要被异步调用的函数"><a href="#将要被异步调用的函数" class="headerlink" title="将要被异步调用的函数"></a>将要被异步调用的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_hello</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_world</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_bye</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写出三个简单的将要被异步调用的函数，函数非常简单，没有 IO ，还是那句话，我们本节聚焦生产者消费者模型的实现。</p><p>这三个函数将会返回 future，他们将会被传入三个 Task 对象中去，然后进入队列，等待消费者线程异步拉起 await 调用。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">excutor</span>(queue: Receiver&lt;Task&lt;<span class="type">String</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">           <span class="title function_ invoke__">Ok</span>(task) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r</span> = task.fut.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_mut</span>().<span class="keyword">await</span>;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;await return: &#123;&#125;&quot;</span>, r);</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="title function_ invoke__">Err</span>(_) =&gt;  &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行器是我们这次又引入的一个概念，它的任务就是执行消费者要做的事情，甚至可以起名叫消费者都可以，但有些框架，会在执行器中spawn 出新的线程去跑逻辑，逻辑被 IO 阻塞的时候才返回给执行器并通知 IO 线程处理，等待任务重新进入队列被调度。</p><p>我们这次这个例子很简单，不去起新的线程，直接在执行器中从消息中取出任务，拿到 future 对象后调用 await 执行函数，当三个函数都被执行后则退出。</p><p>可以看到执行器函数也是 async 的，之前也说了，async 函数才能调用 另一个asyn 函数，因为我们饿 future 已经是 async的了，所以我们的执行器也必须是 async 的。</p><h3 id="main函数的实现"><a href="#main函数的实现" class="headerlink" title="main函数的实现"></a>main函数的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">let</span> (sender, queue) = sync_channel::&lt;Task&lt;<span class="type">String</span>&gt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个即将被异步调用的函数，其返回 future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello_fut</span> = <span class="title function_ invoke__">say_hello</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world_fut</span> = <span class="title function_ invoke__">say_world</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bye_fut</span> = <span class="title function_ invoke__">say_bye</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个Task，存放之前三个函数的future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = Task::<span class="title function_ invoke__">new</span>(hello_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = Task::<span class="title function_ invoke__">new</span>(world_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t3</span> = Task::<span class="title function_ invoke__">new</span>(bye_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下创建三个生产者线程，用以模拟多个IO生产的数据操作</span></span><br><span class="line">    <span class="comment">// 第一个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender1</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender1.<span class="title function_ invoke__">send</span>(t1).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender2</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender2.<span class="title function_ invoke__">send</span>(t2).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender3</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender3.<span class="title function_ invoke__">send</span>(t3).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消费者工作，从队列中取出Task，触发await</span></span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">excutor</span>(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是 main 函数做的事情，注释已经写得很清楚，我们实现了一个简单的生产者消费者模型，这是最简单最基本的异步编程模型，利用了 Rust 以下特性：</p><p>1、消息队列；</p><p>2、async/await 调用；</p><p>3、future trait；</p><p>4、线程函数。</p><p>这个模型非常简单，也因此，其实有很多地方可以讨论，有很多问题待解决，因此我们在后续的文章中会对这个模型提出一些问题，从而引入更多细节的东西解决这些问题，最终理解 Rust 异步编程。</p><p>下一节，我们首先讨论是：future 到底是什么？我们将聚焦 future，看看 future在这个模型中扮演的角色，解决了什么问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 的异步编程内容太庞大了，从最基础的 futures，到各种第三方库，都有很多内容可讲，今天开始，Rust 编程会聚集到异步编程上，当然，异步编程不仅仅是异步，实际也会涵盖比如网络编程等方面。现在，先来个最基础的开胃菜，基本概念和简单的异步编程。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    <category term="Concurrency" scheme="https://www.jackhuang.cc/categories/Rust/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>如何构造自定义错误类型和向下转化</title>
    <link href="https://www.jackhuang.cc/2023/02/05/rust-my-error/"/>
    <id>https://www.jackhuang.cc/2023/02/05/rust-my-error/</id>
    <published>2023-02-05T07:02:44.000Z</published>
    <updated>2023-02-05T07:02:47.727Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 所有的错误都是实现了 std::error::Error 这个trait，因此我们只要也实现这个 trait 就可以自定义自己的错误类型了。</p><span id="more"></span><h2 id="实现自定义错误"><a href="#实现自定义错误" class="headerlink" title="实现自定义错误"></a>实现自定义错误</h2><p>那么怎么实现 Error 这个 trait呢？实际上并不需要实现这个 trait 的太多方法，只要有 Debug 这个 trait 就行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyError</span>(<span class="type">u32</span>, <span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Error</span> <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了 MyError，绑定了 u32 和 String 两个变量，用于记录错误码和错误信息。下面的 impl Error for MyError 我们不实现任何方法，Debug trait 都已经有了。</p><p>接下来我们有必要实现 std::fmt::Display 这个 trait，因为大多数标准库的错误都支持 to_string 方法，方便日后我们打印错误 log：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;error code = &#123;&#125;, error message = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">make_my_error</span>(error_code: <span class="type">u32</span>, error_message: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">MyError</span>(<span class="number">999</span>, error_message.<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，除了实现 Display trait，我们还提供了一个静态方法，方便生成错误对象，不用每次去敲Box::new  这种代码。这样我们的自定义错误就做好了，可以写个函数测试一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_error_happen</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(MyError::<span class="title function_ invoke__">make_my_error</span>(<span class="number">999</span>, <span class="string">&quot;some error happen&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解统一错误处理"><a href="#理解统一错误处理" class="headerlink" title="理解统一错误处理"></a>理解统一错误处理</h2><p>前面说了，标准库的所有专属错误都是实现了 std::error::Error ，因此，我们也应该遵守这个规则，方便则任何时候都可以统一的进行错误处理。</p><p>此外，标准库大多数时候也都是使用 Result&lt;T, E&gt; 来表示方法或者函数返回值，正常则放在 Ok(T)，异常则放在 Err(E)，这里的 E 一般就是 Box&lt;dyn Error&gt;。因为，异常需要脱离函数范围在外部处理，所以错误对象需要 Box 存放，然后各个不同的库都有自己的错误定义，统一的是都实现 std::error::Error trait，因此 Box 需要处理的是 dyn Error，即运行时 dispatch。我们以后也应该遵守这个守则，方便统一进行错误处理，即返回值应该是：Result&lt;X, Box&lt;dyn Erro&gt;&gt; 。</p><h2 id="向下转化"><a href="#向下转化" class="headerlink" title="向下转化"></a>向下转化</h2><p>前面说我们返回出去的时候是 Error 这个 trait，那么，我们怎么获得具体的实际类呢？这就涉及到一个向下转化的问题。有两种方法，一种是直接用原始指针进行强行转化，这个是属于 unsafe 的过程，不建议这么干：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">some_error_happen</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = &amp;result &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in raw, error code: &#123;&#125;, error message: &#123;&#125;&quot;</span>, </span><br><span class="line">                    (*(e.<span class="title function_ invoke__">deref</span>() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">dyn</span> Error <span class="keyword">as</span> *<span class="keyword">const</span> MyError)).<span class="number">0</span>,</span><br><span class="line">                    (*(e.<span class="title function_ invoke__">deref</span>() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">dyn</span> Error <span class="keyword">as</span> *<span class="keyword">const</span> MyError)).<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">down_obj</span> = e.downcast_ref::&lt;MyError&gt;();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(e) = down_obj &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in main, error code: &#123;&#125;, error message: &#123;&#125;&quot;</span>, e.<span class="number">0</span>, e.<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，第 5 到 第 7 行使用了 原始指针的方式去进行向下转化。e.deref() 先获得 &amp;T，也即&amp;Error，然后 as 为原始指针，这里就会产生 unsafe 代码，因此这几行都要包含在 unsafe 中，再从 *const Error 转为*const MyError，即两次 as，第一次转为原始指针，第二次转为向上转化的指针。这些直接错做原始指针的行为都是 unsafe的，毕竟，向上转为是有可能失败的。</p><p>因此，Box 提供了安全的 downcast 方法，如果转化失败，则返回None，否则返回 Some，当然其内部也是用 unsafe 实现的，但我们不必感知，应该推荐用这种方法进行向上转化，如第 11行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 所有的错误都是实现了 std::error::Error 这个trait，因此我们只要也实现这个 trait 就可以自定义自己的错误类型了。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 的高级特性</title>
    <link href="https://www.jackhuang.cc/2023/02/03/rust-advance/"/>
    <id>https://www.jackhuang.cc/2023/02/03/rust-advance/</id>
    <published>2023-02-03T10:57:38.000Z</published>
    <updated>2023-02-05T02:50:34.300Z</updated>
    
    <content type="html"><![CDATA[<p>今天讲一下 Rust 的高级特性。</p><p>包括：</p><p>1、unsafe 代码；</p><p>2、高级trait；</p><p>3、高级类型；</p><p>4、高级函数和闭包；</p><p>5、宏。</p><span id="more"></span><h2 id="unsafe-代码"><a href="#unsafe-代码" class="headerlink" title="unsafe 代码"></a>unsafe 代码</h2><h3 id="使用-raw-指针"><a href="#使用-raw-指针" class="headerlink" title="使用 raw 指针"></a>使用 raw 指针</h3><p>最 unsafe 的行为莫过于直接使用 raw 指针，这时会绕过 Rust 的安全检查，比如经典的不能同时有可变和不可变引用规则，若使用 raw 指针，那么就需要我们很清楚的说，这是 unsafe 代码，Rust 才放心的运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">x</span> = &amp;a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsafe</span> &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;*x = &#123;&#125;, *y = &#123;&#125;&quot;</span>, *x, *y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>类似的还有比如存在两个&amp;mut 引用同一个变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> a[..index], &amp;<span class="keyword">mut</span> a[index..])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;split at 3: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> a, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，split_at_mut 函数最后一行两次 &amp;mut a 会违反引用规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> | <span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">  |                    - <span class="keyword">let</span><span class="symbol">&#x27;s</span> call the lifetime of this reference `&#x27;<span class="number">1</span>`</span><br><span class="line"><span class="number">3</span> |     <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line"><span class="number">4</span> |     (&amp;<span class="keyword">mut</span> a[..index], &amp;<span class="keyword">mut</span> a[index..])</span><br><span class="line">  |     -----------------------^----------</span><br><span class="line">  |     |     |                |</span><br><span class="line">  |     |     |                second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*a` is borrowed <span class="keyword">for</span> `&#x27;<span class="number">1</span>`</span><br></pre></td></tr></table></figure><p>这是因为 Rust 担心两个引用数组所包含的区间会相互覆盖。如果我们告诉 Rust 这个是 unsafe 代码，那么， Rust就会让编译通过并运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = a.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(p, index),</span><br><span class="line">         slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(p.<span class="title function_ invoke__">add</span>(index),  a.<span class="title function_ invoke__">len</span>() - index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-unsafe-函数或者方法"><a href="#调用-unsafe-函数或者方法" class="headerlink" title="调用 unsafe 函数或者方法"></a>调用 unsafe 函数或者方法</h3><p>如果一个函数或者方法是 unsafe 的，那么当然我们也必须告诉 Rust 我们知晓这个行为 unsafe，运行吧。</p><h3 id="调用-C-函数也是-unsafe-的"><a href="#调用-C-函数也是-unsafe-的" class="headerlink" title="调用 C 函数也是 unsafe 的"></a>调用 C 函数也是 unsafe 的</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，调用 C 函数的 abs，extern “C” 表示调用 C 函数库。</p><p>当然反过来， C 函数调用 Rust 函数却是 safe 的，这里不展开来说。关于 C 和 Rust 互调以后有机会再说。</p><h3 id="访问静态可变变量也是-unsafe-的"><a href="#访问静态可变变量也是-unsafe-的" class="headerlink" title="访问静态可变变量也是 unsafe 的"></a>访问静态可变变量也是 unsafe 的</h3><p>Rust 中，如果按照存储特性来分，有三种类型：</p><p>const：运行时存放于常量区，非运行时被固化在文件中；const 数据允许出现在任何地方定义。</p><p>static：进程开始后有固定的内存地址；static 数据允许出现在任何地方定义。</p><p>堆栈：堆栈数据则动态分配。堆栈数据则只能在局部中定义。</p><p>这里，若 static 是可变的，那意味着很多地方都可以去访问 static mut，这当然相当于打破了一个变量值允许一个 mut 引用的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> a: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时编译输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |     a += <span class="number">1</span>;</span><br><span class="line">  |     ^^^^^^ <span class="keyword">use</span> of mutable <span class="keyword">static</span></span><br></pre></td></tr></table></figure><p>明确告诉我们，去使用一个 static mut 的变量是不允许的，应该用unsafe：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> a: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-unsafe-trait-也当然是-unsafe-代码"><a href="#实现-unsafe-trait-也当然是-unsafe-代码" class="headerlink" title="实现 unsafe trait 也当然是 unsafe 代码"></a>实现 unsafe trait 也当然是 unsafe 代码</h3><p> 这个调用了 unsafe 函数或者方法一样。</p><h3 id="使用union-也是-unsafe-的"><a href="#使用union-也是-unsafe-的" class="headerlink" title="使用union 也是 unsafe 的"></a>使用union 也是 unsafe 的</h3><p>和 C 一样，Rust 也有union，它是 unsafe的。</p><h3 id="什么时候用-unsafe"><a href="#什么时候用-unsafe" class="headerlink" title="什么时候用 unsafe"></a>什么时候用 unsafe</h3><p>自己能保证没问题的时候，例如上面的 split 数组，很明显，不管怎么样，split 出来的数组都不会相互有空间的覆盖，虽然 Rust 有这方面的考虑，但既然我们能确定不会有，那么我们就告诉 Rust，这个是已知 unsafe 代码，已确保无误。</p><h2 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h2><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 是 trait 的其中特性之一，比如我们有一个 trait 用于表示给人加年龄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中的 item 即某种类型，实现这个 trait 的 struct 来决定它是什么类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">truct Person &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，为什么不用泛型呢？它和泛型区别在于，泛型可以定义多个 Person 实例，而 type 只能一个，比如我们将 AddAge 修改成使用泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in i32&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span>&lt;<span class="type">u32</span>&gt; <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in u32&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age <span class="keyword">as</span> <span class="type">u32</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们可以定义多个 Person::add，根据不同的类型调用不同的 add：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = a.<span class="title function_ invoke__">add</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">u32</span> = a.<span class="title function_ invoke__">add</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">u32</span></span><br></pre></td></tr></table></figure><p>而使用 type 方法，我们就只能定义一种 add 方法了。</p><p>究其原因，还是因为泛型是类型的一部分，所以两个 add 是两个类型，即两个不同的 add 方法。但 type 则只能选其一。</p><h3 id="默认类型参数"><a href="#默认类型参数" class="headerlink" title="默认类型参数"></a>默认类型参数</h3><p>有时我们可以给 trait 的泛型加上默认类型参数，比如上面的例子中， AddAge 这个 trait 大概率就是给 Person 增加年龄，那么，我们可以默认的写出一些代码，使用方只需关心哪个字段是 age 就行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的 T &#x3D; Self 即实现 AddAge 的类型。即默认情况下，使用实现这个 trait 的类型。</p><h3 id="消除相同方法歧义"><a href="#消除相同方法歧义" class="headerlink" title="消除相同方法歧义"></a>消除相同方法歧义</h3><p>如果一个 struct 实现了两个 trait，而这两个 trait 有相同的方法怎么办呢？此时就需要显式的指定调用的是哪个 trait 的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">AddFamilyName</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddFamilyName</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Huang &quot;</span>) + &amp;<span class="keyword">self</span>.name;</span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add age: &#123;&#125;&quot;</span>, AddAge::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add family name: &#123;&#125;&quot;</span>, AddFamilyName::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AddAge 和 AddFamilyName 都有一个叫 fn add(&amp;mut self) -&gt; Self::item; 的方法，那么，在调用它们的时候，需要显式指定是哪一个的 add 方法，如上面的 39 和 40 行所显示。</p><p>但如果是静态 trait 方法呢？比如这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAll</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>() <span class="punctuation">-&gt;</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAll</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此时需要使用模板的表达告诉编译器使用 AddAll的 add 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;add all: &#123;&#125;&quot;</span>, &lt;Person <span class="keyword">as</span> AddAll&gt;::<span class="title function_ invoke__">add</span>());</span><br></pre></td></tr></table></figure><h3 id="trait-还可以增加-bond"><a href="#trait-还可以增加-bond" class="headerlink" title="trait 还可以增加 bond"></a>trait 还可以增加 bond</h3><p>可以给 trait 增加 bond 限制实现实体必须满足其它的 trait 才可以实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;from outline print: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，第一行的trait 定义中， OutlinePrint 需要实现实体必须能满足 fmt::Display 输出的trait，但 Person 没有，此时 impl OutlinePrint for Person  会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">19</span>:<span class="number">21</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> | <span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">   |                     ^^^^^^^^^^^^ required by this bound <span class="keyword">in</span> `OutlinePrint`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加上 Display 的实现后（可以用 to_string 方法了）正常编译和运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;i am &#123;&#125; years old and my name is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.age, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给外部-struct-增加-trait"><a href="#给外部-struct-增加-trait" class="headerlink" title="给外部 struct 增加 trait"></a>给外部 struct 增加 trait</h3><p>如果我们想给不受我们控制的 struct 增加 trait 怎么办？简单的方法当然是用一个新的 struct 把它包裹起来，然后用新 struct 增加新 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;*&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">MyString</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更多是一个编程技巧。</p><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="用-type-起个短名"><a href="#用-type-起个短名" class="headerlink" title="用 type 起个短名"></a>用 type 起个短名</h3><p>前面说到了使用 type 可以在 trait 中定义一个类型，留待实现者填上具体类型，和泛型不同，trait 里面的 type 只能实现一个。但这里讲的是 trait 以外， type 的其它用法。</p><p>最经典的莫过于可以给复杂的名字起个简短的名字了；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ArcMutex</span>&lt;T&gt; = Arc&lt;Mutex&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new_arcmutex</span>&lt;T&gt;(t: T) <span class="punctuation">-&gt;</span> ArcMutex&lt;T&gt; &#123;</span><br><span class="line">    Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(t))    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">new_arcmutex</span>(Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在多线程中经常用到多个线程共同所有切需要修改某个对象的场景，当然就需要使用 Arc&lt;Mutex&lt;T&gt;&gt; 这样的 类型，因此为了少打尖括号，使用 type 起个好打出来的名字也挺好，并且封装了 new 函数，省去每次连续打 new 的麻烦。</p><p>在很多标准类库中，也经常看到类似这样的定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, Error&gt;</span><br></pre></td></tr></table></figure><p>这就是说，错误都是 Error，但 Ok 的情况下，返回值和 T 相关，这样错误类型的代码就可以少打一些。</p><h3 id="表示不返回值"><a href="#表示不返回值" class="headerlink" title="! 表示不返回值"></a>! 表示不返回值</h3><p>不返回值表示对某种情况下，不返回任何东西。该如何理解呢？比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="keyword">match</span> x &#123;</span><br><span class="line">            <span class="number">5</span> =&gt; x,</span><br><span class="line">            _ =&gt; <span class="keyword">continue</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，初始化下，x &#x3D; 0，进过 x +&#x3D; 1，x 变为 1，match 后发现不等于 5，于是 continue，此时 match 即不返回任何值，而是回到 loop 开头，a 的值为定义。直到 x &#x3D; 5，a 才赋值为5。</p><p>函数可以声明为没有返回值的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in print something&quot;</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;will panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不能删去 panic!，除非用其它不会让 print_something 返回的函数或者宏代替（比如写一个死循环），否则，只要 print_something 返回，那么就不是 ! 返回值，比如删去 panic!  的话，返回值就是空tuple：() 。</p><p>unwrap 就是这样的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123; <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h3><p>思考一下 &amp;str 的 str，每次用到它的时候，总是加上 &amp;，因为 Rust 在编译的时候无法知道 str 的具体大小，加上 &amp; 后， Rust 只要知道 str 的地址和其长度就行了，地址和长度（usize）都是在编译时就知道其所需内存空间的，因此 &amp;str 就可以编译。</p><p>所以，Box&lt;str&gt; 和 Rc&lt;str&gt;  就不需要加上 &amp;，因为它们是用 unsafe 代码直接使用指针来实现的，指针大小当然也是编译的时候就知道了。</p><p>任何一个泛型，都默认是 Sized trait的，即编译的时候就知道其大小：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，print_something 是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> + <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sized 是默认的 trait，一般情况下都会被省略。那么，我们的确也可以指定一种实际上编译的时候还未能确定其大小的泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: &amp;T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> + ?<span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(&amp;Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们把 Sized 改成 ?Sized 后，T 就表示一个编译时不能确定大小的泛型了，那么，此时就只能修改成引用类型了（不知道 T 的大小，但&amp;T的大小是可以确定的，即地址是确定的）。</p><h2 id="函数指针和闭包"><a href="#函数指针和闭包" class="headerlink" title="函数指针和闭包"></a>函数指针和闭包</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>之前使用的都是闭包，但实际 Rust 是可以用函数指针的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">multiple2_if_odd</span>(i: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = multiple2_if_odd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_a</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(f).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;new_a = &#123;:?&#125;&quot;</span>, new_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，用闭包似乎更精炼一点。</p><h3 id="闭包也是一个-Sized"><a href="#闭包也是一个-Sized" class="headerlink" title="闭包也是一个 ?Sized"></a>闭包也是一个 ?Sized</h3><p>和 str 一样，闭包也是一个编译的时候并不知道其大小的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_closure</span>()  <span class="punctuation">-&gt;</span> <span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">make_closure</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3 + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">a</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fn（类似的还有FnMut和FnOnce）在编译期间也是不知道其大小的，对于编译器不知道的类型，要么用引用要么用box（或类似容器）来存放即可，这里只能用box（或类似容器，如Rc），因为需要把闭包的生命周期从函数中延长至外部：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_closure</span>()  <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">make_closure</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3 + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">a</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="写一个自己的函数宏（也叫元编程）"><a href="#写一个自己的函数宏（也叫元编程）" class="headerlink" title="写一个自己的函数宏（也叫元编程）"></a>写一个自己的函数宏（也叫元编程）</h3><p>函数宏是 Rust 最复杂的一个概念，即是官方教程，也没有给出很详细的例子，直接说大部分 Rust 程序员都只是使用函数宏而不是创建函数宏，因此没有详细讨论，当然如果真的很想学习 Rust 的函数宏，官方也给出了很详细的教程：</p><p><a href="https://doc.rust-lang.org/rust-by-example/macros.html">https://doc.rust-lang.org/rust-by-example/macros.html</a></p><p>这里只给一个非常简单的函数宏例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;9 + 1 = &#123;&#125;&quot;</span>, my_macro!(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，macro_rules! 即将定义一个函数宏，函数宏名叫 my_macro，后面的大括号就是函数宏要干的内容。函数宏，其实就是匹配参数，匹配中的，就做对应的事情，很像 match，比如上面的代码中，匹配模式即为($a:expr)，expr表示第一个参数表达式，$a 为这个表达式的值，匹配中了，那么就做 &#x3D;&gt; { … } 里面的事情，做什么的呢， $a + 1，即 expr 表达式的值 + 1。</p><p>所以，my_macro!(9) 表达式 expr 为 9，即 $a 为9，也即 9 + 1为10，即 my_macro 函数宏返回 10。</p><p>实现任意参数输入，即反复匹配：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr, $($b:expr), *) =&gt; &#123;</span><br><span class="line">        my_macro!($a) + my_macro!($($b), *)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, my_macro!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即实现任意参数相加，其中 $($b:expr), * 即反复匹配，在第 6 行这个匹配模式中，先拿出第一个匹配出来，剩余的递归匹配，直到为没有参数位置，展开后即各个数相加。</p><p>其输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>符合预期。</p><p>注意最开头的 #[macro_export] 表示这个宏可以导出使用。</p><h3 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h3><p>还记得我们给自己的 struct 加上 #[derive(Debug)] 的宏吗？这个就是过程宏，它帮我们不用写什么代码，直接就实现了 Debug trait，从而可以 println 出来，这就是过程宏。现在我们就写一个自己的过程宏。</p><p>首先新建一个 library，不妨就叫 mymacro 里面简单的定义一个 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">PrintSelf</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_self</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最终要的效果即：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(MyMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>, </span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">print_self</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，只要在我们的 stuct 上加上 #[derive(MyMacro)]，那么就可以实现 PrintSelf trait ，不需要自己写太多代码。</p><p>因此，我们新建一个 library，约定俗成叫 mymacro_drive，在里面，首选要在 Cargo.toml 文件中增加依赖和告诉cargo我们要定义过程宏了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-<span class="keyword">macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">mymacro = &#123;path = <span class="string">&quot;../mymacro&quot;</span>&#125;</span><br><span class="line">syn = <span class="string">&quot;*&quot;</span></span><br><span class="line">quote = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>其中的 syn 库可以解析 Rust 代码，而quote 库可以生成 Rust 代码，在mymacro_drive的 lib.rs 文件中增加以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(MyMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">impl_my_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_my_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">PrintSelf</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">print_self</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;hello, i am &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，#[proc_macro_derive(MyMacro)] 表示定义了一个过程宏 MyMacro，一旦编译器遇到 #[derive(MyMacro)] ，就会调用 my_macro_derive函数。而TokenStream则是编译器解析给我们的 struct 流，syn::parse 则可以读取解析出来内容，内容即为 strut 的属性，第 14 行的quote 宏可以生成 Rust 代码，里面的 15 - 19 行其事是给 quote 生成代码用的，#name 即替代 13行的宏，stringify!(#name) 即转为字符串方便打印。</p><p>重新把代码编程 TokenStream 输出给编译器，编译器即可把 quote 里面的宏内容在使用 #[derive(MyMacro)] 的地方展开，从而少写了 quote 宏里面的代码。这就是过程宏的展开过程。</p><p>类似这样的还有属性宏，即展开后 struct 获得一些字段，还有类函数宏，即自行解析宏里面的代码，比如：</p><p>sql!(select name from table_name where id &#x3D; 3);</p><p>也都是机遇 syn 和 quote这两个库来实现的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天讲一下 Rust 的高级特性。&lt;/p&gt;
&lt;p&gt;包括：&lt;/p&gt;
&lt;p&gt;1、unsafe 代码；&lt;/p&gt;
&lt;p&gt;2、高级trait；&lt;/p&gt;
&lt;p&gt;3、高级类型；&lt;/p&gt;
&lt;p&gt;4、高级函数和闭包；&lt;/p&gt;
&lt;p&gt;5、宏。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>无惧并发</title>
    <link href="https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/"/>
    <id>https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/</id>
    <published>2023-01-31T09:46:41.000Z</published>
    <updated>2023-02-06T01:52:54.235Z</updated>
    
    <content type="html"><![CDATA[<p>前面所有的例子，都是单线程的，现在我们来看看 Rust 都提供了什么多线程能力。</p><span id="more"></span><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>使用 thread 库的 spawn 方法生成一个 thread，其入参是一个closure：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，main 线程结束没等子线程运行完就直接整个线程退出了。</p><h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>所以，我们需要在主线程 join 子线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p> 此时可以保证子线程结束的时候主线程才退出，因为 join 会挂起，直到子线程完成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">5</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">6</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">7</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">8</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="子线程panic"><a href="#子线程panic" class="headerlink" title="子线程panic"></a>子线程panic</h3><p>子线程 panic 是不会影响主线程，也不会影响其它线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;thread panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread2: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">handle2.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">1</span></span><br><span class="line">thread &#x27;&lt;unnamed&gt;&#x27; panicked at <span class="symbol">&#x27;thread</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">35</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看到，尽管thread 线程 panic了，但 thread2 和 main 线程并没有停止，依然继续打完了所有数字。</p><h3 id="主线程panic"><a href="#主线程panic" class="headerlink" title="主线程panic"></a>主线程panic</h3><p>主线程的 panic 则会打断所有子线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">     <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">         thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">     <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;in thread2: &#123;&#125;&quot;</span>, i);</span><br><span class="line">         thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">     thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">     <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line"> handle2.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可见，main 线程 panic 会中断所有的线程。</p><h3 id="panic-与析构"><a href="#panic-与析构" class="headerlink" title="panic 与析构"></a>panic 与析构</h3><p>既然 main 线程panic会中断所有线程，那么会影响析构吗？答案是：</p><p>1、若果是 main 线程的对象，不会影响 main 线程的对象析构；</p><p>2、若是子线程的对象，那么子线程的对象析构不会被触发。</p><p>先看看主线程panic的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;person is being destroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">            age: <span class="number">99</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">45</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可见子线程中 Person 的析构没有被调用。但如果 Person 对象是在主线程（不再贴出实现 Drop trait 的代码）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">46</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">person is being destroyed</span><br></pre></td></tr></table></figure><p>可见，Person 对象的析构被调用，主线程的对象析构没有受到影响。</p><p>那么，如果是子线程 panic 呢？比如子线程 panic，对象也在子线程上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">            age: <span class="number">99</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;thread panic!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line">thread &#x27;&lt;unnamed&gt;&#x27; panicked at <span class="symbol">&#x27;thread</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">40</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">person is being destroyed</span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可见，子线程 panic，其拥有的对象还是会及时析构。可见 panic 对析构的影响如下：</p><table><thead><tr><th></th><th>对象在主线程</th><th>对象在子线程</th></tr></thead><tbody><tr><td><strong>主线程panic</strong></td><td>对象析构</td><td><font color="red">对象不会被析构</font></td></tr><tr><td><strong>子线程panic</strong></td><td>对象析构</td><td>对象析构</td></tr></tbody></table><h3 id="move-所有权到子线程"><a href="#move-所有权到子线程" class="headerlink" title="move 所有权到子线程"></a>move 所有权到子线程</h3><p>之前在讲 closure 的时候，有说过：闭包只是引用上下文，除非使用 move 否则闭包不会获得上下文对象的所有权。我们启动一个线程的时候，也是使用闭包，但 Rust 的线程闭包如果要 catch 上下文，就必须 move：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;peson in m = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">m</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，闭包 m 不会夺走 p 的所有权，因为它的定义前面没有 move，这样没问题。但线程的闭包却不行，线程的闭包必须获得上下文的所有权（如果线程有使用的话）。因为线程 catch 上下文对象，如果不获得所有权，那么可能会造成悬空指针的问题，因此上面的代码编译报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">36</span>:<span class="number">32</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |     <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">   |                                ^^ may outlive borrowed value `p`</span><br><span class="line"><span class="number">37</span> |         <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">   |                                   - `p` is borrowed here</span><br><span class="line">   |</span><br><span class="line">note: function requires argument <span class="keyword">type</span> <span class="title class_">to</span> outlive `<span class="symbol">&#x27;static</span>`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">36</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">   |  __________________^</span><br><span class="line"><span class="number">37</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line"><span class="number">38</span> | |     &#125;);</span><br><span class="line">   | |______^</span><br><span class="line">help: to force the closure to take ownership of `p` (and any other referenced variables), <span class="keyword">use</span> the `<span class="keyword">move</span>` keyword</span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |     <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |                                ++++</span><br></pre></td></tr></table></figure><p>我们按照编译起的提示，在线程闭包前加上 move 即可正常运行。注意，此时 p 已经失去所有权，主线程后续不能再使用 p。</p><h2 id="信息传递的两种主要方式"><a href="#信息传递的两种主要方式" class="headerlink" title="信息传递的两种主要方式"></a>信息传递的两种主要方式</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>使用 move 方式 显然不是最好的，按 Go 语言的哲学：“Do not communicate by sharing memory; instead, share memory by communicating”。即用复制传递信息，而不是共享的方式传递。 Rust 的 sync::mpsc 库提供了 channel 方式来实现线程直接的消息通讯。mpsc 即 multiple producer single consumer，多生产者单消费者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (sender, recv) = sync::mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = recv.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;receive a person: &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(p).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，首先第 7 行生成了一对 channel tuple，一个是 消息发送者sender，和接受者 recv，然后第 9 行 我们将 recv move 进（因为子线程中使用了recv，但没有使用 sender，因此 sender 还在主线程中）子线程，在子线程中，我们调用 recv 来拉取 sender 给过来的对象。</p><p>注意，sender 是在第 14 行，因此，子线程的 recv 是会阻塞的，直到主线程的 sender 发消息过来。recv 方法返回的是 Result，如果没问题，我们将会在子线程收到 Person 对象，否则则是Err。</p><p>主线程启动子线程后，会使用sender 调用 send 方法将 Person 传递给子线程，此时 recv 会结束阻塞，返回Result，若成功，unwrap 出来则是Person对象。</p><p>注意，Person 对象 send给子线程后，主线程就失去所有权了。</p><p>子线程若不想阻塞，可以调用 try_recv，如果子线程需要周期性的处理一些事情，可以写个循环，try_recv 一次，然后再处理一下其它事情，可以用多 sender 写个例子。</p><h3 id="多sender"><a href="#多sender" class="headerlink" title="多sender"></a>多sender</h3><p>对于 sender，我们可以简单的调用 clone 来获得更多的生产者：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, recv) = sync::mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> recv.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(message) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;receive messge: &#123;:?&#125;&quot;</span>, message);</span><br><span class="line">                &#125;,</span><br><span class="line">                TryRecvError =&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;!&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">m</span> <span class="keyword">in</span> message &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_sender</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        new_sender.<span class="title function_ invoke__">send</span>(m).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第 21 行就是 sender 通过 clone 方法直接创建了多个生产者。接受者则使用了 try_recv 来拉取消息。</p><h3 id="Mutex-lt-T-gt-与-Arc-lt-T-gt"><a href="#Mutex-lt-T-gt-与-Arc-lt-T-gt" class="headerlink" title="Mutex&lt;T&gt; 与 Arc&lt;T&gt;"></a>Mutex&lt;T&gt; 与 Arc&lt;T&gt;</h3><p>前面一节讲过，Rc 和 RefCell 是不能用于多线程的，如果有一个资源需要多线程共享，那么我们就需要 Arc&lt;T&gt; 来进行引用计数，因为它的引用计数是原子的，即 atomic reference count。Arc&lt;T&gt; 和 Rc&lt;T&gt; 是一样的，只是它还能支持多线程使用。</p><p>同样，因为多个线程要修改这个资源，那么就需要 Mutex&lt;T&gt; 去代替 RefCell&lt;T&gt;。Mutex&lt;T&gt; 同样和  RefCell&lt;T&gt; 一样，但还能用于多线程。</p><p>因此，若想实现多个线程同时修改一个资源，那么就需要 Arc&lt;Mutex&lt;T&gt;&gt; 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, sync::&#123;<span class="keyword">self</span>, mpsc::&#123;Sender, RecvError, TryRecvError&#125;, Arc, Mutex&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    title: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">boy</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        score: <span class="number">0</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        title: <span class="literal">None</span>,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score_arc</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;boy);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score_handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = score_arc.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;no person!&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;add the score&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> p.score == <span class="number">8</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;score is up to 8&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.score += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;one year pass&quot;</span>);</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title_arc</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;boy);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title_handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = title_arc.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;no person!&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;check the score&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> p.score == <span class="number">8</span> &#123;</span><br><span class="line">                p.title = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;PhD&quot;</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(title) = &amp;boy.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().title &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the boy get title: &#123;&#125;&quot;</span>,title);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，score_handle 这个线程不停的加分数，title_handle 这个线程不停的检查分数是否达标，若达标，则授予PhD，而主线程则不停的检查 title。</p><p>三个线程都在争夺 Person 对象资源，因此，Person 对象资源放在Mutex中。同时，多个线程需要访问 Mutex，需要对 Mutex 进行引用计数，因此，Mutex 放在 Arc 中。</p><p>其中的 lock 函数将会获得资源，若资源被占用，则线程 阻塞在 lock 函数。lock 函数返回 LockGuard，当超出作用域（即每次 loop 循环）则自动释放 lock，因此，三个线程都在争夺 Person 资源，从输出可以看出的确如此：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">score is up to <span class="number">8</span></span><br><span class="line">check the score</span><br><span class="line">the boy get title: PhD</span><br></pre></td></tr></table></figure><h2 id="注意死锁"><a href="#注意死锁" class="headerlink" title="注意死锁"></a>注意死锁</h2><p>尽管 Rust 已经做了很多防止悬挂指针的操作，但依然还是无法防止运行时的错误，死锁就是这样，因为这个不可能通过编译时就能找出来。</p><p>最常见的死锁就是两个线程户等对象已经持有的锁，比如 A 线程拿着 A 锁等 B 线程释放 B 锁，而 B 线程拿着 B锁等 A 线程释放 A 锁，这样A 和B永远无法解开。</p><p>防止这种死锁发生的关键是，每次使用锁的时候，应该多考虑以下问题；</p><p>1、是否必须加锁不可；实际上，胡乱加锁是出现死锁的重要原因，所以每次想到要加锁，那么就要好好思考：是否有不需要加锁的设计或者现有的锁已经可以满足需求；加锁并不是一件很酷的事情，实际上不到万不得已，就不去加锁。</p><p>2、如果非要加锁，那么对同一个资源的加锁操作需要保证顺序一致，互等死锁的问题就在于两个线程加锁顺序不一致造成的；也可以理一下，为什么访问一个资源要加两个锁？这种设计是否已经出问题？</p><p>3、锁的粒度是否过细；过细的锁很容易造成死锁，当然过粗的锁也会降低并行效率；可以回到第一步好好考虑是否应该加锁。</p><p>4、针对业务逻辑建立标准的生产者消费者模型或者规范可以很好的防止死锁发生。因为模型或者规范一旦建立，我们只需要集中写逻辑就行了，无需再对资源争夺问题想太多，少写危险代码就少点风险。底层的逻辑一旦建立好，就应该依赖或者复用，防止反复踩坑。</p><h2 id="Send-和-Sync-trait"><a href="#Send-和-Sync-trait" class="headerlink" title="Send  和 Sync trait"></a>Send  和 Sync trait</h2><p>Send trait 可以让类型获得可以 send 的能力，Rust 几乎所有的类型都是有 send trait 的除了 Rc&lt;T&gt;。</p><p>Sync trait 则可以让类型获得多线程访问的能力，同样， Rc&lt;T&gt; 也是不能用于多线程的，RefCell&lt;T&gt; 也是，必须用 Mutex&lt;T&gt;代替。</p><p>一般情况下不会去手动实现 Send  和 Sync trait，因为它们是 unsafe 的，而且大部分类型都已经是有这两个 trait了，用它们组合而成的 类型也会带有 Send  和 Sync trait。</p><h2 id="注意-join-方法"><a href="#注意-join-方法" class="headerlink" title="注意 join 方法"></a>注意 join 方法</h2><p>spawn生成一个线程后，其返回值是一个 JoinHandle，我们调用它的 join 方法等待线程结束，需要留意的是，join 方法的入参是 self 而不是&amp;self，也就是说，join 后 handle 会失效。这就会有可能造成悬空指针。</p><p>可见，join 一般是等待线程结束时使用，之后就不应该再去操作线程了。</p><h2 id="多线程下-trait-的-‘static-属性"><a href="#多线程下-trait-的-‘static-属性" class="headerlink" title="多线程下 trait 的 ‘static 属性"></a>多线程下 trait 的 ‘static 属性</h2><p>之前的 move 会把所有权移入线程中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        score: <span class="number">100</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> move会把 p 所有权移入线程，但如果改成移入一个引用就会报错了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    score: <span class="number">100</span>,</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;p;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `p` does not live long enough</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |       <span class="keyword">let</span> <span class="variable">a</span> = &amp;p;</span><br><span class="line">   |               ^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">15</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  __________________-</span><br><span class="line"><span class="number">16</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">17</span> | |     &#125;);</span><br><span class="line">   | |______- argument requires that `p` is borrowed <span class="keyword">for</span> `<span class="symbol">&#x27;static</span>`</span><br><span class="line">...</span><br><span class="line"><span class="number">20</span> |   &#125;</span><br><span class="line">   |   - `p` dropped here <span class="keyword">while</span> still borrowed</span><br></pre></td></tr></table></figure><p> 这个很容易理解，主线程可能已经析构 p，但 a 引用还在，此时就是典型的悬挂指针了。因此这里是不应该允许 move 引用的。改成 template 也会出现同样的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_print</span>&lt;T, F&gt;(f: F) </span><br><span class="line">        <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">              F: <span class="title function_ invoke__">Fn</span>() <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">some_print</span>(|| &#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            score: <span class="number">100</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面的代码会有以下错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `T` cannot be sent between threads safely</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  __________________^^^^^^^^^^^^^^^^^^_-</span><br><span class="line">   | |                  |</span><br><span class="line">   | |                  `T` cannot be sent between threads safely</span><br><span class="line"><span class="number">14</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> | |     &#125;);</span><br><span class="line">   | |_____- within this `[closure@src/main.rs:<span class="number">13</span>:<span class="number">37</span>: <span class="number">15</span>:<span class="number">6</span>]`</span><br><span class="line">   |</span><br><span class="line">note: required because it<span class="symbol">&#x27;s</span> used within this closure</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">37</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  _____________________________________^</span><br><span class="line"><span class="number">14</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> | |     &#125;);</span><br><span class="line">   | |_____^</span><br><span class="line">note: required by a bound <span class="keyword">in</span> `spawn`</span><br><span class="line">help: consider further restricting this bound</span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> |         <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span> + std::marker::<span class="built_in">Send</span>,</span><br><span class="line">   |                                  +++++++++++++++++++</span><br></pre></td></tr></table></figure><p>这里的问题就是出在我们打算把 a move 进线程中时，Rust 需要我们保证 a 有以下能力：</p><p>1、可以 move 的能力，这个需要Send trait；（详见：<a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/marker/trait.Send.html">https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/marker/trait.Send.html</a> ）</p><p>2、保证 a 的生命周期覆盖整个线程生命周期。这个是似乎是显而易见的，但为什么呢？因为 Rust 怕我们把引用给 move 进去了，就好像前一个例子，a 是 p 的引用，此时 move a 到线程中是会出现悬空指针的。解决方案是向 Rust 保证：move a 到线程后，它的生命周期会完全覆盖线程的生命周期，直接点讲，在模板中增加 ‘static trait 意味着此处只能使用实际类型，而不能使用引用类型作为模板。（这里和引用参数中的 ‘static 不一样，引用参数的 ‘static 是说这个引用是固化在常量存储区中的，它随进程的生命周期一起开始和结束）。修改方法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_print</span>&lt;T, F&gt;(f: F) </span><br><span class="line">        <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">              F: <span class="title function_ invoke__">Fn</span>() <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面所有的例子，都是单线程的，现在我们来看看 Rust 都提供了什么多线程能力。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的RefCell容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-refcell/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-refcell/</id>
    <published>2023-01-29T13:43:59.000Z</published>
    <updated>2023-02-05T02:51:15.274Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了Box&lt;T&gt; 和 Rc&lt;T&gt; 两个指针容器，本节要讲的是 RefCell&lt;T&gt; ，和 Box&lt;T&gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&lt;T&gt; 和  Box&lt;T&gt;有什么不一样呢？</p><span id="more"></span><h2 id="RefCell-lt-T-gt-和-Box-lt-T-gt-的区别"><a href="#RefCell-lt-T-gt-和-Box-lt-T-gt-的区别" class="headerlink" title="RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别"></a>RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别</h2><p>Rust 的优点（可能也是别人认为的缺点）就是尽可能的在编译时发现问题，令有可能产生问题的代码编译失败，强迫程序员按照既定的规则写代码，从而保证高质量代码。</p><p>例如，Rust 有一条规则：引用一个资源，要么是可变且只允许一个可变引用，要么是不可变的但可以多个不可变引用，决不允许同时存在对一个资源进行可变引用和不可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会产生失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">10</span> |     <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">   |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">11</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">   |                 ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">12</span> |</span><br><span class="line"><span class="number">13</span> |     <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">   |                                    - immutable borrow later used here</span><br></pre></td></tr></table></figure><p>因为此时 b 是不可变引用，而 c 是可变引用，违反了 Rust 的编译规则。</p><p>Box&lt;T&gt; 当然也遵循这点，编译时期 Rust 也检查：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = a.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第 10 行 b 从Box 那里得到了一个不可变的Person对象引用，这没问题。但 11 行又试图获得一个 可变的 Person 对象引用，这就违反了 Rust 最基本的规则。</p><p>那么 RefCell&lt;T&gt;  呢？当然也遵守，因为一个可变引用和不可变引用同时存在是很危险的，这会导致数据或者逻辑不一致。但其区别就是，RefCell&lt;T&gt; 是运行时期才检查，编译时期是可以通过的，一旦运行时被发现违反了这个规则，程序就会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    y.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Box&lt;T&gt; 和 Rc&lt;T&gt; 不一样，RefCell&lt;T&gt; 不支持解引用操作（*a），必须显式调用 borrow_mut 方法才能获得其封装的 RefMut&lt;T&gt; 对象， RefMut&lt;T&gt; 才支持 Deref trait。出于可读性，这里不直接用 “&amp;*a.borrow_mut() ” 这样的写法，而是依赖  RefMut&lt;T&gt; 的封装，假设 y 就是 &amp;T （实际上是 RefMut&lt;T&gt;，但其表现得像 &amp;T一样）。</p><p>编译上面的代码，不会像 Box&lt;T&gt; 那样出现失败，而是成功编译，但运行到 11行时，会产生 panic，因为 Rust 不允许可变引用和不可变引用同时存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = RefCell &#123; value: &lt;borrowed&gt; &#125;, y = Person &#123; age: <span class="number">100</span>, name: <span class="string">&quot;jack&quot;</span> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;already</span> mutably borrowed: BorrowError&#x27;, src/main.rs:<span class="number">19</span>:<span class="number">15</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>也可以看到，一旦 x 被可变引用了，其 value 状态变为被借用，如果两个不可变引用同时存在，那么一点问题都不会有：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码正常编译且运行无误。</p><p>由此可见，RefCell和Box 本质区别就在于，虽然只能有唯一的所有权方，但前者是运行时期检查引用规则，若有违反，则panic，后者在编译时期检查引用规则，若有违反，则编译失败。</p><p>当然方法的区别也是有的Box 两个获取 T 引用的方法是 as_ref 和as_mut，而 RefCell 的两个方法是 borrow 和 borrow_mut 。</p><h2 id="RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型"><a href="#RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型" class="headerlink" title="RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型"></a>RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型</h2><p>我们可以利用Rc&lt;T&gt;的 clone 方法绕过 Rust 的运行时检查，从而获得同时存在多个可变引用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    y.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    z.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码首先用 Rc&lt;RefCell&lt;T&gt;&gt; 的方式创建了一个对象 x，它终究是Rc，因此，可以利用Rc::clone() 方法又获得一个 y 和 z，然后我们通过点操作直接调用放在 Rc 里面的 Refcell 的 borrow_mut 方法，最终达到了同时多个可变引用的目的。</p><h2 id="RefCell-lt-T-gt-导致的内存泄漏问题"><a href="#RefCell-lt-T-gt-导致的内存泄漏问题" class="headerlink" title="RefCell&lt;T&gt; 导致的内存泄漏问题"></a>RefCell&lt;T&gt; 导致的内存泄漏问题</h2><p>由于我们可以使用RefCell&lt;Rc&lt;T&gt;&gt; 创建这么一种类型：即可变且多引用的类型，那么，如果有两个节点，相互引用，那么它们的 Rc 永远无法到达0，也就无法被析构，最终造成内存泄漏：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Next</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;Node&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> Node::Next;</span><br><span class="line"><span class="keyword">use</span> Node::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(t, _) = <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the node will be drop, &#123;&#125;&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先 x 和 y 都是 Rc，然后它们内部又有指针指向另一个Rc，初始化的时候先都初始化为 Nil，然后通过RefCell&lt;T&gt; 的可变性，把它们都各指向对方，于是，main 函数结束的时候，x 的Rc减 1，但原始值为 2，因为 y 有它的引用，所以 2 - 1 &#x3D; 1，不为 0，x不析构，同理，y 也不会析构，于是内存泄漏了。</p><p>上面的 p 是用于观察正常情况下析构是否进行的。上面的代码输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the node will be drop, <span class="number">999</span></span><br></pre></td></tr></table></figure><p>x 和 y 不会被析构。</p><p>解决方案是引入 weak&lt;T&gt; 。weak&lt;T&gt; 即若引用，相对于强引用，若引用首先并不获得所有权，也就是若引用计数是不是 0 并不影响对象的析构。因此，weak&lt;T&gt; 可能持有一个无效的 T 引用，所以 weak&lt;T&gt; 获取 T 引用的时候是返回的 Option&lt;T&gt; ，如果 weak&lt;T&gt; 已经无效，则返回 None，如果 weak&lt;T&gt; 依然有效，则返回Some(T) 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n <span class="title function_ invoke__">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = t.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">None</span> = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;it is None initially&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;y);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of y is &#123;&#125; and strong count of y is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;y), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;y));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(other) = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;other = &#123;:?&#125;&quot;</span>, other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;x);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of x is &#123;&#125; and strong count of x is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;x), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先第二三行的代码 RefCell::new(Rc::new(Nil)) 被修改为 RefCell::new(Weak::new()) ，可以看到我们直接用了weak::new() 初始化 weak&lt;T&gt; 指针，因为 weak&lt;T&gt; 并不需要主动初始化，它是 Rc 的弱引用，先有 Rc 才能有 weak&lt;T&gt;。</p><p>先略过 5 到 9 行，x 和 y 初始化结束后，我们把 x 和 y 互相指向对方，注意第 12 行没有再使用 Rc::clone，而是 Rc::downgrade，与 Rc::clone 返回 Rc 不同，Rc::downgrade 返回一个 weak&lt;T&gt; 对象（这也是获得一个可能非None的 weak&lt;T&gt; 对象的方法），赋值给了 x 的 weak&lt;T&gt;。同理，y 这边也是这样。</p><p>这样 x 和 y 都相互引用了对方，但由于是弱引用，因此，即是它们相互引用，也不妨碍最后离开 main 函数时被析构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it is <span class="literal">None</span> initially</span><br><span class="line">the weak count of y is <span class="number">1</span> and strong count of y is <span class="number">1</span></span><br><span class="line">other = <span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell &#123; value: (Weak) &#125;)</span><br><span class="line">the weak count of x is <span class="number">1</span> and strong count of x is <span class="number">1</span></span><br><span class="line">the node will be drop, <span class="number">999</span></span><br><span class="line">the node will be drop, <span class="number">2</span></span><br><span class="line">the node will be drop, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，最后 x 和 y 都被析构了，我们也打印了weak count 和 strong count，都是 1， 结束的时候，x 和 y 都是Rc，因此 strong count 减 1，x 和 y 析构。weak count 不管多少，都不影响 Rc 被析构。 </p><p>weak&lt;T&gt; 不拥有所有权，依靠调用 upgrade 来获取 T 引用，upgrade 返回 Option&lt;T&gt; ，若原 Rc 已经被析构，则返回 None，否则返回 Some(Rc&lt;T&gt;)。没有初始化的情况下，则直接返回None。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left"></th><th>Box&lt;T&gt;</th><th>Rc&lt;T&gt;</th><th>RefCell&lt;T&gt;</th><th>RefMut&lt;T&gt;&#x2F;Ref&lt;T&gt;</th><th>Weak&lt;T&gt;</th></tr></thead><tbody><tr><td align="left">所有权规则</td><td>只有一个所有权</td><td>依靠强引用计数实现多个所有权</td><td>只有一个所有权</td><td>只有一个所有权</td><td>依靠弱引用计数实现多个所有权，但实际并不获得所有权，依靠Option&lt;T&gt; 来判断资源是否有效</td></tr><tr><td align="left">什么时候使用</td><td>1、大资源，想减少拷贝的时候；2、实现多态；3、实现栈分配；4、实现无限大小的对象。</td><td>需要多个所有权方时。</td><td>若Box&lt;T&gt;编译时期规则（一个资源同一个时间内，要么只有一个可变引用，要么有多个不可变引用，禁止可变引用和不可变引用同时存在）检查无法满足需求，需要在运行时检查，则可以使用RefCell&lt;T&gt;。</td><td>由RefCell&lt;T&gt;的borrow_mut&#x2F;borrow方法返回，一般不直接使用。一般情况下，用户不感知这个类的存在。可以认为borrow_mut&#x2F;borrow返回的就是对应的资源引用即可。</td><td>由 Rc&lt;T&gt;的downgrade方法返回，相比Rc&lt;T&gt;的强引用，Weak&lt;T&gt;用于弱引用。</td></tr><tr><td align="left">解引用方法</td><td>实现Deref trait 和 Copy trait，即let b &#x3D; *a。</td><td>因为有引用计数规则，不能直接拿走所有权，因此不能直接解引用获取资源，即禁止let b &#x3D; *a，必须通过 Rc::clone 和self.as_ref 方法对资源进行访问。当然写成 let b &#x3D; &amp;*a（这样没有拿走所有权，不违反规则） 也可以，但可读性差。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。应该使用self.upgrade方法（返回Option）判断资源是否有效。</td></tr><tr><td align="left">不可变引用方法</td><td>as_ref</td><td>as_ref</td><td>borrow</td><td>直接点运算操作即可</td><td>upgrade判断返回值Option</td></tr><tr><td align="left">可变引用方法</td><td>as_mut</td><td>不支持，但可以结合 RefCell&lt;T&gt; 实现，即Rc&lt;RefCell&lt;T&gt;&gt;</td><td>borrow_mut</td><td>直接点运算操作即可</td><td>不支持，但可以结合Rc&lt;RefCell&lt;T&gt;&gt;实现。</td></tr></tbody></table><p>注意，以上所有的容器都无法在多线程的时候使用。</p><p>那么，多线程怎么办呢？下面就开始无惧并发的学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了Box&amp;lt;T&amp;gt; 和 Rc&amp;lt;T&amp;gt; 两个指针容器，本节要讲的是 RefCell&amp;lt;T&amp;gt; ，和 Box&amp;lt;T&amp;gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&amp;lt;T&amp;gt; 和  Box&amp;lt;T&amp;gt;有什么不一样呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的Rc容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-rc/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-rc/</id>
    <published>2023-01-29T02:14:33.000Z</published>
    <updated>2023-02-05T02:51:10.214Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了 Box&lt;T&gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&lt;T&gt;了。</p><span id="more"></span><h2 id="使用Rc-lt-T-gt-实现多个不可变资源共享"><a href="#使用Rc-lt-T-gt-实现多个不可变资源共享" class="headerlink" title="使用Rc&lt;T&gt; 实现多个不可变资源共享"></a>使用Rc&lt;T&gt; 实现多个不可变资源共享</h2><p>之前的Box&lt;T&gt;实现了一个如同以下的链表：</p><p><img src="https://www.jackhuang.cc/svg/conforbox.svg" alt="Box\&lt;T\&gt;实现无限链表"></p><p>其代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果串入另一个链表如下，Box&lt;T&gt;就不能实现了，因为Box&lt;T&gt;是只能有一个所有权方的：</p><p><img src="https://www.jackhuang.cc/svg/conforrc.svg" alt="两个链表串起来"></p><p>写成代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   Compiling greeting v0.<span class="number">1.0</span> (/Users/jack/Documents/code/rust/vsrust/greeting)</span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `common_list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> |     <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">   |         ----------- <span class="keyword">move</span> occurs because `common_list` has <span class="keyword">type</span> `<span class="type">Box</span>&lt;List&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">   |                    ----------- value moved here</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line">   |                      ^^^^^^^^^^^ value used here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>可见，common_list在第12行的时候就给了 a 链表，b 链表想用是用不了了。此时就需要Rc&lt;T&gt;，它和Box&lt;T&gt;不同之处就是它实现了多个不可变对象的共享资源（Box&lt;T&gt;可变不可变资源都可以，但只能有一个所有权方）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以正常编译并运行。</p><p>注意，Rc&lt;T&gt; 对象之间在赋值的时候需要使用 Rc::clone 方法，如果直接使用赋值，还是会走到Rust的默认行为：所有权转移。</p><h2 id="顺带一提：clone和copy方法"><a href="#顺带一提：clone和copy方法" class="headerlink" title="顺带一提：clone和copy方法"></a>顺带一提：clone和copy方法</h2><p>顺带提一下 clone 和 copy 方法。clone 和 copy 都是带有复制的意思，但 copy 则比较暴力，是资源的安位拷贝，而 clone 则是和具体是类型实现相关，比如上面的 Rc::clone 实现的是浅拷贝，并且引用计数加 1。而String 的 clone 则是字符串拷贝：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        b = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        std::mem::<span class="title function_ invoke__">drop</span>(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，a 虽然超出作用域，甚至调用了drop，但 b 依然能正常打印，因为 String的 clone 是深拷贝。</p><h2 id="打印计数"><a href="#打印计数" class="headerlink" title="打印计数"></a>打印计数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，每次赋值或者走出作用域后都打印一次Rc的内部计数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可见，每次clone，引用计数加 1，对象被销毁，则计数减 1，为 0 时，资源被析构。</p><p>为什么这里用的是 Rc::strong_count 呢？为什么不是调用 Rc::count，因为还有一个 Rc::weak_count 与 Rc::strong_count 对应。这里就引出了一个问题：资源的相互引用。这在引入RefCell&lt;T&gt;  的时候将可能会发生，留待下节讲。</p><h2 id="Rc-lt-T-gt-的方法"><a href="#Rc-lt-T-gt-的方法" class="headerlink" title="Rc&lt;T&gt; 的方法"></a>Rc&lt;T&gt; 的方法</h2><h3 id="解引用"><a href="#解引用" class="headerlink" title="*解引用"></a>*解引用</h3><p>和Box不一样，Box 我们可以通过解引用的方式获得 T 的所有权，但如果我们对Rc进行解引用，那么会编译错误，因为这样越过 Rc 的计数法则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只能得到 Rc&lt;T&gt;  的引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;*x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>修改成 &amp;*x 后 y 将是 Person 的对象引用，一切正常。</p><p>这种方式也是安全的，因为编译器在编译的时候就会检查无误，不会出现悬挂指针。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>调用 &amp;*x 可读性实在是比较差，调用 as_ref 则清晰很多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>和 &amp;*x 等效。</p><h3 id="没有-as-mut"><a href="#没有-as-mut" class="headerlink" title="没有 as_mut"></a>没有 as_mut</h3><p>Rc&lt;T&gt; 不会提供可变 T 引用方法，因为它是针对不可变 T 来设计的。</p><h2 id="什么时候使用-Rc-lt-T-gt"><a href="#什么时候使用-Rc-lt-T-gt" class="headerlink" title="什么时候使用 Rc&lt;T&gt;"></a>什么时候使用 Rc&lt;T&gt;</h2><p>如果 Box这种只能有一方所有权的容器无法满足需求，且不涉及可变资源，那么就可以使用 Rc&lt;T&gt; 了。简单来说可以按以下步骤来确定是否可以使用Rc&lt;T&gt;：</p><p>1、能用 Box&lt;T&gt; 那就用；</p><p>2、若不能用  Box&lt;T&gt;，比如需要多个所有权方，且不涉及可变资源，那么使用 Rc&lt;T&gt;。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Rc&lt;T&gt; 和 Box&lt;T&gt; 一样，都实现了Deref 和 Drop 这两个 trait，即解引用（*a  操作）和 自动析构；</p><p>2、Rc&lt;T&gt; 通过引用计数维护不可变资源是否应该释放，当引用计数为 0 的时候资源将被释放；</p><p>3、应该通过 Rc::clone 来赋值，因为不同的类型 clone 有不同的实现，而如果不用 clone 方法则会发生所有权转移；</p><p>4、和Box&lt;T&gt; 一样，Rc&lt;T&gt; 也是一个单线程容器，不允许多线程使用；</p><p>5、使用as_ref 提高可读性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了 Box&amp;lt;T&amp;gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&amp;lt;T&amp;gt;了。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的box容器</title>
    <link href="https://www.jackhuang.cc/2023/01/28/rust-box/"/>
    <id>https://www.jackhuang.cc/2023/01/28/rust-box/</id>
    <published>2023-01-28T00:22:51.000Z</published>
    <updated>2023-02-05T02:52:59.883Z</updated>
    
    <content type="html"><![CDATA[<p>Box&lt;T&gt;就是模仿Rust的指针行为：</p><p>1、可以解引用访问，即*a操作；</p><p>2、超出生命范围区域会主动释放资源。</p><p>Rust还提供了Rc&lt;T&gt;，RefCell&lt;T&gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&lt;T&gt;。</p> <span id="more"></span><h2 id="为什么需要-Box-lt-T-gt"><a href="#为什么需要-Box-lt-T-gt" class="headerlink" title="为什么需要 Box&lt;T&gt;"></a>为什么需要 Box&lt;T&gt;</h2><p>Rust最大的优点定（当然可能也是一把双刃剑）就是编译的时候确定实体大小。但总有需要运行时才知道的时候，例如多态（往后会讲），或者例如本例这种struct&#x2F;enum类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 List 枚举的Con 类型绑定了一个 i32 和 另一个 List，因此它的大小在编译的时候无论如何都是未知的。编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> | <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  | ^^^^^^^^^ recursive <span class="keyword">type</span> <span class="title class_">has</span> infinite size</span><br><span class="line"><span class="number">3</span> |     <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">  |              ---- recursive without indirection</span><br></pre></td></tr></table></figure><p>这是因为编译的时候编译器就需要给它一个大小定义。这时就可以使用Box&lt;T&gt;来做到确定的大小。当然Box&lt;T&gt;不是未卜先知，而是编译器看到Box&lt;T&gt;就知道它是一个固定大小的struct，因为Box&lt;T&gt;封装了T的原始指针，它的大小是已知的。我们修改List定义，并sizeof打印它的大小：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof i32 = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">i32</span>&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;List&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;List&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;f64&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">f64</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;i16&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">i16</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof list = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;List&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sizeof <span class="type">i32</span> = <span class="number">4</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;List&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">f64</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">i16</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof list = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这里可以看到，不管 Box&lt;T&gt; 的 T 是什么，其大小都是 8，因为  Box&lt;T&gt;其实就是一个封装了 unsafe 原始指针，不管 T 是什么，其大小都是 *mut T，即 8个字节（指针大小）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: *<span class="keyword">mut</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust的标准库大多数都是使用unsafe机制实现的，也就是unsafe代码实现了一套safe库。在其中用sta::alloc库实现了 unsafe 内存分配和释放。</p><p>因此，当我们无法在编译时期就能确定一个 T 的具体大小时（比如 T 是一个 trait，我们不知道 trait 背后的具体对象是什么的时候），就需要Box&lt;T&gt;。另外，Box&lt;T&gt;还可以让对象生命周期延长到其范围之外，即Box&lt;T&gt;封装了一个栈对象。</p><h2 id="实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait"><a href="#实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait" class="headerlink" title="实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait"></a>实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait</h2><h3 id="定义-MyBox-lt-T-gt"><a href="#定义-MyBox-lt-T-gt" class="headerlink" title="定义 MyBox&lt;T&gt;"></a>定义 MyBox&lt;T&gt;</h3><p>MyBox&lt;T&gt;是一个空struct，但它绑定了一个 T 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure><p>new的时候返回MyBox&lt;T&gt;对象即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deref-方法"><a href="#deref-方法" class="headerlink" title="deref 方法"></a>deref 方法</h3><p>为了让MyBox&lt;T&gt;能做到解引用（*），我们必须实现 Deref trait，其中就是要实现deref方法，它就是返回一个 &amp;T：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a 是一个 Box&lt;T&gt; 的话，那么调用 *a 就相当于在调用 *(a.deref())。即获得 T 对象。</p><h3 id="drop-方法"><a href="#drop-方法" class="headerlink" title="drop 方法"></a>drop 方法</h3><p>接着就是Drop trait，即在超出作用域的时候会调用，类似析构函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;nothing to do but println it to see it was called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察分配和析构"><a href="#观察分配和析构" class="headerlink" title="观察分配和析构"></a>观察分配和析构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 a 将会 act like a dynamic pointer，即支持 *a 运算（相当于调用了 a.deref() ），当作用域走出 main 函数后，a会自动销毁，此时a.drop() 被调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">what the a is: <span class="number">100</span></span><br><span class="line">nothing to <span class="keyword">do</span> but println it to see it was called</span><br></pre></td></tr></table></figure><h3 id="主动析构"><a href="#主动析构" class="headerlink" title="主动析构"></a>主动析构</h3><p>有些时候我们想主动析构一个box对象，比如主动释放连接之类的，但如果我们主动的调用drop是会编译失败的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会发现编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">23</span>:<span class="number">7</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> |     a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">   |     --^^^^--</span><br><span class="line">   |     | |</span><br><span class="line">   |     | explicit destructor calls not allowed</span><br><span class="line">   |     help: consider using `drop` function: `<span class="title function_ invoke__">drop</span>(a)`</span><br></pre></td></tr></table></figure><p>这里也给出了提示，使用std::mem::drop 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以主动析构 Box了。</p><h2 id="Box-lt-T-gt-的方法"><a href="#Box-lt-T-gt-的方法" class="headerlink" title="Box&lt;T&gt; 的方法"></a>Box&lt;T&gt; 的方法</h2><p>Box&lt;T&gt; 提供了一些方法供我们访问被封装的对象，但注意这种方式打破了 Box&lt;T&gt;的封装，不过好在 Box&lt;T&gt; 是编译时就能检查所有权和引用规则，所以一般不会出问题（要出也是编译时期就被检查出来），相对这个来讲，RefCell 就比较危险了。</p><h3 id="使用-解引用"><a href="#使用-解引用" class="headerlink" title="使用*解引用"></a>使用*解引用</h3><p>解引用操作会使 Box&lt;T&gt; 返回被封装的对象，这会造成 Box&lt;T&gt;  失去对 T 对象的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">     age:<span class="number">99</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>上面的第 4 行代码会使得 x 失去对 Person对象的所有权，编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">16</span>:<span class="number">36</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line">   |                 -- value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">   |                                    ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>当然其实 改为 let mut y &#x3D; x; 也会使 x:  Box&lt;T&gt;  失去所有权。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>使用as_ref 方法则获得 Box&lt;T&gt; 的 T 引用。除非函数参数必须传入引用，否则一般情况下也不需要使用这个方法，好在不管怎么样，编译器都会帮助我们检查悬空指针的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">print_age</span>(x.<span class="title function_ invoke__">as_ref</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h3 id="as-mut"><a href="#as-mut" class="headerlink" title="as_mut"></a>as_mut</h3><p>相比as_ref，as_mut 则返回一个可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change_age</span>(p: &amp;<span class="keyword">mut</span> Person) &#123;</span><br><span class="line">    p.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">change_age</span>(x.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h2 id="什么时候需要使用-Box-lt-T-gt"><a href="#什么时候需要使用-Box-lt-T-gt" class="headerlink" title="什么时候需要使用 Box&lt;T&gt;"></a>什么时候需要使用 Box&lt;T&gt;</h2><p>总结看来，Box&lt;T&gt; 是一个其实是对 unsafe 指针的封装，那么什么时候会使用Box&lt;T&gt; 呢？一般以下几种情况可以使用：</p><p>1、当 T 是一个大 size 类型时，可以减少拷贝；</p><p>2、需要实现堆的内存特性，即如果资源超出作用域依然不想析构，此时可以用 Box&lt;T&gt; 传递出去；例如在函数中分配内存，在函数外使用，如果不使用 Box&lt;T&gt;，那么代码看起来像这样： </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="keyword">dyn</span> SelfIntroduce &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        SchoolType::school_teacher =&gt; Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 和 Teacher 两个对象都会在函数结束的时候被析构调，外面的使用方将会变成悬挂指针。但如果改成Box&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> SelfIntroduce&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        SchoolType::school_teacher =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;),   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当函数返回的时候，内部的 Box&lt;T&gt; 将指针所有权全传递给外面使用方，指针所指资源依然存在不会被析构。</p><p>3、正如上面的例子，Student 和 Teacher 都实现了 SelfIntroduce trait，因此可以使用 Box&lt;T&gt; 来实现多态；</p><p>4、也正如最开始的例子，如果是一个无限大的 struct&#x2F;enum，那么也可以用 Box&lt;T&gt;，因为 Box&lt;T&gt; 是对指针的封装，大小总是固定的，可以在编译时确定。</p><h2 id="Box-lt-T-gt-要留意的地方"><a href="#Box-lt-T-gt-要留意的地方" class="headerlink" title="Box&lt;T&gt; 要留意的地方"></a>Box&lt;T&gt; 要留意的地方</h2><p>1、Box&lt;T&gt; 只能有一个所有权方；</p><p>2、Box&lt;T&gt; 只能单线程使用；</p><p>3、Box&lt;T&gt; 的三个方法（解引用，as_ref 和 as_mut）可以让我们方法 T 对象，解引用可能会失去所有权，而引用不会，编译器会检查，防止悬空指针出现。</p><p>那么如果需要多个所有权就需要后面讲的 Rc&lt;T&gt; 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Box&amp;lt;T&amp;gt;就是模仿Rust的指针行为：&lt;/p&gt;
&lt;p&gt;1、可以解引用访问，即*a操作；&lt;/p&gt;
&lt;p&gt;2、超出生命范围区域会主动释放资源。&lt;/p&gt;
&lt;p&gt;Rust还提供了Rc&amp;lt;T&amp;gt;，RefCell&amp;lt;T&amp;gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&amp;lt;T&amp;gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的工作空间（workspace）</title>
    <link href="https://www.jackhuang.cc/2023/01/26/rust-workspace/"/>
    <id>https://www.jackhuang.cc/2023/01/26/rust-workspace/</id>
    <published>2023-01-26T09:27:20.000Z</published>
    <updated>2023-02-05T02:51:30.286Z</updated>
    
    <content type="html"><![CDATA[<p>前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。</p><span id="more"></span><h2 id="为什么需要workspace"><a href="#为什么需要workspace" class="headerlink" title="为什么需要workspace"></a>为什么需要workspace</h2><p>正如前面所说，项目中，个人既要能做到对自己的代码进行单元测试，也要能和别人的代码进行集成测试，因此，项目必须能同时满足独立构建和协同构建。Rust 的workspace正是这个概念。它可以创建独立的 library 工程，也可以同时对几个 library 工程进行依赖构建，也即独立工作时可以非常独立，需要协作时又能迅速集成，期间不需要太多复杂的操作，仅仅只是从工程子目录切换到工程workspace目录，简单而有效。</p><h2 id="如何构建workspace"><a href="#如何构建workspace" class="headerlink" title="如何构建workspace"></a>如何构建workspace</h2><p>我们以 <a href="https://github.com/jackzhhuang/rscount">https://github.com/jackzhhuang/rscount</a> 为例，说说workspace的结构是怎么样子的。</p><p>首先，切换到 workspace_example 分支，因为master分支还在开发中，可能目录结构等等都会变化，为了说明 workspace 结构，我新拉了一个示例分支用来讲 workspace 的结构。</p><p>拉取分支后，可以看到，其目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rscount</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── rsconfig</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── config.rs</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── rscount_main</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── rsfile</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src</span><br><span class="line">        ├── lib.rs</span><br><span class="line">        ├── rs_code_dir.rs</span><br><span class="line">        └── rs_code_file.rs</span><br></pre></td></tr></table></figure><p>首先 rscount 就是我们的workspace根目录，这个目录是用mkdir命令创建的，cd进入rscount就可以开始workspace的创建了。</p><p>需要说的是，rscount&#x2F;Cargo.toml 是 workspace 的结构说明，里面主要展示 workspace 都有哪些子工程，该文件内容是手动写入的，每创建一个子工程就需要手动写入一次工程名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;rscount_main&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsfile&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsconfig&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，一共有三个子工程，名字分别是：rscount_main，rsfile和rsconfig。这些子工程都是用 cargo new 命令来创建的。对于 rscount_main 这种执行文件工程，直接在rscount目录下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new rscount_main</span><br></pre></td></tr></table></figure><p>即可。</p><p>而对于rsfile和rsconfig，因为是 library 工程，需要加上 –lib参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new rsfile --lib</span><br><span class="line">cargo new rsconfig --lib</span><br></pre></td></tr></table></figure><p>创建好这些工程后，就可以写代码编译了，当然可以一起编译，即在rscount下cargo build，也可以分别在各个子工程下分别编译。这里还需要注意的是，rscount_main依赖了rsfile和rsconfig两个工程，因此需要在其rscount_main&#x2F;Cargo.toml中告诉编译器这个依赖关系：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="设置编译选项-编译release版本"><a href="#设置编译选项-编译release版本" class="headerlink" title="设置编译选项-编译release版本"></a>设置编译选项-编译release版本</h2><p>编译的时候，cargo build加上 –release参数即可编译release版本，我们还可以指定release版本的参数，比如最常见的优化级别，debug版本优化级别我们设置为0，release版本优化级别设置为3:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>还有很多编译选项可以甚至，具体可以参考官方文档。</p><h2 id="使用crates-io"><a href="#使用crates-io" class="headerlink" title="使用crates.io"></a>使用crates.io</h2><p>除了自己写 library，还可以求助crates.io，上面有很多其他人编写的 libray库，例如我们需要mysql客户端库，但我们不想自己写一个，肯定有人已经写好了，于是我们上crates.io搜索mysql： <img src="https://www.jackhuang.cc/images/WX20230127-101853@2x.png" alt="使用create.io搜索第三方库"></p><p>​将mysql这个库写入dependencies中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br><span class="line">mysql = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>然后编译，可以看到cargo可以自动下载库并建立依赖，直接使用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>闭包和迭代器</title>
    <link href="https://www.jackhuang.cc/2023/01/25/closure-and-iter/"/>
    <id>https://www.jackhuang.cc/2023/01/25/closure-and-iter/</id>
    <published>2023-01-25T06:44:32.000Z</published>
    <updated>2023-02-05T02:52:48.473Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。</p><span id="more"></span><h2 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h2><p>闭包，即closure，简单说即：</p><p>1、匿名函数；</p><p>2、可以当作value赋值，灵活调用；</p><p>3、闭包的入参和出参除了定义闭包的时候可以指定，还可以由编译器推断（这样更简洁）。</p><p>以下是最简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>(), </span><br><span class="line">                              <span class="string">&quot;hello rust!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                              <span class="string">&quot;hello jack!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),];</span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;print in closure: &#123;&#125;&quot;</span>, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的闭包即“|x| println!(“print in closure: {}”, x)”，这是一个匿名函数，入参为x，编译器会推理为String，根据代码的实现，没有返回参数，只是简单的打印了String的值。</p><p>关于闭包这里不在对其定义阐述更多基本的内容，只需要知道，Rust的闭包入参和出参都是可以依靠编译器推断的就行，关键是Rust的闭包相对于其它语言需要留意的地方。</p><h3 id="是move还是引用？"><a href="#是move还是引用？" class="headerlink" title="是move还是引用？"></a>是move还是引用？</h3><p>闭包最大的特点就是可以capture上下文变量，那么，这个capture在Rust中是move还是引用呢？答案是：引用。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面的例子中，show这个闭包不接受任何参数，但capture了上面的list，show被调用后，list所有权没有被show拿走，依然还在，第7行正常打印list。</p><p>那么，如果闭包就是像move走所有权呢？需要在闭包的前面加上move：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>此时编译出错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">51</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">4</span>  |     <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">   |         ---- <span class="keyword">move</span> occurs because `list` has <span class="keyword">type</span> `<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">   |                ------- value moved into closure here</span><br><span class="line"><span class="number">6</span>  |         <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                     ---- variable moved due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> |     <span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                   ^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>因为list的所有权被show拿走了，最后的print对list的访问将会报错。</p><h3 id="mut闭包"><a href="#mut闭包" class="headerlink" title="mut闭包"></a>mut闭包</h3><p>默认情况下，和Rust基本特性一样，闭包对上下文的capture都是immutable的，如果需要在闭包中更改变量，除了被capture的上下文需要是mut的以外，闭包也需要声明为mut：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">more</span> = || &#123;</span><br><span class="line">    list.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">more</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面这个例子中，list和more都需要mut才能编译通过。</p><h3 id="FnOnce，-FnMut和Fn"><a href="#FnOnce，-FnMut和Fn" class="headerlink" title="FnOnce， FnMut和Fn"></a>FnOnce， FnMut和Fn</h3><p>闭包结合Rust的所有权特性，会对闭包的调用有所限制。闭包的trait有三个：FnOnce，FnMut和Fn。</p><p>FnOnce，顾名思义，表示因为有所有权转移，该闭包只能被调用一次。</p><p>FnMut，Mut即表示改变的意思，意思是该闭包会修改上下文变量，但不会产生所有权转移。</p><p>Fn则比较佛性，即不修改上下文变量名，也不产生所有权转移。</p><p>看下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">70</span>,</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">100</span>,</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[r1, r2, r3];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;return once&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">operation</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the list is &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本意是调用一次sort_by_key方法就会push一次字符串，但编译不通过的是，sort_by_key的入参中，闭包需要是FnMut，可上面的代码中，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只能被调用一次，因为第二次s已经没所有权了，即此时闭包的trait是FnOnce属性的，打开sort_by_key方法的代码可以发现的确是需要FnMut的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(no_global_oom_handling))]</span></span><br><span class="line">  <span class="meta">#[rustc_allow_incoherent_impl]</span></span><br><span class="line">  <span class="meta">#[stable(feature = <span class="string">&quot;slice_sort_by_key&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">  <span class="meta">#[inline]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort_by_key</span>&lt;K, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> f: F)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">      F: <span class="title function_ invoke__">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> K,</span><br><span class="line">      K: <span class="built_in">Ord</span>,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="title function_ invoke__">merge_sort</span>(<span class="keyword">self</span>, |a, b| <span class="title function_ invoke__">f</span>(a).<span class="title function_ invoke__">lt</span>(&amp;<span class="title function_ invoke__">f</span>(b)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>闭包是迭代器最常用的工具，而迭代器又是批处理集合最常用的方法，下面我们就看看Rust的迭代器是怎么用的吧。</p><h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>迭代器是Rust处理集合最最最常用的方法，可以说没有之一。如果依然使用for语句去处理集合，一来不够Rust，二来效率不如迭代器快，因为迭代器是零成本抽象实现。</p><p>关于零成本抽象有很多介绍，但很多人不太理解，这里尝试用最简单的人话说：即只仅仅实现需要的代码，无需额外的代码（成本）。</p><p>再简单一步说，即人类目前设计出最抽象的代码，以至于你不可能再写出更抽象的了（如果可以，请提交PR），因为已经是最抽象的代码，已经没有简化优化的空间，因此效率是最高的。</p><p>迭代器就是高度零成本抽象的代码，我们应该尽可能使用迭代器去处理集合，而不是写for语句。</p><p>Rust中迭代器是一个trait，基本定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of the elements being iterated over.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>其主要的方法是next，每次调用next迭代器都会返回当前元素Some(T)，并且跳到下一个元素，直到所有元素被完全枚举，此时返回None。如果自己定义一个集合也想有迭代器trait，那么也需要去实现这个next方法。</p><p>从上面看出，迭代器是有状态的，即它会记录目前在集合中的位置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><p>那么，当手里拿着一个集合时，如果需要逐个处理，我们应该首先把它变成迭代器，Rust的集合有三个不同的迭代器变化方法，分别对应三个用途，即：iter，into_iter和iter_mut。</p><h3 id="iter，into-iter和iter-mut"><a href="#iter，into-iter和iter-mut" class="headerlink" title="iter，into_iter和iter_mut"></a>iter，into_iter和iter_mut</h3><p>iter是把集合转成引用迭代器，即访问集合元素时以引用的方式访问，不会有所有权转移。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line"> ];</span><br><span class="line"></span><br><span class="line"> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面第7行 x 其实是&amp;String，因此第9行访问 v 时，v 依然时有效的集合。顺便所一下，for_each会拉起对集合的处理流程，即对每一个元素都以参数的方式传入 for_each 中的闭包，即上面的 x。</p><p>如果改成into_iter方法，那么 x 就会变成 String，导致 v 中元素对 String 所有权丢失（都跑 x 去了）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> |     v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line">   |       ----------- `v` moved due to this method call</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> |     <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">   |                              ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>而 iter_mut 即上面的 x 为可变引用（&amp;mut String），注意此时集合本身也必须是可变的才行。这里不多举例了。</p><p>稍微总结一下：</p><p>iter方法：转为引用访问的迭代器，因此没有所有权转移；</p><p>into_iter方法：转为所有权转移的迭代器，因此集合会丧失对所有元素的所有权；</p><p>iter_mut：转为可变引用访问的迭代器，因此也没有所有权转移，且还可以修改元素。</p><h3 id="map和collect"><a href="#map和collect" class="headerlink" title="map和collect"></a>map和collect</h3><p>前面演示了迭代器的 for_each 方法，它只是遍历一遍元素，实际上我们不仅可以遍历一遍元素，还可以把这些被处理的元素以新的集合返回出来，例如map和collect组合，我们先用map：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面的例子中 map 的 x 就是&amp;mut String，我们对 x 进行追加一个 “!”  操作，它作为返回值返回给新的迭代器，但这里并没有把新的迭代器写出来，编译执行以上代码，发现 v 并没有变化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all v = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello rust&quot;</span>, <span class="string">&quot;hello jack&quot;</span>]</span><br></pre></td></tr></table></figure><p> 这是怎么回事呢？因为和 for_each 不同，map 是个偷懒的函数，如果没有新的迭代器去装返回值，那么它就不会被触发，另外，新的迭代器类型是靠返回值类型来推断出来的，我们可以用其它迭代器来装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list</span>: LinkedList&lt;_&gt; = v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>); </span><br><span class="line">    x.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">&#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all list = &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>这里用了 LinkedList&lt;_&gt; 来装。调用迭代器的collect方法会迫使迭代器去产生新的迭代器进而产生新的集合。</p><p>为什么这里 LinkedList&lt;_&gt; 省略了模板类型呢？用了下划线 _ 来代替，因为编译器可以推理出下划线 _ 即 String，我们可以省略不写太多字母。</p><p>此外，我们的map中的闭包返回了 x.clone()，即&amp;mut String的 clone，这是因为如果返回 x，即 LinkedList&lt;_&gt;为LinkedList&lt;&amp;mut String&gt;，最后两句print宏会产生歧义，即 v 是immutable引用，而v是mutable引用，Rust不允许对同一个对象即有mut又有immut引用。</p><p>总之，我们可以用迭代器产生新的迭代器，其产生映射可以用 map 函数来生成新的集合元素，map返回新的迭代器。</p><p>而用迭代器的 collect方法把迭代器重新变回为集合，集合类型可以用返回值推导出来。这是最常用的方法了。</p><p>除了map，还有不少其它引射方法，比如filter，其输入的闭包若返回true则进入到新的迭代器中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evens</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evens = &#123;:?&#125;&quot;</span>, evens);</span><br></pre></td></tr></table></figure><p>输出为偶数集合：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的测试框架</title>
    <link href="https://www.jackhuang.cc/2023/01/21/rust-test/"/>
    <id>https://www.jackhuang.cc/2023/01/21/rust-test/</id>
    <published>2023-01-21T01:16:18.000Z</published>
    <updated>2023-02-05T02:51:25.618Z</updated>
    
    <content type="html"><![CDATA[<p>测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。</p><span id="more"></span><h2 id="生成测试框架"><a href="#生成测试框架" class="headerlink" title="生成测试框架"></a>生成测试框架</h2><p>在生成 library 库的时候，Rust一定会生成一个简单的测试模板，例如，我们建立一个名叫jacktest的库：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new jacktest --lib</span><br></pre></td></tr></table></figure><p>此时就会在src目录下生成lib.rs文件，里面就是一个简单的测试模板，简单的对 2+2 进行测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里先注意到的是之前我们用过的一个语法 #[]，即表明增加某个属性（attribute），比如之前用的 #[derive(Debug)] 就是指这是一个派生（derive）属性，具体属性为Debug，即这个struct可以用于Debug，比如格式化打印观察里面的数据。</p><p>这里 #[test] 则表示it_works是一个 testing 函数，会被命令cargo test调起。执行cargo test后，会打印出it_works被执行的测试信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们就可以自己添加自己想要测试的内容了。这里不去讨论太多assert宏的使用，这个在官方文档花了大量篇幅介绍，这里不去一一介绍那些assert宏。关于assert宏的要说的有两点：</p><h3 id="assert宏的应用"><a href="#assert宏的应用" class="headerlink" title="assert宏的应用"></a>assert宏的应用</h3><p>第一，我们应该尽量选择合适的assert去体现测试原意，比如计算两个值是否相等，使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b);</span><br></pre></td></tr></table></figure><p>就比使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(a == b);</span><br></pre></td></tr></table></figure><p>要好。因为assert_eq出来的信息比assert出来的信息更能反映测试目的。</p><p>第二，assert后面可以打印一些format信息帮助我们在看测试结果的时候能看到更多有用的信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>测试框架遇到panic会直接报错，但和平常的panic处理方法不同，测试框架里面的panic不会停止测试流程，只是单个测试会中断而已，例如我们在上一个测试代码中增加一个测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_will_panic</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;something goes wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试框架还是会执行其它的测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line"><span class="keyword">in</span> partial_cmp of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">240</span></span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_will_panic&#x27; panicked at <span class="symbol">&#x27;something</span> goes wrong!&#x27;, src/lib.rs:<span class="number">41</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">test tests::equal ... ok</span><br><span class="line">test tests::it_will_panic ... FAILED</span><br></pre></td></tr></table></figure><p>这是因为测试框架是用多线程来拉起测试用例的，某一个用例panic只会影响某一个线程，不会使整个测试框架进程都退出。</p><p>panic也可以format我们输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;the value is &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><h3 id="should-panic"><a href="#should-panic" class="headerlink" title="should_panic"></a>should_panic</h3><p>有些时候panic就是我们所期望的，特别是我们需要测试一些失败用例的情况下，比如设计一个类，关联一个 1 到 100 的数字，如果输入不在这个范围内则panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果输入200到new方法中，则理应在13行panic，这是我们期待的，但如果直接执行测试，那结果是不通过的，这时就需要should_panic宏来告诉测试框架，这个是我们期待的panic，可以认为通过。那么怎么告诉呢，其原理是检查panic宏打印的log是否包含should_panic中指定的字符串，如果包含，则认为如预期panic，测试用例通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，#[should_panic(expected &#x3D; “less than or equal to 100”)] 就是指定期待panic的地方，其中expect所等于的字符串，就是子串，只要逻辑代码中panic信息包含这个子串，那么认为测试通过而不是报失败。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::greater_than_100 - should panic ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><p>如果我们交换Guess函数中 if - else 语句的panic，此时panic信息自然就不是期待的那样了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行测试，走入if value &gt; 100分支中，但提示信息和should_panic不一样，那么会被判定为不期待的panic，测试失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">note: panic did not contain expected string</span><br><span class="line">      panic message: `<span class="string">&quot;Guess value must be greater than or equal to 1, got 200.&quot;</span>`,</span><br><span class="line"> expected substring: `<span class="string">&quot;less than or equal to 100&quot;</span>`</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greater_than_100</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">0</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h2 id="控制测试框架"><a href="#控制测试框架" class="headerlink" title="控制测试框架"></a>控制测试框架</h2><h3 id="测试框架的参数"><a href="#测试框架的参数" class="headerlink" title="测试框架的参数"></a>测试框架的参数</h3><p>测试框架参数分成两种，一种用于过滤测试代码用例（比如执行或者不执行某些测试用例），一种是用来控制测试框架行为的（比如用例的执行方式，怎么打印信息等）。</p><p>两种参数用 – 隔离。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test 测试用例过滤参数 -- 控制测试框架行为参数</span><br></pre></td></tr></table></figure><h3 id="控制测试用例行为"><a href="#控制测试用例行为" class="headerlink" title="控制测试用例行为"></a>控制测试用例行为</h3><h4 id="控制测试线程数量"><a href="#控制测试线程数量" class="headerlink" title="控制测试线程数量"></a>控制测试线程数量</h4><p>之前也提到过，测试框架使用的是多线程拉起各个测试用例的，也就是测试用例是并行运行的，一般情况下不会有什么问题，但如果比如两个用例同时写一个文件那么久会出现不可预知的后果，这时就需要我们告诉测试框架，使用单线程去执行用例，这个是控制测试框架行为的，所以放在 – 的右边：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --test_threads=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就不会有并发运行测试了。</p><h4 id="在测试流程中打印print信息"><a href="#在测试流程中打印print信息" class="headerlink" title="在测试流程中打印print信息"></a>在测试流程中打印print信息</h4><p>假设我们现在有一个矩形面积类：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要测试哪个矩形的面积哪个面积大，那么我们必须先实现PartialEq（需要实现eq方法）和PartialOrd（需要实现partial_cmp方法）这两个trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialEq</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eq</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in eq of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() == other.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialOrd</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">partial_cmp</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;std::cmp::Ordering&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in partial_cmp of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() &gt; other.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Greater);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Less);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但我们在进行测试的时候，发现println!并没有打印出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            width: <span class="number">10</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">120</span>,</span><br><span class="line">            width: <span class="number">2</span>,</span><br><span class="line">            name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是因为cargo test不会打印出标准输入输出，为了打印print信息，控制测试框架行为，需要这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --nocapture</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output</span><br></pre></td></tr></table></figure><p>这样，我们在代码中print出来的数据就能看到了。</p><h3 id="过滤测试用例"><a href="#过滤测试用例" class="headerlink" title="过滤测试用例"></a>过滤测试用例</h3><h4 id="运行指定用例"><a href="#运行指定用例" class="headerlink" title="运行指定用例"></a>运行指定用例</h4><p>在默认情况下，如果只是运行cargo test那么所有被标记为 #[test] 属性的用例都会被执行，但偶尔我们只想运行其中某个用例，此时就可以直接用名字来指定某个用例，例如增加一个这么个用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eq</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">10</span>,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不想执行large测试用例，只想执行eq测试用例，那么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test eq -t- --show-output</span><br></pre></td></tr></table></figure><p>因为是过滤，所以eq写在 – 的左边。表示执行以eq为开头的用例。这样large用例就不会被拉起。</p><p>如果想运行多个，那么用前缀匹配即可，例如增加一个eq_fail：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"> <span class="meta">#[should_panic(expected = <span class="string">&quot;not equal!&quot;</span>)]</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">eq_fail</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">10</span>,</span><br><span class="line">         name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">20</span>,</span><br><span class="line">         name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> a.<span class="title function_ invoke__">area</span>() != b.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">         <span class="built_in">panic!</span>(<span class="string">&quot;the area of a&#123;&#125; and b&#123;&#125; are not equal!&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样运行之前的命令，此时eq开头的测试用例都会被拉起：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::eq ... ok</span><br><span class="line">test tests::eq_fail - should panic ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- tests::eq stdout ----</span><br><span class="line"><span class="keyword">in</span> eq of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">---- tests::eq_fail stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::eq_fail&#x27; panicked at <span class="symbol">&#x27;the</span> area of a1000 and b2000 are not equal!&#x27;, src/lib.rs:<span class="number">54</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    tests::eq</span><br><span class="line">    tests::eq_fail</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">2</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">1</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h4 id="忽略某些用例"><a href="#忽略某些用例" class="headerlink" title="忽略某些用例"></a>忽略某些用例</h4><p>有些用例很特殊，比如可能某个版本会出错，此时我们需要暂时忽略这些用例，那么可以用ignore属性忽略掉，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore = <span class="string">&quot;no testing anymore&quot;</span>]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>此时即使使用cargo test也不会拉起large用例了。</p><h4 id="运行所有用例（包括已忽略的）"><a href="#运行所有用例（包括已忽略的）" class="headerlink" title="运行所有用例（包括已忽略的）"></a>运行所有用例（包括已忽略的）</h4><p>如果想运行所有用例即使是被 igore 的呢？那么一种方法当然是删掉 ignore 属性，一种是使用控制测试框架行为的参数，把被 ignored 的用例 include 进来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --include-ignored</span><br></pre></td></tr></table></figure><p>当然，如果只想运行被 ignored 的用例，那么就指定使用 ignored 用例即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --ignored</span><br></pre></td></tr></table></figure><h2 id="测试用例结构"><a href="#测试用例结构" class="headerlink" title="测试用例结构"></a>测试用例结构</h2><h3 id="测试代码与二进制文件"><a href="#测试代码与二进制文件" class="headerlink" title="测试代码与二进制文件"></a>测试代码与二进制文件</h3><p>当某个mod被声明test的时候，编译二进制文件讲不会包含测试代码，测试代码和生产用的代码是被分别编译成不同的产物的，这样即节省了编译时间，也减少了测试代码对生产代码的影响：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">cfg</span>(test)]</span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p>可以看到我们一直以来都是在测试非pub的函数，那么方法一样，我们测试的所有函数和方法都不是mod test里面的，也没有声明为pub，但实际我们一直在测试，所以Rust是允许 test 越过访问权限来测试的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::*;</span><br></pre></td></tr></table></figure><p>Test 框架中use supper也说明它引入了所有其它mod，无需担心是否有pub属性。</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>前面说的都是单元测试，所谓单元测试，即对某一个模块的某一个函数或者方法进行测试，而集成测试，则是对某一个模块所导出的接口进行测试，这个模块可能依赖多个其它模块。和单元测试不同，单元测试是和生产代码（放在src目录下）放在一起的，只是都集中放在mod tests里面，并标记 cfg(test)] ，集成测试则是放在和生产代码目录src同级目录下，名叫tests，这些名字都是固定的。cargo会根据目录名而知道，tests下放的每一个文件都是一个testing crate（Rust的基础模块单元）。集成测试不需要再把测试代码放进mod tests里面，只要保证在tests目录下即可。</p><p>例如我们把之前的RectangleArea的测试代码移动到tests目录下，最后目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rectangle</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── rectangle_area.rs</span><br><span class="line">└── tests</span><br><span class="line">    └── test_rectangle_area.rs</span><br></pre></td></tr></table></figure><p>其中lib.rs导出rectangle_area：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> rectangle_area;</span><br></pre></td></tr></table></figure><p> 而内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rectangle::rectangle_area::RectangcleArea;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_area_eq_large</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;a.area() = &#123;&#125; is not larger than b.area() = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，测试框架因为被移出src目录，需要使用use把rectangle目录引入，而且，由于不再是单元测试，如果是私有的字段或者方法，将需要声明为pub，否则tests是无法使用的。</p><p>运行cargo build将会编译库文件，运行cargo test将会执行tests目录下的测试模块，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test --test test_rectangle_area -- --nocapture</span><br></pre></td></tr></table></figure><p>即运行 test_rectangle_area.rs的测试用例，且打印print信息。如果不指定test_rectangle_area，那么tests中所有的测试用例都会被拉起执行，而且如果其中某一个失败，会中断所有的测试流程。</p><p>这里似乎不能像python test那样指定到某个函数进行测试，而且对于执行文件（main.rs）是不能使用测试框架的，因为Rust官方认为，执行文件的逻辑应该是很少的，大部分逻辑应该都在库文件中，执行文件只需要简单的运行起来就能测试了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的生命周期（lifetime）</title>
    <link href="https://www.jackhuang.cc/2023/01/19/rust-lifetime/"/>
    <id>https://www.jackhuang.cc/2023/01/19/rust-lifetime/</id>
    <published>2023-01-19T08:19:54.000Z</published>
    <updated>2023-02-05T02:50:48.809Z</updated>
    
    <content type="html"><![CDATA[<p>生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。</p><span id="more"></span><h2 id="生命周期是什么"><a href="#生命周期是什么" class="headerlink" title="生命周期是什么"></a>生命周期是什么</h2><p>生命周期（lifetime）是annotation，即一个标记。仅此而已。不管我们怎么做，生命周期就是一个标记，它没有改变任何东西，尤其不会改变对象的生命周期，尽管我们把它叫做生命周期。所以，遇到生命周期时，记住，它只是一个标记，相当于给编译器看的注释，用于给它提示对象的生命周期的。</p><h2 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h2><p>为什么我们要关注生命周期呢，看看下面这个例子，找出一句话的第一个单词：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(&amp;[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> words.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个find_first_word函数入参是一个引用，出参也是一个引用，这么做完全没问题，因为如果出参引用的是入参，那么出参的生命周期和入参一样，如果出参是内部new出来的，那么如果出现悬空指针，那么编译器是可以知道的，所以此时不需要生命周期标记。但如果有两个参数就不一样了，比如返回最长的那个字符串引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，find_longest函数可能返回s1也可能返回s2，那么其返回值的生命周期到底是s1还是s2呢？这个是要靠运行时才能知道的，由于不知道到底返回哪个，编译器自然也无法知道返回值的生命周期，那么无法编译使用这个函数的地方的代码，因为Rust必须在编译时就精确知道各个变量的生命周期，这样才能避免悬空指针，比如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    longest_string = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><p>显然，现在函数find_longest会返回s1，那么longest_string将会引用s1，但s1在离开大括号后就没有了，于是第 8 行的print代码显然在打印一个悬空指针。</p><p>如果没有生命周期标记，Rust编译器无法知道第 5 行longest_string拿到的返回值生命周期到底有多长，也就很难（实际上是可以发现的，可能未来会优化）发现悬空指针问题。</p><p>我们加上生命周期后如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和模板很像，首先在函数名的简括号里面生命一个生命周期，以 ‘ 开头，这个是生命周期语法的要求，后面的 a 则是一般约定俗成的写法，一般使用小写字母，短的单词表示某个某个生命周期，唯一比较特殊的是 ‘static 这个生命周期，这个放后面讲。</p><p>声明完生命周期后，后面引用的时候在&amp;符号后面加上这个’a就表示这个引用的生命周期是’a，那么上面的代码中，s1和s2以及返回值这三个引用的生命周期都是’a，即表示，他们这三个变量中，最小的生命周期必须覆盖其它两个变量的使用范围。</p><p>前一个例子中，s1的生命周期是最小的，它只能活在大括号内，而s2和longest_string在可以存活在大括号外面，所以，s1的生命周期最小，它必须覆盖完s2和longest_string的使用范围。但很明显，出了大括号后，我们访问了longest_string，此时s1已经被销毁，不满足上述要求，因此编译器报错。修复它当然很简单，延长s1的生命周期范围即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span> = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><h2 id="struct的生命周期"><a href="#struct的生命周期" class="headerlink" title="struct的生命周期"></a>struct的生命周期</h2><p>和函数一样，struct也有生命周期问题，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: &amp;<span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，name这个字段是个引用，那么为了避免有悬空指针出现，Person的对象的生命周期小于等于name引用的对象的生命周期，否则，如果Person的对象还存在，但name所引用的对象已经销毁，那么就会出现悬空指针了。于是为了说明这一点，我们加上生命周期标记，让编译器也让使用方知道，我们必须保证Person的对象生命周期小于等于name所引用的对象的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和函数类似，在Person后的尖括号内声明生命周期’a，name的引用符号&amp;后加上’a，这样就表示Person的对象和这个name字段引用的对象它们的生命周期必须保证Person对象能在name引用对象之前销毁。</p><p>那么，如果我们给这个Person加上方法，是否也需要跟着都加上生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是需要的，即使不管是入参还是返回值，都没有去碰name这个引用，返回值也不是引用，为什么需要加上’a声明呢？</p><p>因为Rust其实是把生命周期和泛型看成差不多一样的对待，大家也看到了，生命周期的声明和模板的声明一样，都在一个地方，他们都是在标记带有某个类型或者声明周期的struct，也就是说，既然我们声明了struct Person&lt;’a&gt;，那么Person&lt;‘a&gt;就是一个叫做“生命周期为’a的struct，struct名叫Person”的类型，那么，给这个类型添加方法，也需要带上’a，简单说也就是Person&lt;‘a&gt;是一个整体，就好像模板Person&lt;T&gt;一样。</p><p>那么返回name这个引用呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">    <span class="keyword">self</span>.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，依然顺利通过编译，但get_name如果改成可能某种情况下会返回pre或者self.name：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">     <span class="keyword">if</span> pre == <span class="string">&quot;hello&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> pre;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会报类似前面的错误了。这是为什么呢？这里就需要Rust的声明周期检查三个规则来解释了。</p><h2 id="生命周期的三个规则"><a href="#生命周期的三个规则" class="headerlink" title="生命周期的三个规则"></a>生命周期的三个规则</h2><p>Rust发现在函数（方法也类似）签名（即入参和出参）或者struct中发现有引用时，会使用这三个规则来检查我们是否需要增加生命周期，如果都通过，那么就不需要，如果有失败，则提示需要增加生命周期。</p><h3 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h3><p>编译器给函数的输入参数都加上自己的生命周期。</p><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器先自己尝试这个给它们都加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即s1和s2都有自己的生命周期 ‘a 和 ‘b。这一步一般不会有什么错误。</p><h3 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h3><p>编译器给函数的输出参数加上自己的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译器发现 ‘c 会出现问题，因为 ‘c这个生命周期 ‘a 和 ‘b 相关，那么，’c 应该选 ‘a 还是 ‘b 呢？似乎都不确定，这就需要写这段代码的人告诉编译起怎么选择。</p><p>因此编译器报错，提示我们请准确告诉它用哪一个生命周期。我们把s1和s2都写成同一个生命周期，这样就相当于告诉编译器，s1和s2在这个函数中有相同的生命周期，返回参数也可以用这个生命周期，问题得以解决：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以修改这个函数加深理解，忘记这个函数是做什么的，假如这个函数就是只返回s2，那么，哪怕我们把s1和s2都声明称不同的声明周期也没问题，因为编译起看到代码，发现函数只返回s2，所以返回值使用s2的即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写是没有问题的，因为返回值就只能是s2，那么返回参数的生命周期当然和s2是一样的。如果返回参数用的s1的生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译起报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |                 --  -- lifetime `<span class="symbol">&#x27;b</span>` defined here</span><br><span class="line">   |                 |</span><br><span class="line">   |                 lifetime `<span class="symbol">&#x27;a</span>` defined here</span><br><span class="line"><span class="number">23</span> |     <span class="keyword">return</span> s2;</span><br><span class="line">   |            ^^ function was supposed to <span class="keyword">return</span> data with lifetime `<span class="symbol">&#x27;a</span>` but it is returning data with lifetime `<span class="symbol">&#x27;b</span>`</span><br></pre></td></tr></table></figure><p>因为它们的生命周期不匹配。可见，生命周期是引用的一部分，这点类似于Class&lt;T&gt;不能赋值给Class&lt;F&gt; 一样，它们虽然名字都叫Class，但就是不一样的类型。</p><p>如果只有一个引用参数的话呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，编译起尝试给入参加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现返回值只能是s的生命周期，所以推理出返回值的生命周期为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译器不会发生之前那种歧义的地方，编译通过，我们不需要手工加上生命周期。</p><p>总之，规则二就是编译器主动自己给每一个引用入参加上生命周期的过程，只要它能推理出确定的返回值生命周期，编译就能顺利通过。经验上来讲，如果入参只有一个引用，编译器一般都能推理出返回参数的生命周期，但如果是多于一个引用参数，那么就需要我们给编译器提示了。</p><h3 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h3><p>这个规则是和方法相关的，如果是一个方法，那么除了规则二的应用，还会加上规则三，即，如果引用返回值的生命周期和引用self相关，那么它的生命周期就使用引用self的生命周期。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照规则二announce方法会出现错误，但规则三却可以弥补规则二的问题。即因为引用返回值的生命周期和引用self相关，所以他们的返回值是一样的，即确定的。但如果我们改成返回参数s，这个时候就需要我们加入生命周期标记了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static生命周期"><a href="#static生命周期" class="headerlink" title="static生命周期"></a>static生命周期</h2><p>之前讲的生命周期都是叫a，b或者c，可以说是起了一个短且小写的名字，一般是随意起的，约定俗成是短且小写即可，但有一个特殊的生命周期标记是保留的，即static，表示引用一个从程序执行开始到结束都存在的数据，实际上，static表示这个对象是已经被固化在二进制文件里面了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> =  <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>上面的代码中，”hello world!”这个字符串就是被编译器写入二进制可执行文件的常量区域中，它永远不会被销毁，一致都存在，这个时候就可以用static生命周期标记这种变量。</p><p>一般来说，如果在没有引入常量区的情况下编译器提示使用static引用，多少都说明在设计上可能出现了问题，此时不应该直接用static引用解决编译问题，而是看看哪里引用设计不合理。</p><h2 id="生命周期优化"><a href="#生命周期优化" class="headerlink" title="生命周期优化"></a>生命周期优化</h2><p>诚然在Rust文档中有提到过是否可以优化这些生命周期标记，但目前还是不可或缺，未来版本拭目以待吧。</p><h2 id="生命周期和模板混用"><a href="#生命周期和模板混用" class="headerlink" title="生命周期和模板混用"></a>生命周期和模板混用</h2><p>正如前所说，生命周期非常类似模板，它们可以混在一起用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    age: F </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; Person&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的限制是生命周期的声明必须放在模板之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生命周期是帮助Rust编译器（其实也是帮助程序员）确定引用返回值的生命周期，或者保证struct结构的引用字段中不会出现悬空指针问题。但需要注意的是，生命周期并不改变变量的生命，他只是一种标记，表示某个引用的生命周期相对其它引用的生命周期关系，即生命周期是仅仅只是标记，且有相对性，单个生命周期标记是没有意义的。</p><p>我们可以用前面介绍的三个推理规则来判断如何帮助编译器确认生命周期。</p><p>生命周期和模板非常类似，它们都是类型属性之一，如果因为帮助编译起确定生命周期而进行了生命周期声明，那么它就是类型的一部分，外后增加方法的时候不能省略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
</feed>
