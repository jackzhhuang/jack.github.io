<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Huang的技术生活</title>
  
  <subtitle>一些关于技术的思考，想法和积累</subtitle>
  <link href="https://www.jackhuang.cc/atom.xml" rel="self"/>
  
  <link href="https://www.jackhuang.cc/"/>
  <updated>2023-01-17T05:11:31.555Z</updated>
  <id>https://www.jackhuang.cc/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust的错误处理</title>
    <link href="https://www.jackhuang.cc/2023/01/16/rust-err/"/>
    <id>https://www.jackhuang.cc/2023/01/16/rust-err/</id>
    <published>2023-01-16T05:07:36.000Z</published>
    <updated>2023-01-17T05:11:31.555Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的错误处理主要有以下4点需要学习：</p><p>1、使用panic!宏；</p><p>2、使用Result&lt;T, E&gt;;</p><p>3、使用Optional&lt;T&gt;</p><p>4、使用 ? 符号简化错误处理的代码，这一点非常赞。</p><p>现在就看看我们Rust的错误处理具体细节吧。</p><span id="more"></span><!-- toc --><ul><li><a href="#1-panic%E5%AE%8F">1. panic!宏</a></li><li><a href="#2-%E4%BD%BF%E7%94%A8resultt-e">2. 使用Result&lt;T, E&gt;</a></li><li><a href="#3-%E7%94%A8expect%E4%BB%A3%E6%9B%BFpanic%E5%AE%8F">3. 用expect代替panic!宏</a></li><li><a href="#4-%E7%94%A8-%E6%9D%A5%E7%AE%80%E5%8C%96%E8%BF%94%E5%9B%9E%E7%9A%84%E9%94%99%E8%AF%AF%E5%80%BC%E5%A4%84%E7%90%86">4. 用 ? 来简化返回的错误值处理</a></li><li><a href="#5-%E8%BF%94%E5%9B%9E%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%99%E8%AF%AF">5. 返回其它类型的错误</a></li><li><a href="#6-%E4%BD%BF%E7%94%A8optionalt%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9">6. 使用Optional&lt;T&gt;也是一种选择</a></li><li><a href="#7-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99panic%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81">7. 什么时候panic什么时候返回错误码</a></li></ul><!-- tocstop --><h2><span id="1-panic宏">1. panic!宏</span></h2><p>这个是最简单也是最暴力的错误解决处理方案，即直接中断程序运行，并且报告程序错误。如果程序无法继续往下执行，那么，尽早中断也是不错的选择，关键是，如果配合环境变量RUST_BACKTRACE&#x3D;1的话，还可以打印从panic的地方开始的调用栈，方便快速定位问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;the denominator should not be 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s * t = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">divide</span>(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行的时候加上环境变量RUST_BACKTRACE&#x3D;1，则可以在检查分母的失败时打印出调用栈：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;the</span> denominator should not be <span class="number">0</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: _rust_begin_unwind</span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">   <span class="number">2</span>: greeting::divide</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">3</span>: greeting::main</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">12</span>:<span class="number">28</span></span><br><span class="line">   <span class="number">4</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /private/tmp/rust-<span class="number">20220812</span>-<span class="number">6466</span>-<span class="number">1</span>atesch/rustc-<span class="number">1.63</span>.<span class="number">0</span>-src/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure><h2><span id="2-使用resultltt-egt">2. 使用Result&lt;T, E&gt;</span></h2><p>大部分错误都是可以容忍的，或者说我们可以继续保持程序继续运行，同时给用户一个友好提示，所以给一个恰当的提示是大多数场景。这个时候我们一般使用Result&lt;T, E&gt;。这是一个很简单但非常有用且常用的枚举类型，其源代码为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="comment">/// Contains the success value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Ok&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Contains the error value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Err&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即Ok和Err两个枚举类型，很多标准函数都会用它来表示是否执行成功，例如，我们现在写一个程序，打开一个文件，如果该文件不存在，则创建它，否则就往文件里面写hello world：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fs::File, io::Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">open_or_create_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_handle_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> file_handle_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">            file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_file_hanle_result</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">match</span> new_file_hanle_result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">                    file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;failed to create rust_test.txt, since: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_or_create_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒写了很多，其实就是做了一个简单的逻辑，即先打开文件，存在则写入，不存在则创建，创建成功后写入，创建失败则panic。这个算是比较基本的Result&lt;T, E&gt;使用了。但显然，Rust不会让我们写这么多 match 或者 if 去做判断Result&lt;T, E&gt;结果的，下面就看看Rust是怎么把这段代码简化的。</p><h2><span id="3-用expect代替panic宏">3. 用expect代替panic!宏</span></h2><p>如果我们只是想遇到错误就直接panic，那么expect可以帮助我们少写一次 match 或则 if ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_handle</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nofile.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;cannot open the file&quot;</span>);</span><br><span class="line">file_handle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;cannot</span> open the file: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">35</span>:<span class="number">52</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可以看到，我们并不需要去判断open() 方法的返回值Result&lt;T, E&gt;，它的expect()  方法帮我们做了判断，如果是失败，那么就panic，如果是成功，则unwrap给我们句柄。</p><p>如果文件存在，那么expect直接返回句柄，那么后面的写入内容就可以顺利执行。</p><h2><span id="4-用-来简化返回的错误值处理">4. 用 ? 来简化返回的错误值处理</span></h2><p>Rust提供了了 ? 号来帮助我们简化这种常见的Result&lt;T, E&gt;判断。? 其实就是一段简单的逻辑，即，如果返回的是Err那么就直接返回，如果是Ok则继续往下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_write</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="title function_ invoke__">create_write</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 ? 号后，简化了我们对Result&lt;T, E&gt;的判断处理，代码更简洁了。上面的代码中，open() 方法返回了Result&lt;T, E&gt;，? 会处理成功与失败的情况，若成功，则展开Ok(T)，也即获得文件对象句柄，进而调用write_all() 方法写入数据，若失败，则提前返回。</p><p>这里需要注意的是，open_write() 和 create_write() 返回值必须和里面的代码匹配，即成功返回的是Ok(())，失败则返回的是File::open() 或File::create() 的失败返回值Err(E)，此处E是std::io::Error。</p><h2><span id="5-返回其它类型的错误">5. 返回其它类型的错误</span></h2><p>上面可以看到，我们返回的错误Err&lt;E&gt;中，类型都是一致的，也即std::io::Error ，但如果我们不想返回这个类型的错误的话呢？这个时候会发生错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_check</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_hanle</span> = File::<span class="title function_ invoke__">open</span>(file_name)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file_hanle.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content);</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">&quot;hello world!&quot;</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">open_check</span>(<span class="string">&quot;nofile.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">18</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">18</span> |         <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">   |         --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected <span class="keyword">struct</span> `std::io::Error`, found <span class="keyword">struct</span> `<span class="type">String</span>`</span><br><span class="line">   |         |</span><br><span class="line">   |         arguments to this <span class="keyword">enum</span> <span class="title class_">variant</span> are incorrect</span><br><span class="line">   |</span><br></pre></td></tr></table></figure><p>因为函数签名上期待的错误枚举，绑定的类型是std::io::Error，但这里返回了String。解决方法是后面学到的trait和面向对象设计。后面再提。</p><h2><span id="6-使用optionallttgt也是一种选择">6. 使用Optional&lt;T&gt;也是一种选择</span></h2><p>Optional&lt;T&gt;也可以像Result&lt;T, E&gt;那样用，如果是None那么就直接返回，否则就继续处理，比如前面的HashMap，我们get一个key，若存在，则乘以二返回，否则就返回None：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">multiple_2</span>(h: &amp;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;, key: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(h.<span class="title function_ invoke__">get</span>(key)? * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">2</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;rust&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">4</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;rose&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果通过get() 方法访问一个HashMap存在的key，那么 ? 会展开Some(&amp;i32)得到i32的对象的引用，并且和2相乘。如果不存在，则get() 方法返回None，函数提前返回，这段代码的输出是：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the result is <span class="title function_ invoke__">Some</span>(<span class="number">12</span>)</span><br><span class="line">the result is <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2><span id="7-什么时候panic什么时候返回错误码">7. 什么时候panic什么时候返回错误码</span></h2><p>那么什么时候panic什么时候返回错误枚举呢？个人觉得这个问题还是比较显而易见的，从后端服务器设计角度来讲，进程退出是难以维护的不够健壮的提现，好的后端服务，应该能经受得住各种输入数据而屹立不倒，如果随随便便就退出以示对错误的一种反应，则容易被恶意客户端所利用，造成拒绝服务攻击。</p><p>也有人认为，出了错就尽快退出，这样可以及时发现错误，这个愿望是很好的，在程序调试阶段我们可以这么干，的确有利于调试，但放到线上，就需要深思熟虑了。</p><p>折衷方案是，对于后端服务初始化阶段，我们可以对关键信息做panic，运行时，对损害健壮性的请求进行提前拦截并提示错误。业务流程错误则当然使用错误信息。</p><p>再进一步说，对于出错，我们其实不能仅仅只是靠panic或者返回错误信息，需要更系统的去考虑问题，比如系统的吞吐（延迟），成功量（率），失败量（率），请求量，不同水平的告警，等等各种多维度的去监控才能准确的知道一个系统的健康与否。这里只是Rust语言学习，不展开说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的错误处理主要有以下4点需要学习：&lt;/p&gt;
&lt;p&gt;1、使用panic!宏；&lt;/p&gt;
&lt;p&gt;2、使用Result&amp;lt;T, E&amp;gt;;&lt;/p&gt;
&lt;p&gt;3、使用Optional&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;p&gt;4、使用 ? 符号简化错误处理的代码，这一点非常赞。&lt;/p&gt;
&lt;p&gt;现在就看看我们Rust的错误处理具体细节吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的容器</title>
    <link href="https://www.jackhuang.cc/2023/01/12/collection/"/>
    <id>https://www.jackhuang.cc/2023/01/12/collection/</id>
    <published>2023-01-12T14:42:05.000Z</published>
    <updated>2023-01-15T16:15:59.363Z</updated>
    
    <content type="html"><![CDATA[<p>今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：</p><p>1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）</p><p>2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）</p><p>3、其它各种先决条件。</p><p>总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。</p><p>现在我们就从最常用的容器开始吧。</p><span id="more"></span><!-- toc --><ul><li><a href="#1-%E6%95%B0%E7%BB%84vec">1. 数组Vec</a><ul><li><a href="#11-%E9%AB%98%E6%95%88%E5%88%9D%E5%A7%8B%E5%8C%96">1.1 高效初始化</a></li><li><a href="#12-%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE">1.2 顺序访问</a></li><li><a href="#13-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE">1.3 索引访问</a></li><li><a href="#14-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">1.4 插入操作</a><ul><li><a href="#141-insert%E6%96%B9%E6%B3%95">1.4.1 insert()方法</a></li></ul></li><li><a href="#15-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">1.5 删除操作</a><ul><li><a href="#151-pop%E6%96%B9%E6%B3%95">1.5.1 pop()方法</a></li><li><a href="#152-swap_remove-%E6%96%B9%E6%B3%95">1.5.2 swap_remove () 方法</a></li></ul></li><li><a href="#16-vec%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6">1.6 Vec内部结构探究</a></li></ul></li><li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2string">2. 字符串String</a><ul><li><a href="#21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5">2.1 字符串的连接</a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82">2.2 字符串和字节</a></li><li><a href="#23-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAstring">2.3 比较两个String</a></li><li><a href="#24-rust%E7%9A%84string%E4%B8%8D%E7%AE%80%E5%8D%95">2.4 Rust的String不简单</a></li></ul></li><li><a href="#3-%E5%93%88%E5%B8%8Chashmap">3. 哈希HashMap</a><ul><li><a href="#31-%E6%8F%92%E5%85%A5">3.1 插入</a></li><li><a href="#32-%E6%9F%A5%E6%89%BE">3.2 查找</a></li><li><a href="#33-%E6%9B%B4%E6%96%B0">3.3 更新</a></li></ul></li></ul><!-- tocstop --><h2><span id="1-数组vec">1. 数组Vec</span></h2><p>数组Vec是最常用的容器，它非常类似C++的std::vector，底层数据结构也是一块连续的内存，内存不足时，会扩大，并把老数据拷贝到新内存上，因此，非常适合顺序访问和索引访问，非常不适合有删除和插入的场景，因为此时暗含着内存移动的低效操作。</p><h3><span id="11-高效初始化">1.1 高效初始化</span></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用了最常用的初始化方法，array1是vec!宏来初始化，array2是直接用Vec::new()来初始化，可以看到我们在定义array2的时候并没有去告诉array2将会放上面类型，直到第6行push第一个String对象的时候才告诉编译器，我们要放的对象是String。Vec只能是单一对象。第6行决定了array2必须放String对象。</p><p>前面说了，Vec是会因为自身分配的内存空间不足时，增长内存的，因此会有数据移动的低效操作，array2的初始化就是这样，如果我们能事先告诉array2要存放什么类型，已经即将存放的数量，那么Vec就可以事先分配好空间，保证我们后续放入数据时不会有数据移动操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">array2.<span class="title function_ invoke__">reserve</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>上面的reserver方法就是告诉array2实现分配至少3个String对象空间，好让后续的3个push方法调用不产生数据移动操作。</p><p>如果事先知道需要分配数组的元素数量，且它们的值都是同一个，那么，更高效的方法是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = <span class="built_in">vec!</span>[<span class="number">100</span>; <span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array3 = &#123;:?&#125;&quot;</span>, array3);</span><br></pre></td></tr></table></figure><p>上面的[100; 5]就表示，分配长度为5个元素，且每个值都是100的数组，这就比前面使用reserver更高效。</p><p>还有with_capacity()方法，可以把Vec::new()和reserve()方法都合成一个，例如array2的初始化可以改成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>总之，如果我们实现就能知道有多少元素即将push进Vec里面的话，我们就尽量的把内存分配好，避免数据移动操作。</p><h3><span id="12-顺序访问">1.2 顺序访问</span></h3><p>Vec是最适合顺序访问的了，我们可以一个个枚举Vec里面的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> &amp;array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，访问array2时我们用了引用，这样访问里面的String对象时，也都变成了引用，这个规则struct也是这样。因为用了引用，后续array2还是有效的指针。</p><h3><span id="13-索引访问">1.3 索引访问</span></h3><p>索引访问也是我们常用的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[2] = &#123;&#125;&quot;</span>, array2[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>这当然会打印“hello jack”，但如果访问一个不存在的索引呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[6] = &#123;&#125;&quot;</span>, array2[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure><p>此时会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">6</span>&#x27;, src/main.rs:<span class="number">14</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>还需要非常注意的是，之前也提到过，Vec不允许自己的元素被转移走，即以下代码将编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">take</span> = array2[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>因为首先Rust不允许悬空指针的存在，其次如果Vec去维护中间哪一个元素处于悬空指针又实在不合常理，毕竟Vec就是Vec，即向量，向量不应该感知这些东西。因此如果有人打算通过索引访问去取走Vec的资源，那么就会被编译器报错。</p><h3><span id="14-插入操作">1.4 插入操作</span></h3><h4><span id="141-insert方法">1.4.1 insert()方法</span></h4><p>相对于push操作，每一次的insert() 的操作就需要大量移动移动数据了，push只有超过capacity的时候才会产生数据转移，而insert每一次都要把需要插入的位置的后面元素往后挪动一个位置，空出来后给新元素放入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>如果插入操作真的需要很频繁，那么就应该用 LinkedList&lt;T&gt;。</p><h3><span id="15-删除操作">1.5 删除操作</span></h3><h4><span id="151-pop方法">1.5.1 pop()方法</span></h4><p>如果想删去Vec的元素，推荐用的是pop()方法，但注意pop() 方法只能从Vec的最后一个元素开始删除，毕竟前面也说了，试图从中间开始插入或删除一个Vec会引起数据移动操作，这是非常低效的。</p><p>例如我们pop出最后一个元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>可以看到，pop()参数返回的是一个Option&lt;T&gt;，也就是如果array2是空的，那么就会返回None。这里返回的是Some(String)类型。pop之后，array2就只有两个元素在里面了。</p><p>但要注意，如果用for in的方式访问array2且没有使用引用的话，还是会把里面的资源转移走的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure><p>以上代码编译不通过，因为第1行for in语句中，s会逐次获得array2的资源，第4行再去访问array2的资源会编译失败。</p><h4><span id="152-swap_remove-方法">1.5.2 swap_remove () 方法</span></h4><p>如果真的需要删掉其中某一个元素，那么可以使用swap_remove()。它的入参是一个index，即需要删掉的元素的索引。为了避免数据移动，Vec的删除策略是这样的：把最后一个元素的值和需要删掉的index交换，并把Vec的长度减1:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before swap_remove, array1 = [<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line">after swap_remove, array1 = [<span class="number">192</span>, <span class="number">3</span>, <span class="number">231</span>, -<span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>可以看到，我们打算删掉31，于是传入它的index&#x3D;1，Vec把末尾的3交换到31上，然后长度减1。同时，swap_remove还会把31返回出来，虽然这里程序没有提现。</p><h3><span id="16-vec内部结构探究">1.6 Vec内部结构探究</span></h3><p>Vec实际上内部是封装了一个tuple结构，tuple中第一个是指针，指向T资源，第二个是长度len，第三个是容量capacity。Vec保证当容量不足时就会自动懂扩容，因此自动扩容的出现点出现在所需内存大于capacity时。把上面的array2结构画出来，会是这样：</p><p><img src="https://www.jackhuang.cc/svg/Vec.svg" alt="Vec内部"></p><p>可以看到，上图蓝色的三个元素就是Vec内部主要封装的三个熟悉，用tuple表示为 (p, 3, 6) ，即p表示指向一组连续的内存，放String数组，3则是数组的元素个数，6则表示array2的容量，表示还可以再存放6 - 3 &#x3D; 3个String对象，且保证在此之前不会触发数据移动操作。</p><p>String数组后面的灰色部分是未初始化区域，也就是6 -3 &#x3D; 3这个部分。关于未初始化区域，可以详细看这里：<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</a> 。</p><h2><span id="2-字符串string">2. 字符串String</span></h2><h3><span id="21-字符串的连接">2.1 字符串的连接</span></h3><p>两个字符串连接是最常见的编程场景，最显而易见的就是使用String的push_str和push两个方法，前者入参是一个字符串，后者入参是一个字符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;，&#x27;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>另外一个方法，就是直接用 + 号来实现字符串的拼接，需要注意的是，+ 号方法，使用的是self而不是&amp;self，也就是说，会有所有权转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure><p>还有需要注意的是，s这个参数是&amp;str，也就是它接受一个引用，也就是被加的字符串不会有所有权转移，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;，&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br></pre></td></tr></table></figure><p>上面的代码中，s1 + &amp;s2 + &amp;s3会使得s1丢失所有权，所幸又还给了s1。这里Rust之所以这么干，其实是避免了拷贝，其内部只是通过引用拿到s2和s3的内容，拷贝到s1的后面，避免了拷贝一块新的区域来存放s1。</p><h3><span id="22-字符串和字节">2.2 字符串和字节</span></h3><p>String是和Vec类似的，内部结构也是一个tuple，同样放着p指向字符串，另外两个是字符串的长度和容量。这里不展开讲太多String的功能方法，稍有编程经验的人都应该知道String会提供哪些典型的方法，具体可以参考官方文档。</p><p>和其它语言不同，需要特别注意的是，Rust的String对象是一个UTF8格式的，这就意味着一个问题，就是如果我们索引访问一个String对象，会是返回什么？</p><p>如果String内容是“hello world!”，那么[0]是否应该是h，如果是h，那么它的大小就是一个字节。</p><p>如果String内容是“你好，世界！”，那么[0]是否应该是“你”，如果是“你”，那么它的大小就是三个字节。</p><p>那么到底索引访问一个String要返回多少个字节呢？Rust觉得这是一个模糊的问题，于是拒绝编译这种代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br><span class="line">  |             ^^^^ `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br></pre></td></tr></table></figure><p>Rust 需要使用方明确知道自己在干什么，是要返回一个字符，还是要返回某个字节，所以，如果想拿到某个字符，就明确的告诉String，我要以字符方式访问你：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>chars() 方法返回一个迭代器，即我们熟悉的iterator，可以看到做为迭代器，它是有状态的，即封装了一个当前所处位置的指针，因此需要加上mut，这样后面的nth() 方法才可以得以调用，因为nth() 方法会把当前位置往前移动，这相当于修改了状态。</p><p>nth返回Option&lt;Char&gt;，调用unrawp() 方法可以拿到里面的字符。</p><p>我们当然也可以用字节访问String对象，但这样，打印出来的就不是字符形式了，而是字节数字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = s.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>输入出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">189</span></span><br><span class="line">s = <span class="string">&quot;你好，世界！&quot;</span></span><br></pre></td></tr></table></figure><p>189其实是“你”这个字符的第二个字节数。</p><h3><span id="23-比较两个string">2.3 比较两个String</span></h3><p>Rust在这方面要求就比较简单，只需要 &#x3D;&#x3D; 去比较就好了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好世界!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;你好世界!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are same!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are different!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">they are same!</span><br></pre></td></tr></table></figure><p>虽然s1是String对象，s2是原生字符串，s1是对象的指针，s2是一个引用，但Rust还是会去判断这两个字符串是否内容相等。</p><h3><span id="24-rust的string不简单">2.4 Rust的String不简单</span></h3><p>Rust的String并不简单，这里只是主要提了最重要的一点，即String需要我们时刻知道我们到底是造操作字符还是字节，未来遇到String的使用，还是需要多翻阅文档，这里就不去一句句翻译文档内容了。</p><h2><span id="3-哈希hashmap">3. 哈希HashMap</span></h2><p>hash也是日常中最常用的数据结构，Rust的HashMap使用了SpiHash算法，避免了哈希碰撞的攻击，详见：<a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> 。当然，其效率就有所下降。</p><p>这里主要讲的是我们常使用的方法，第一个当然是插入了。</p><h3><span id="31-插入">3.1 插入</span></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1 = &#123;:#?&#125;&quot;</span>, h1);</span><br></pre></td></tr></table></figure><p>可以看到，首先HashMap和Vec不一样，需要我们显式引入，其次，它的key和value类型可以在insert的时候指定，当然一旦指定好类型，之后都不允许更改了。</p><p>注意，由于我们没有使用引用，因此，一旦对象呗插入到HaspMap中，HashMap就有了对象的所有权，如果使用引用，那么我们就必须保证所插入的数据的生命周期大于HashMap对象的生命周期，这在后一节讲到。</p><h3><span id="32-查找">3.2 查找</span></h3><p>使用get方法可以获得一个Optional&lt;T&gt;，如果不存在，返回None，否则返回Somel&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这里调用了copied方法，因为返回的是Optional&lt;&amp;i32&gt;，最后调用unwrap_or() 方法，并且提供了若是None，则返回0。</p><p>这里的错误处理下一节会专门讲到。</p><p>当然除了用ge() t方法，还是使用for语句去遍历所有的HashMap数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> h1 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="33-更新">3.3 更新</span></h3><p>如果我们在插入同样的key会发生什么呢？比如再插入一条key为”hello rust!”，value为80的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可以看到，原来的20被80给覆盖了，因此，插入同样的key会产生覆盖结果。</p><p>但如果我们并不想去覆盖，如果已经存在就不要去动它了，怎么办呢？此时应该调用Entry() 方法，Entry() 方法返回一个枚举，如果有值，则返回那条记录的引用，否则返回新的记录的引用，新记录的枚举中，调用它的or_insert() 方法就可以插入新值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>此时输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>20没有再被80覆盖。</p><p>如果我们要针对老值来更新新值呢？比如统计“how many word in this word ?” ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;how many word in this word ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">key</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">count</span> = h.<span class="title function_ invoke__">entry</span>(key).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">     *count += <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:#?&#125;&quot;</span>, h);</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h = &#123;</span><br><span class="line">    <span class="string">&quot;in&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;this&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;how&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;?&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;many&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;word&quot;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到由于word这个词已经存在，所以，第二次调用的时候，entry()  方法返回了老的记录的音乐，此时若调用or_insert()  方法并不会更新，并且返回value的引用，后面的*count +&#x3D; 1对word这个词进行了 + 1 统计。</p><p>以上就是我们常用的HashMap方法，当然，还是那句话，我们使用容器的时候应该多考虑开篇说的两个问题，即什么场景使用，会怎么使用，并且应该常翻阅文档，在里面看看有没有合适的方法供我们选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：&lt;/p&gt;
&lt;p&gt;1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）&lt;/p&gt;
&lt;p&gt;2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）&lt;/p&gt;
&lt;p&gt;3、其它各种先决条件。&lt;/p&gt;
&lt;p&gt;总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。&lt;/p&gt;
&lt;p&gt;现在我们就从最常用的容器开始吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的模块化管理</title>
    <link href="https://www.jackhuang.cc/2023/01/10/mod-and-crate/"/>
    <id>https://www.jackhuang.cc/2023/01/10/mod-and-crate/</id>
    <published>2023-01-10T15:18:55.000Z</published>
    <updated>2023-01-12T05:15:22.663Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。</p><span id="more"></span><!-- toc --><ul><li><a href="#1-%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%85%E6%BC%94%E5%8C%96%E8%AF%B4%E8%B5%B7">1. 从最简单的包演化说起</a><ul><li><a href="#11-%E7%AC%AC%E4%B8%80%E4%B8%AAmod">1.1 第一个mod</a></li><li><a href="#12-%E6%8A%8Amod%E6%94%BE%E5%88%B0%E5%88%AB%E7%9A%84%E6%96%87%E4%BB%B6">1.2 把mod放到别的文件</a></li><li><a href="#13-%E6%8A%8Amod%E6%94%BE%E5%88%B0%E5%88%AB%E7%9A%84%E7%9B%AE%E5%BD%95">1.3 把mod放到别的目录</a></li></ul></li><li><a href="#2-%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B7%AF%E5%BE%84">2. 模块的路径</a><ul><li><a href="#21-%E6%A0%B9%E7%9B%AE%E5%BD%95-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">2.1 根目录、绝对路径和相对路径</a></li><li><a href="#22-%E4%BD%BF%E7%94%A8use">2.2 使用use</a></li><li><a href="#23-%E4%BD%BF%E7%94%A8pub-use%E5%92%8Cas">2.3 使用pub use和as</a></li><li><a href="#24-%E4%BD%BF%E7%94%A8super">2.4 使用super</a></li></ul></li><li><a href="#25-pub-struct%E5%92%8Cpub-enum">2.5 pub struct和pub enum</a></li><li><a href="#3-%E5%90%8C%E6%97%B6%E5%BC%95%E5%85%A5%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97">3. 同时引入多个模块</a></li><li><a href="#4-%E6%80%BB%E7%BB%93">4. 总结</a></li></ul><!-- tocstop --><h2><span id="1-从最简单的包演化说起">1. 从最简单的包演化说起</span></h2><p>任何项目都不可能一个main文件写到底，我们总是要分成几个文件，甚至还要给文件放进不同目录，甚至会事先编译一些文件来管理项目文件。为了学习Rust的相关概念，我们从最简单的一个文件说起，慢慢把它演化成我们常见的项目管理方式，首先来个最简单的main.rs：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个main.rs文件没有任何模块化管理的概念，Person结构体直接就能用。</p><h3><span id="11-第一个mod">1.1 第一个mod</span></h3><p>现在我们把它放到一个module里面吧：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们第一个module了，这里的module很像C++的名字空间（但也不完全是），因此，想使用Person就必须加上PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜这样是编译不通过的，因为任何一个mod里面的东西（也就是module），包括struct，字段，方法，函数甚至子mod都统统是私有的，想对mod外面暴露，就必须定义为pub，因此，我们给Person等名前都加上pub，意味共有的，可以个mod的外部使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候Person以及他的字段都变成pub了，外部可以使用了。代码可以通过编译。</p><p>可见，一个mod关键字，可以声明一个module。</p><h3><span id="12-把mod放到别的文件">1.2 把mod放到别的文件</span></h3><p>以上代码我们都是在main.rs文件里面写的，显然我们应该独立出来，假设独立出来的文件名就叫PersonData.rs，那么我们不需要在文件中声明mod PersonData了（如果声明了mod PersonData，那么就是PersonData的子包也叫PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，main.rs的改动就是mod一下这个文件名，从而引入Person结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它地方并没有什么改变。</p><p>可见，一个rs文件，可以被当作一个module。</p><h3><span id="13-把mod放到别的目录">1.3 把mod放到别的目录</span></h3><p>如果文件PersonData.rs放到别的文件夹呢？假设我们把PersonData.rs移动到DataSet目录里面，那么，此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>此时，main.rs怎么找到PersonData这个模块呢？</p><p>有两种方法：</p><p>1、和main.rs同目录建一个DataSet同名的rs文件，在里面pub mod PersonData，pub表示这个DataSet包要公开PersonData这个module了。</p><p>DataSet.rs内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br></pre></td></tr></table></figure><p>此时，目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">├── DataSet.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>而main.rs中，mod DataSet（此时不需要pub mod，因为和main.rs是同一个文件，表示引入DataSet），且由于Person被放到了DataSet目录的PersonDate.rs文件中，因此需要修改一下访问它的路径了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，如果一个目录想变成module，就必须在目录同一级目录中，创建一个相同名字的rs文件，并通过它来里面的pub语句来决定公开目录中哪个module。</p><p>第二种方法，我个人认为更简便，即在目录中创建mod.rs，里面干和上面DataSet.rs同样的事情，即决定对外公开目录中哪个module。</p><p>此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>其中，mod.rs的内容和之前第一种方法的DataSet.rs内容一样。这两个方法都是等效的。</p><p>可见，目录想变成module，还可以在目录中创建mod.rs文件来达到这个目的。</p><h2><span id="2-模块的路径">2.  模块的路径</span></h2><h3><span id="21-根目录-绝对路径和相对路径">2.1 根目录、绝对路径和相对路径</span></h3><p>前面我们演化并展示了，一个struct类型如何变成不同位置的mod，以及我们的main.rs如何引用它。那么，Rust这些模块路径是通过什么原则去寻找的呢？</p><p>回顾一下，我们新建一个Rust工程的时候使用的是cargo new命令，例如，cargo new greeting，即创建了名为greeting的工程，进入greeting目录，tree命令可以看到创建的工程结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── DataSet</span><br><span class="line">│   │   ├── PersonData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   └── main.rs</span><br></pre></td></tr></table></figure><p>其中src是自动生成的，main.rs是自动生成的，而 DateSet目录是后来添加的。</p><p>Cargo.toml则是工程描述文件，包含版本，工程名已经工程的外部依赖项。</p><p>需要编译编译的时候，在greeting目录中，执行cargo build就可以生成二进制文件。如果想生成库文件，则需要加上–lib命令选项，且不需要写main函数。</p><p>这里主要讲的是，在用cargo new生成工程的时候，src目录即为改工程的根目录。在使用mod关键字去引入工程时，会以src为起点作为根目录，去寻找引用的模块。根目录其实可以用crate来代替，例如上面对Person的访问可以写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了从根目录找，当然还会找同文件的mod模块，即本文一开始写的第一个mod，它写在main.rs文件中。</p><p>还有一个寻找路径就是相对路径，即如果在子目录，那么，也会从子目录开始寻找引用的模块。例如我们新增一个House模块在DataSet目录下，并在Hous模块中添加HoseData.rs文件，文件内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的根目录开始的tree命令输出是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── House</span><br><span class="line">│   │   ├── HouseData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>那么如果我们在DataSet模块输出House模块路径是怎么样的呢？直接以DataSet目录为起点（即相对路径）输入出House模块即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br></pre></td></tr></table></figure><p> 这样DataeSet模块就可以对外输出House模块了。当然House模块也需要对外输出它的HouseData模块，即House目录下的mod.rs文件需要：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> HouseData;</span><br></pre></td></tr></table></figure><p>因为任何模块里面的东西都是私有的，需要显示的说它是pub的才行。</p><p>此时我们在main.rs中就能直接访问House模块了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，Rust的寻找路径可以这样：</p><p>1、从根目录开始寻找；</p><p>2、从相对路径开始寻找</p><p>3、从当前兄弟模块开始寻找。</p><p>根目录即src目录，在代码中可以省略或者以crate开头。</p><h3><span id="22-使用use">2.2 使用use</span></h3><p>但如此长的名字确实不好打，Rust给我们提供了一个关键字use，我们只写一次就可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>这样，我们的h指针在初始化的时候就不需要写这么多层级了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="23-使用pub-use和as">2.3 使用pub use和as</span></h3><p>设想如果DataSet有更多更深的模块的话，我们的每次使用这些又深名字又长的模块都要写一次use，实在太麻烦，此时我们可以在DataSet里面使用pub use来直接吧HouseInfo导出去：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>用了上面第三行的pub use，HouseInfo就如同DataSet的一个struct一样被导到外面去了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> DataSet::HouseInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用，不管子模块有多深，只要使用一次pub use，后续都不需要重新use一遍长路径。</p><p>在使用use的时候还可以给导出的struct或者模块起个新名字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::HouseInfo <span class="keyword">as</span> DHI;</span><br></pre></td></tr></table></figure><p>  此时，使用HouseInfo的时候我们可以用DHI代替了。</p><h3><span id="24-使用super">2.4 使用super</span></h3><p>和crate不同，crate是表示根目录，而super则表示当前目录的上一级目录。</p><p>例如我们在House中想使用PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::super::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里用了两个super，从之前的tree看到，第一个super是PersonData.rs的父目录House，第二个super就是House的父目录DataSet，而PersonData.rs就在DataSet下。我们当然也可以用crate目录（也即根节点去引用PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::DataSet::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="25-pub-struct和pub-enum">2.5 pub struct和pub enum</span></h2><p>最后要提的是，pub struct和pub enum不同点：</p><p>pub struct只是把struct导出，它的字段，方法还需要再pub来确定是否导出。而enum一旦pub了，它的字段都会变成共有的，都会被导出。</p><h2><span id="3-同时引入多个模块">3. 同时引入多个模块</span></h2><p>如果需要引入一个模块中多个struct或者其它什么的，可以用大括号来在一行中表示，例如，我们既需要Person也需要HouseInfo，除了写两行use外，还可以这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br><span class="line"><span class="keyword">use</span> DataSet::PersonData::Person;</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::&#123;House::HouseData::HouseInfo, PersonData::Person&#125;;</span><br></pre></td></tr></table></figure><p> 甚至一个*号来表示所有的可以导出的DataSet的东西：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::*;</span><br></pre></td></tr></table></figure><p> 但星号还是谨慎使用，因为比较随意，可能不经意引起名字冲突。</p><h2><span id="4-总结">4. 总结</span></h2><p>这一节从main.rs分裂出一个子模块，并把它放到一个目录中，再新建一个子模块到子子目录中，并通过使用mod（引入一个模块），pub（声明struct，方法，字段，enum为公有，或者用来导出struct，函数或者enum）来控制访问模块。</p><p>使用use来引入复杂的层级，使用pub use来导出一个复杂的层级，还可以使用as来给导出或者引入的模块或者类型定义一个新名字。</p><p>再简化总结一下：</p><p>一个crate可以有多个模块，crate的根在src目录。</p><p>使用方：用mod+use来引入模块，mod引入顶层模块，use引入模块中更复杂的层级结构。如果是引入父级目录，则不需要mod，直接use即可。</p><p>导出方：用pub导出字段，struct，方法函数等，用pub use导出层级深的目录结构。</p><p>as可以提供改名的便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust中的enum和match</title>
    <link href="https://www.jackhuang.cc/2023/01/08/enum-and-match/"/>
    <id>https://www.jackhuang.cc/2023/01/08/enum-and-match/</id>
    <published>2023-01-08T11:25:24.000Z</published>
    <updated>2023-01-12T14:42:36.590Z</updated>
    
    <content type="html"><![CDATA[<p>今天就来熟悉一下Rust的enum和match语法吧。</p><span id="more"></span><!-- toc --><ul><li><a href="#1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAenum">1. 定义一个enum</a><ul><li><a href="#11-%E7%BB%99enum%E7%BB%91%E5%AE%9A%E5%80%BC">1.1 给enum绑定值</a></li><li><a href="#12-%E7%BB%99enum%E5%8A%A0%E4%B8%8A%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">1.2 给enum加上成员方法</a></li><li><a href="#13-enum%E5%92%8Cstruct%E7%9A%84%E5%8C%BA%E5%88%AB">1.3 enum和struct的区别</a></li></ul></li><li><a href="#2-match%E6%8E%A7%E5%88%B6%E6%B5%81">2. match控制流</a></li><li><a href="#3-%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84enumoptionalt">3. 一个常用的enum：Optional&lt;T&gt;</a></li><li><a href="#4-if-let%E7%94%A8%E6%B3%95">4. if let用法</a></li><li><a href="#5-%E4%BD%BF%E7%94%A8match%E5%92%8Cif-let%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5. 使用match和if let的注意事项</a></li></ul><!-- tocstop --><h2><span id="1-定义一个enum">1. 定义一个enum</span></h2><p>枚举类型从来不缺席任何一个稍微高级的语言。Rust也不例外，定义一个枚举只需要enum关键字即可，比如我们定义IP地址类型，其有两种格式，V4和V6版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddressType</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果有一个地质结构体，就可以用它来标识一个地址是哪一个类型的，使用方法也和其他语言差不多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddressType</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    address_type: IpAddressType,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress &#123;</span><br><span class="line">        address_type: IpAddressType::V4,</span><br><span class="line">        address: <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ip = &#123;:#?&#125;&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ennum此时的用法和C++差不多一样，几乎没有特殊之处，下面，就说一下Rust的enum类型带来的更多特性。</p><h3><span id="11-给enum绑定值">1.1 给enum绑定值</span></h3><p>上面的例子，IpAddressType定义了V4和V6两个类型，要使用它们去标识一个IP需要和String类型一起使用，即IpAddressType标识String的内容是V4还是V6，enum实际上还可以和一个类型绑定，使得其不但有类型属性，还有值属性，比如上面的例子，可以简化为这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ip = &#123;:#?&#125;&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip = <span class="title function_ invoke__">V4</span>(</span><br><span class="line">    <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，enum的类型还可以和其它类型绑定在一起，形成“类型+值”的关系，简化了代码。</p><p>enum绑定可以很灵活，可以绑定任何类型，只要你想绑定，就能绑定，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">RAW_V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">String</span>), <span class="comment">// 绑定多个值</span></span><br><span class="line">    <span class="title function_ invoke__">VPerson</span>(Person) <span class="comment">// 绑定自定义struct</span></span><br><span class="line">    Point&#123;x: <span class="type">i32</span>, y: <span class="type">i32</span>&#125;,  <span class="comment">// 绑定一个匿名struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样使用这个enum：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">raw_ip</span> = IpAddress::<span class="title function_ invoke__">RAW_V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;this is a home address&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">person_type</span> = IpAddress::<span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), age: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point</span> = IpAddress::Point &#123; x: <span class="number">100</span>, y: <span class="number">120</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;raw_ip = &#123;:?&#125;&quot;</span>, raw_ip);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;person_type = &#123;:?&#125;&quot;</span>, person_type);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;point = &#123;:?&#125;&quot;</span>, point);</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raw_ip = <span class="title function_ invoke__">RAW_V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;this is a home address&quot;</span>)</span><br><span class="line">person_type = <span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="string">&quot;jack&quot;</span>, age: <span class="number">100</span> &#125;)</span><br><span class="line">point = Point &#123; x: <span class="number">100</span>, y: <span class="number">120</span> &#125;</span><br></pre></td></tr></table></figure><h3><span id="12-给enum加上成员方法">1.2 给enum加上成员方法</span></h3><p>enum甚至可以加上成员方法，比如我们给IpAddress添加一个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">do_something</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this is an enum!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦拥有了一个IpAddress的枚举值，即可调用这个do_something方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">100</span> &#125;);</span><br><span class="line">ip.<span class="title function_ invoke__">do_something</span>();</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is an enum!</span><br></pre></td></tr></table></figure><h3><span id="13-enum和struct的区别">1.3 enum和struct的区别</span></h3><p>看上去enum和struct大部分是一样的，它们可以定义字段，定义方法，但也有细微的不同，首先当然是一个是用struct关键字定义，一个是用enum定义。</p><p>其次，如果我们把上面的例子改成用struct实现，那么每一个枚举类型都是一个struct，那么这些struct它们都不属于一个类型下的定义，即每个类型都是独立的，而枚举类型则是打包了很多个类型，此时若把struct当作enum来用，if let判断或者match判断是错误的，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddressV4</span> &#123;</span><br><span class="line">    name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddressV6</span> &#123;</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddressV6&#123;</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">match</span> ip &#123;</span><br><span class="line">        IpAddressV4 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v4&quot;</span>),</span><br><span class="line">        IpAddressV6 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码虽然可以编译，但打印出来的却是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is v4</span><br></pre></td></tr></table></figure><p>很明显，不符合预期。 这是因为match发现它们都是struct这个类型，于是走进了V4这个分支中。用enum就可以顺利表达我们的意思：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">u32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">V6</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">match</span> ip &#123;</span><br><span class="line">        IpAddress::<span class="title function_ invoke__">V4</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v4&quot;</span>),</span><br><span class="line">        IpAddress::<span class="title function_ invoke__">V6</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v6&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is v6</span><br></pre></td></tr></table></figure><p>打印正常，因为enum能正确给V4和V6不同的类型，所以，如果需要用match或者if let的话，还是使用enum吧。</p><h2><span id="2-match控制流">2. match控制流</span></h2><p>上面的代码用到了match语法，match其实就是C++中的switch，关键是：match强制检查所有enum类型，否则报错，也就是必须要么枚举所有的类型，或者使用下划线 _  来指定匹配之前的类型都失败则执行默认行为。比如之前的match判断就枚举了V4和V6的所有枚举，但如果遇到整型，由于不可能枚举所有整形，就需要默认分支，也即下划线来保证所有的分支都有考虑到：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_24_or_30</span>(i: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> i &#123;</span><br><span class="line">        <span class="number">24</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one day has 24 hours&quot;</span>),</span><br><span class="line">        <span class="number">30</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;some monthes have 30 days&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no decriptions, it is &#123;&#125;&quot;</span>, i),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，每一个rust分支都是以逗号“,”结尾。我们也可以加上大括号，写一些语句：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_24_or_30</span>(i: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> i &#123;</span><br><span class="line">        <span class="number">24</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one day has 24 hours&quot;</span>),</span><br><span class="line">        <span class="number">30</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;some monthes have 30 days&quot;</span>),</span><br><span class="line">        <span class="number">365</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">                name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                age: <span class="number">100</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;a year commonly has 365 days, the person is: &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no decriptions, it is &#123;&#125;&quot;</span>, i),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-一个常用的enumoptionallttgt">3. 一个常用的enum：Optional&lt;T&gt;</span></h2><p>可以讲讲Optional&lt;T&gt;了。它实际上是一个enum，其源代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// No value.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;None&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="comment">/// Some value of type `T`.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Some&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有两个成员类型，一个是None，顾名思义，即空类型，一个是Some，绑定一个范型T，所以，如果一个变量是Optional&lt;T&gt;的，那么意味着，要么是None类型，要么是Some类型。例如我们写一个函数，入参是Optional&lt;T&gt;，那么里面就要判断两个类型，一个是Some &lt;T&gt;，另一个是None：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">what_kind</span>(k: &amp;<span class="type">Option</span>&lt;IpAddress&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> k &#123;</span><br><span class="line">       <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> x &#123;</span><br><span class="line">                IpAddress::<span class="title function_ invoke__">V4</span>(a, b, c, d) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the v4 ip is &#123;&#125;:&#123;&#125;:&#123;&#125;:&#123;&#125;&quot;</span>, a, b, c, d), </span><br><span class="line">                IpAddress::<span class="title function_ invoke__">V6</span>(a) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the v6 ip is &#123;:?&#125;&quot;</span>, a), </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip1</span> = <span class="title function_ invoke__">Some</span>(IpAddress::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip2</span> = <span class="title function_ invoke__">Some</span>(IpAddress::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::::1&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip3</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip1);</span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip2);</span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以看出，遇到Optional&lt;T&gt;枚举时，必须考虑None和Some两种情况（不然编译报错，虽然可以用下划线来表示默认行为），而要想拿到和Some绑定的T，则必须用match（或者if let，下面会讲），简单总结来说，Optional&lt;T&gt;分为两层处理：</p><p>1、处理None和Some；</p><p>2、若不为None处理Some取出T。</p><p>那么，有人会问，为什么要有Optional&lt;T&gt;这个东西呢？因为Rust所有实体都不能为invalid状态，因此不存在“空”这样的概念，要么有值，要么不能访问，产生编译错误，但现实是有这个概念的，很多语言也有这个概念，Rust在语言机制层面禁止了这个状态的存在，可为了和现实或者和其它语言相对应表达意思的话怎么办呢？于是就需要Optional&lt;T&gt;来做这个工作。</p><p>最后要提一下的是，如果match某个枚举类型啥也不想干，怎么表达呢？因为match必须强制对所有的枚举类型都考虑一遍，所以，遇到啥也不想干的分支，需要一个特殊的写法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ip1 &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> x &#123;</span><br><span class="line">            IpAddress::<span class="title function_ invoke__">V4</span>(a, b, c, d) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>),</span><br><span class="line">            _ =&gt; (),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println!(&quot;x = &#123;:?&#125;&quot;, x);</span></span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码第9行，&#x3D;&gt; ()就是表示，这个分支啥也不干。</p><h2><span id="4-if-let用法">4. if let用法</span></h2><p>上面讲了match处理Optional&lt;T&gt;的方法，如果你只是对某个枚举类型感兴趣但其它都做默认处理的话，就可以使用if let用法。这样可以比较自然的写出对枚举类型的处理，其实也可以少打一些代码。</p><p>if let其实就是match的特殊版本，即只处理某一个枚举，其它要么忽视，要么else去做默认处理，例如上面的例子可以改写成这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">what_kind</span>(k: &amp;<span class="type">Option</span>&lt;IpAddress&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = k &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the v4 ip is &#123;&#125;:&#123;&#125;:&#123;&#125;:&#123;&#125;&quot;</span>, a, b, c, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V6</span>(a) = x &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the v6 ip is &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="5-使用match和if-let的注意事项">5. 使用match和if let的注意事项</span></h2><p>match和if let的使用算是讲完了，但有一个不起眼的事情需要提一下，就是match和if let是会发生资源转移的，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = ip1 &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br></pre></td></tr></table></figure><p>上面第一行代码if let Some(x) &#x3D; ip1，会发生资源转移，即ip1的字段会转移到x上，也即partial moves（详见：<a href="https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html">https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html</a> ）因此，第7行的println!会访问一个已经包含悬空指针的ip1，这不合法，编译器拒绝编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `ip1`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">71</span>:<span class="number">28</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">65</span> |     <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = ip1 &#123;</span><br><span class="line">   |                 - value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">71</span> |     <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br><span class="line">   |                            ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `IpAddress`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this field <span class="keyword">in</span> the pattern to avoid moving `ip1.<span class="number">0</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">65</span> |     <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> x) = ip1 &#123;</span><br><span class="line">   |                 +++</span><br></pre></td></tr></table></figure><p>编译起给出的建议是用引用ref x，当然，我觉得用&amp;ip1也可以。</p><p>还需要注意到一个点是，x并没有发生资源转移，因为x的资源都是u8，他们是primitive类型的，直接使用拷贝，这在前面讲过。</p><p>换成match呢：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ip1 &#123;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">      &#125;,</span><br><span class="line">      _ =&gt; (),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br></pre></td></tr></table></figure><p>依然编译不通过的，资源转移发生在上面的第2行：Some(x) &#x3D;&gt;，此时ip1资源转给了x，ip1又包含悬空指针了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `ip1`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">74</span>:<span class="number">28</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">66</span> |         <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">   |              - value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">74</span> |     <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br><span class="line">   |                            ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `IpAddress`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this field <span class="keyword">in</span> the pattern to avoid moving `ip1.<span class="number">0</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">66</span> |         <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> x) =&gt; &#123;</span><br></pre></td></tr></table></figure><p> 总结来说，使用match或者if let一定要小心，如果不想发生资源转移，那么就用引用来代替，编译器给出了不错的建议。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天就来熟悉一下Rust的enum和match语法吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的struct类型</title>
    <link href="https://www.jackhuang.cc/2023/01/07/RustStruct/"/>
    <id>https://www.jackhuang.cc/2023/01/07/RustStruct/</id>
    <published>2023-01-07T09:19:26.000Z</published>
    <updated>2023-01-09T12:46:41.104Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的struct定义和C++的类似，甚至提供了简化初始化的方法，定义成员方法也更灵活，刚刚登上第一个陡坡（所有权），这一节缓缓，因为struct算是Rust中难度不高的内容。</p><span id="more"></span><!-- toc --><ul><li><a href="#1-struct%E7%9A%84%E5%AE%9A%E4%B9%89">1. struct的定义</a></li><li><a href="#2-struct%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">2. struct的初始化方法</a><ul><li><a href="#21-%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">2.1 直接初始化</a></li><li><a href="#22-%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96">2.2 用函数初始化</a></li><li><a href="#23-%E7%94%A8%E5%88%AB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96">2.3 用别的对象初始化</a></li></ul></li><li><a href="#3-%E7%89%B9%E6%AE%8A%E7%9A%84struct">3. 特殊的struct</a></li><li><a href="#4-%E7%BB%99struct%E5%8A%A0%E4%B8%8A%E6%96%B9%E6%B3%95">4. 给struct加上方法</a></li><li><a href="#5-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">5. 静态方法</a></li><li><a href="#6-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">6. 定义多个成员方法</a></li><li><a href="#7-%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">7. 遗留问题</a></li></ul><!-- tocstop --><h2><span id="1-struct的定义">1. struct的定义</span></h2><p>和很多语言一样，定义一个struct就是用struct关键字加上名字，然后罗列出字段来，比如最简单的定义一个人：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>, </span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就定义好了一个人，接下来就是初始化了。</p><h2><span id="2-struct的初始化方法">2. struct的初始化方法</span></h2><h3><span id="21-直接初始化">2.1 直接初始化</span></h3><p>Rust有三种办法初始化一个struct，最简单的莫过于直接赋值，很像json，即key-value形式赋值即可（另外其实提示一下，初始化这些字段并无顺序要求）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jackzhhuang@gmail.com&quot;</span>),</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>试着打印one，会发现错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, one);</span><br></pre></td></tr></table></figure><p>错误信息为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Person` doesn<span class="symbol">&#x27;t</span> implement `std::fmt::Display`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">34</span>:<span class="number">26</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">34</span> |     <span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, one);</span><br><span class="line">   |                          ^^^ `Person` cannot be formatted with the default formatter</span><br><span class="line">   |</span><br><span class="line">   = help: the <span class="keyword">trait</span> `std::fmt::Display` is not implemented <span class="keyword">for</span> `Person`</span><br><span class="line">   = note: <span class="keyword">in</span> format strings you may be able to <span class="keyword">use</span> `&#123;:?&#125;` (or &#123;:#?&#125; <span class="keyword">for</span> <span class="title class_">pretty</span>-print) instead</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br></pre></td></tr></table></figure><p>这里根据提示，会知道，Rust并不是说不知道one里面有什么东西，而是它不知道怎么格式化输出这个对象，好在我们有Debug trait，它可以告诉Rust怎么格式化输出结构，所以，Person的定义加上Debug trait即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>, </span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust提供了很多trait，struct结构derive了某个trait就有了某个特性，比如这里derive了Debug trait，就可以让rust知道怎么格式化输出这个结构体，更多trait后面会讲到，官方教学文档也给所有的trait介绍，详见：<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">https://doc.rust-lang.org/book/appendix-03-derivable-traits.html</a>  ，这里不展开说。</p><p>另外，由于是自定义的类型，需要在格式化的时候告诉Rust，因此print宏中，{}需要修改为{:?}（简洁打印，所有字段都在一行打印出来）或者{:#?}（美观打印，会换行且对齐）。</p><p>此时，可以正常打印one了，以下是美观打印出来的输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;jackzhhuang@gmail.com&quot;</span>,</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="22-用函数初始化">2.2 用函数初始化</span></h3><p>我们当然可以写一个函数然后传入一些字段值，然后在函数中初始化一个对象，最后返回出去。但Rust还提供了一个更简略的语法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_a_person</span>(name: <span class="type">String</span>, age: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Person &#123;</span><br><span class="line">    Person &#123; name, </span><br><span class="line">             age, </span><br><span class="line">             address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(), </span><br><span class="line">             email: <span class="string">&quot;jackzhhuang@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，name和age直接就放在大括号中了，并不需要写出name: name或者age: age这样的代码。</p><h3><span id="23-用别的对象初始化">2.3 用别的对象初始化</span></h3><p>如果已经有了一个对象，我们还想初始化另一个对象，只是有些字段和现有的对象字段不同，除了用前面的方法初始化以外，还有什么办法吗？Rust提供了struct update语法：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jackzhhuang@gmail.com&quot;</span>),</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="variable">another</span> = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Bob&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    ..one</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;another = &#123;:#?&#125;&quot;</span>, another);</span><br></pre></td></tr></table></figure><p>以上会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">another = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>,</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，age和address都和one一样有同样的值。</p><p>但此时注意，one的address变成了悬空指针，此时不能再访问，如果后面加上访问代码，会直接编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.name = &#123;&#125;&quot;</span>, one.name);    <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.email = &#123;&#125;&quot;</span>, one.email);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.age = &#123;&#125;&quot;</span>, one.age);      <span class="comment">// 没问题，因为primitive类型是copy</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.address = &#123;&#125;&quot;</span>, one.address);   <span class="comment">// 编译错误，因为address已经被转移到another了</span></span><br></pre></td></tr></table></figure><p>编译结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">44</span> |       <span class="keyword">let</span> <span class="variable">another</span> = Person &#123;</span><br><span class="line">   |  ___________________-</span><br><span class="line"><span class="number">45</span> | |         name: <span class="string">&quot;Bob&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line"><span class="number">46</span> | |         email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line"><span class="number">47</span> | |         ..one</span><br><span class="line"><span class="number">48</span> | |     &#125;;</span><br><span class="line">   | |_____- value moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">55</span> |       <span class="built_in">println!</span>(<span class="string">&quot;one.address = &#123;&#125;&quot;</span>, one.address);</span><br><span class="line">   |                                    ^^^^^^^^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>即这么干，one会把它的字段资源转移到another，由于name和email我们赋的是新值，而age是u32，为primitive，赋值是copy形式，只有address字段我们即没有给新值，且其赋值会采取资源转移形式，因此one的address变成悬空指针了，不能访问。</p><h2><span id="3-特殊的struct">3. 特殊的struct</span></h2><p>和C++一样，可以定义一个什么都没有的struct：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nothing</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no</span> = Nothing;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;n = &#123;:?&#125;&quot;</span>, no)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个用在trait比较多，类似于定义一个interface，后续会学习到。</p><h2><span id="4-给struct加上方法">4. 给struct加上方法</span></h2><p>在没有成员方法之前，我们计算一个长方形的面积时这么写的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">80</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, <span class="title function_ invoke__">area</span>(r.width, r.height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用面向对象的方法去思考，面积是长方形的一个属性，长方形自己才知道如何计算自己的面积，因此，应该是长方形这个类返回面积才对，把area这个函数变成Rectangle的方法，只需要impl关键字，并且把area移到Rectangle里面去，并且，第一个参数是&amp;self：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，打印时只需要简单的点area调用即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, r.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure><p>这里需要注意的一个地方是，self这个参数，我们用了引用，其实是省略写法，写完整是self: &amp;Self，那么如果不使用引用可以吗？当然可以，只是这么干，会触发Rust的资源转移机制，调用方的对象会变悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = r.<span class="title function_ invoke__">area</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, s);</span><br></pre></td></tr></table></figure><p>因为self不是引用，上面的代码第7行r会变成悬空指针，那么第8行的打印r会编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> |     <span class="keyword">let</span> <span class="variable">s</span> = r.<span class="title function_ invoke__">area</span>();</span><br><span class="line">   |               ------ `r` moved due to this method call</span><br><span class="line"><span class="number">21</span> |     <span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, s);</span><br><span class="line">   |                                                        ^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">note: this function takes ownership of the receiver `<span class="keyword">self</span>`, which moves `r`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">9</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">9</span>  |     <span class="keyword">fn</span> <span class="title function_">area</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">   |             ^^^^</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br></pre></td></tr></table></figure><p>根据提示可以知道，因为self不是引用，所以对象资源被转移走了，r就丢了对象，导致悬空指针。这种把self定义为非引用的用法在Option&lt;T&gt;中比较常用，下一节会讲到。</p><h2><span id="5-静态方法">5. 静态方法</span></h2><p>正如之前用的String::from那样，struct可以定义静态成员方法，也就是不需要对象指针就可以访问的方法，只需要在方法上不加入self参数即可，比如下面这个计算一个数的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;square of &#123;&#125; is &#123;&#125;&quot;</span>, n, Rectangle::<span class="title function_ invoke__">square</span>(n));</span><br></pre></td></tr></table></figure><p>可以正常打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square of <span class="number">3</span> is <span class="number">9</span></span><br></pre></td></tr></table></figure><h2><span id="6-定义多个成员方法">6. 定义多个成员方法</span></h2><p>定义多个成员方法时，可以都写在同一个impl块中也可以分开写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以下是等价的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分开写在不同的impl块的好处是扩展Rectangle类的时候不需要去修改之前的老代码，相比OOP中的写一个子类去扩展要更方便更灵活。</p><h2><span id="7-遗留问题">7. 遗留问题</span></h2><p>这一节相对来说是比较简单的，实际上遗留了一些比较难的问题，这些需要后面学习到lifetime的时候解决：</p><p>1、目前为止我们都是用的类来做成员字段，如果用引用做成员字段呢？</p><p>2、如果struct对象已引用的方式传参，那么会发生什么？</p><p>3、如何解决用其它对象初始化新对象时，其它对象字段指针变成悬空指针的问题？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的struct定义和C++的类似，甚至提供了简化初始化的方法，定义成员方法也更灵活，刚刚登上第一个陡坡（所有权），这一节缓缓，因为struct算是Rust中难度	不高的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>C++右值引用场景分析</title>
    <link href="https://www.jackhuang.cc/2023/01/05/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://www.jackhuang.cc/2023/01/05/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</id>
    <published>2023-01-05T04:42:57.000Z</published>
    <updated>2023-01-06T15:03:05.773Z</updated>
    
    <content type="html"><![CDATA[<p>今天就向右值引用的使用场景进行开炮。</p><p>首先，几句话快速复习左值右值：</p><span id="more"></span><p>左值：有一个生命范围的值。左值有名称。</p><p>右值：不像左值在某个范围都能存在，而右值生命始于某一行也终于那一行的值，除非有右值引用接住它的资源，否则过了那一行就要变成invalid的值。std::move可以把左值转为右值，进而执行资源转移语义。右值无名称，但右值的引用可以有名称。</p><p>我们先写一个基本类，好跟踪调试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="type">char</span>* s_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in common constructor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in left value reference!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in right value reference!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">        other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] s_;</span><br><span class="line">        s_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">strlen</span>(other);</span><br><span class="line">        s_ = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(s_, other, len);</span><br><span class="line">        s_[len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whatis</span>;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyString&amp; s) &#123;</span><br><span class="line">    out &lt;&lt; s.<span class="built_in">what</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="1-右值引用作为函数参数">1. 右值引用作为函数参数</span></h2><h3><span id="11-具体类">1.1 具体类</span></h3><p>假设我们现在要打印一个MyString对象，如果函数使用的是一个具体的右值引用（即MyString&amp;&amp;）参数，那么，它就是右值引用，即只接受右值：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(MyString&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若打算传一个左值，那就会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>此时会报：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No matching function <span class="keyword">for</span> call to <span class="string">&#x27;print_my_string&#x27;</span></span><br></pre></td></tr></table></figure><p>因为print_my_string需要的就是一个右值，必须给它一个右值，比如一个函数返回的临时变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">make_my_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* something)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyString</span>(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_my_string</span>(<span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为make_my_string返回了一个局部变量，且make_my_string返回的是一个对象，因此这里相当于返回一个临时变量MyString，因为是临时的，没人接手它的资源就要被销毁了，所以是名副其实的右值，此时满足print_my_string的入参条件，编译没问题，运行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>可以看到，并没有调用太多的构造函数，尤其是没有去调用右值引用的拷贝构造函数，这当然是优化的结果（return value optimization）。尽管如此，依赖右值引用入参的print_my_string还是被调用了，符合预期。</p><p>总之，当函数的入参是一个具体的右值引用参数时，那么它就是一个右值引用参数，不能是其它类型值。可是，一旦把具体的右值引用参数改成模板类型，就发生巨大的改变。</p><h3><span id="12-模板">1.2 模板</span></h3><p>将print_my_string修改成模板函数后，变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(T&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果传入一个MyString对象：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>会发现打印的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>也就是实际在print_my_string函数中，s是一个左值引用。但如果使用print_my_string返回一个右值，那么就变成了右值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print_my_string</span>(<span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>也就是说，T&amp;&amp;会根据入参的类型，来去定参数s的类型，甚至能变出const引用出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString <span class="type">const</span>&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>实际上，T&amp;&amp;和右值引用并不是一回事，T&amp;&amp;是一种万能引用，可以根据调用方的参数类型变成对应的引用类型。</p><h2><span id="2-变量的右值引用">2. 变量的右值引用</span></h2><h3><span id="21-变量为右值引用">2.1 变量为右值引用</span></h3><p>变量定义为右值引用的情况，那么当然只能是右值引用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">MyString&amp;&amp; t = <span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>这个特性似乎没什么可说的。那么换成auto&amp;&amp;呢？</p><h3><span id="22-autoampamp">2.2 auto&amp;&amp;</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = <span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>运行代码发现还是右值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>这应该也很好理解，因为make_my_string就是返回一个右值。如果给auto&amp;&amp;一个左值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = s;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>此时和前面的万能引用一样，变成了左值引用，以下是运行结果：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>也和前面说的一样，如果加上const，t也会变成带const的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = s;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString <span class="type">const</span>&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>可以加auto&amp;&amp;和T&amp;&amp;一样，都是万能引用，随着使用方的类型变化成对应的引用类型。</p><h2><span id="3-万能引用加上const后的ampamp">3. 万能引用加上const后的&amp;&amp;</span></h2><p>上面说了T&amp;&amp;和auto&amp;&amp;是万能引用，那么const T&amp;&amp;和const auto&amp;&amp;呢？print_my_string 改成了加行const的T&amp;&amp;入参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(<span class="type">const</span> T&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时下面的代码会变成const左值引用吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>实际上是会编译失败，在xcode上提示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No matching function <span class="keyword">for</span> call to <span class="string">&#x27;print_my_string&#x27;</span></span><br></pre></td></tr></table></figure><p>因为这个时候const T&amp;&amp;变成是模板类型为T的右值引用，不是万能引用了，强制std::move一下实现右值语义就能通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(std::<span class="built_in">move</span>(s));</span><br></pre></td></tr></table></figure><p>同理，auto&amp;&amp;加上const后，即const auto&amp;&amp;就不再是万能引用，而是右值引用，必须是右值才能给它赋值。</p><h2><span id="4-总结">4. 总结</span></h2><p>对于实际类的右值引用就是右值引用。</p><p>但参数值T&amp;&amp;和右值引用无关，是万能引用，其参数类型由调用方决定，调用方传的什么类型，就是什么类型的引用，即可以是右值引用也可以是左值引用，甚至可以推导出const属性。</p><p>同理，作为一个变量，auto&amp;&amp;也是万能引用，其由赋值方来决定其是什么类型的引用，也即可以是右值引用也可以是左值引用，同样也可以推导出const属性。</p><p>但需要注意的是，const T&amp;&amp;和const auto&amp;&amp;却不是万能const引用，而是右值const引用，即它们只接受右值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天就向右值引用的使用场景进行开炮。&lt;/p&gt;
&lt;p&gt;首先，几句话快速复习左值右值：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust所有权</title>
    <link href="https://www.jackhuang.cc/2023/01/02/Rust%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>https://www.jackhuang.cc/2023/01/02/Rust%E6%89%80%E6%9C%89%E6%9D%83/</id>
    <published>2023-01-02T08:17:40.000Z</published>
    <updated>2023-01-08T04:01:07.403Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的所有权应该是Rust语言最难理解的一个，是初学者学习Rust遇到的第一个也是最大的陡坡。很多语言几乎不需要去花时间学习资源管理（Java，Go，Python等，C++当然是除外的），所以那些语言很流行，很受欢迎，因为只需要学习一下语法，关键字就能投入到项目中去了，但Rust学习单单是所有权（相当于资源管理）这一块内容，就可以成功劝退绝大部分程序员。</p><p>这是Rust的劣势，决定了Rust流行不起来，也是Rust的优势，决定了Rust效率和正确率上都远优于其它语言（甚至包括C语言）。今天写个总结，把Rust所有权内容说一说。</p><span id="more"></span><h2><span id="1-简单的生命周期">1. 简单的生命周期</span></h2><p>从最简单的说起，let表示绑定某个指针到某个对象上，当离开作用域时，对象被销毁，指针进而变为invalid：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面的代码，离开main函数，就变成invalid了，String对象也销毁了。</p><p>上面的代码相当于这样：</p><p><img src="https://www.jackhuang.cc/svg/rust_%E6%89%80%E6%9C%89%E6%9D%83.svg" alt="绑定关系"></p><p>这里简单说一下，s可以理解为一个指针，String即为对象，其成员p指向真正的字符串类型，后面的10位字符串的长度，16为String对象的容量（capacity） 。</p><h2><span id="2-从最简单的所有权关系说起">2. 从最简单的所有权关系说起</span></h2><h3><span id="21-赋值">2.1 赋值</span></h3><p>其实Rust难，就难在下面这个简单代码里面，很多人是无法接受Rust这种规定，但其实Rust这么干也是用心良苦。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>以上代码是不能通过编译的，报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">17</span>:<span class="number">24</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `s` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line">   |             - value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="number">17</span> |     <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">   |                        ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>因为s赋值给t后，s将会变成invalid，也就是悬空指针，这个时候不能对s进行任何访问操作，其对象关系图如下：</p><p><img src="https://www.jackhuang.cc/svg/rust%E8%B5%8B%E5%80%BC.svg" alt="赋值"></p><p>也即，s将失去String对象，t取而代之，只有去掉对s的访问才可以通过编译，Rust不允许访问没有资源的指针。</p><h3><span id="22-参数传递">2.2 参数传递</span></h3><p>同理，返回值也一样，比如我们有一个函数，返回一个String对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_upper_string</span> (t: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t.<span class="title function_ invoke__">to_uppercase</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_upper_string</span>(s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，上面的代码第10行诗没有办法通过编译的，因为print_upper_string函数的参数t已经获得了s的String对象资源，s变成了悬空指针，cargo build会提示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `s`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">16</span>:<span class="number">24</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `s` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">15</span> |     <span class="title function_ invoke__">print_upper_string</span>(s);</span><br><span class="line">   |                        - value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">   |                        ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><h2><span id="3-使用借用">3. 使用借用</span></h2><p>解决以上的问题有三个办法，一个是借用，一个是clone，还有一个是使用引用计数。这里先讲借用。</p><p>所谓借用，其实就是C++的引用，也就是被赋值的指针是引用，而不是拥有资源，此时不发生资源转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = &amp;s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>例如上面的代码，t获得&amp;s，即t只是借用s资源，并不拥有它，因此可以通过编译，运行良好。都会打印hello rust!：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = hello rust! </span><br><span class="line">s = hello rust! </span><br></pre></td></tr></table></figure><p>如果去打印t的值和s的地址，会发现它们是相等的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:p&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:p&#125;&quot;</span>, &amp;s);</span><br></pre></td></tr></table></figure><p>此时会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0x7ffeefbff2f8</span></span><br><span class="line">s = <span class="number">0x7ffeefbff2f8</span></span><br></pre></td></tr></table></figure><p>所以t其实对s的一个引用：</p><p><img src="https://www.jackhuang.cc/svg/rust%E5%BC%95%E7%94%A8.svg" alt="引用"></p><p>因此，打印t和s所指向的字符串内容时，访问t也可以用解引用来访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, *t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>以上两句代码同样也是打印hello rust!。而且，你会发现*t的地址正是s的地址。</p><h2><span id="4-使用克隆">4. 使用克隆</span></h2><p>另一个可以用于赋值的方法，就是克隆函数clone：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust! &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;, t = &#123;:p&#125;&quot;</span>, t, &amp;t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;, s = &#123;:p&#125;&quot;</span>, s, &amp;s);</span><br></pre></td></tr></table></figure><p>这时，s和t就是两个完全不同的指针了，它们只是值相同而已：</p><p><img src="https://www.jackhuang.cc/svg/rust_clone.svg" alt="克隆"></p><h2><span id="5-数组的特殊情况">5. 数组的特殊情况</span></h2><p>以上说的是非数组情况，到了数组，稍微有点不一样了，因为数组是维护了一组指针，如果随便允许把其中某个或者某些指针置为悬空指针，那么数组就需要维护哪个指针是悬空的，哪个指针是有效的。Rust拒绝这么干，所以，数组中的指针不允许直接变成悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">5</span>] = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = array[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = array[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按前面所说，以上代码中，t和s会获得array数组中第三、第四个资源所有权，但实际Rust拒绝这么干，此时编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[<span class="type">String</span>; <span class="number">5</span>]`, a non-copy array</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">21</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |     <span class="keyword">let</span> <span class="variable">t</span> = array[<span class="number">2</span>];</span><br><span class="line">   |             ^^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |             <span class="keyword">move</span> occurs because `array[_]` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |             help: consider borrowing here: `&amp;array[<span class="number">2</span>]`</span><br><span class="line"></span><br><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[<span class="type">String</span>; <span class="number">5</span>]`, a non-copy array</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">22</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> |     <span class="keyword">let</span> <span class="variable">s</span> = array[<span class="number">3</span>];</span><br><span class="line">   |             ^^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |             <span class="keyword">move</span> occurs because `array[_]` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |             help: consider borrowing here: `&amp;array[<span class="number">3</span>]`</span><br></pre></td></tr></table></figure><p>也即，对于数组中的资源，我们只能用引用访问，以下可以正常编译通过且打印如预期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">5</span>] = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = &amp;array[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;array[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, *t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, *s);</span><br></pre></td></tr></table></figure><p>相比之前的代码，t和s都变成了引用，由于是引用，并不会转移所有权，因此array的资源都在。</p><p>如果是多个引用，则直接使用引用数组即可，例如连续引用数组的第三和第四个资源：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span>: &amp;[<span class="type">String</span>] = &amp;array[<span class="number">2</span>..=<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &quot;</span>, t);</span><br></pre></td></tr></table></figure><p>此时打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;!&quot;</span>, <span class="string">&quot;jack&quot;</span>] </span><br></pre></td></tr></table></figure><p>这里，数组被我改成了Vec对象，其实只要是连续的对象，比如数组（即[]），Vec，String都可以用引用数组来引用，String的引用有点特殊：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span>: &amp;<span class="type">str</span> = &amp;s[<span class="number">2</span>..=<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &quot;</span>, t);</span><br></pre></td></tr></table></figure><p>这里看到，使用的是&amp;str而不是&amp;[T]，这是Rust的两类数组，&amp;[T]是普通数组引用，&amp;str相当于对字符类型的特殊数组引用，即char串引用。作为特殊的引用，Rust还给它们（&amp;[T]和&amp;str）起了个名字叫切片，即slice。关于引用后面还要专门拿出来讲，这里关注所有权这个话题就好了。</p><p>尽管数组不允许别人把它的资源拿走，只能用引用，但如果用迭代器去访问，资源的所有权还是会被拿走的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), ];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t)</span><br><span class="line">&#125;                              </span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面的代码会报错，因为v的资源的所有权都被t拿走了，v已经是一个悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">32</span>:<span class="number">26</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">25</span> |     <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `v` has <span class="keyword">type</span> `<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">...</span><br><span class="line"><span class="number">28</span> |     <span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">   |              - `v` moved due to this implicit call to `.<span class="title function_ invoke__">into_iter</span>()`</span><br><span class="line">...</span><br><span class="line"><span class="number">32</span> |     <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">   |                          ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><h2><span id="6-primitive类型不会有所有权转移">6. primitive类型不会有所有权转移</span></h2><p>尽管前面讲了很多所有权转移的例子，但对于原始类型（比如整型，bool，char）并不会有所有权转移的问题，它们永远都是copy：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// 不会发生所有权转移，a和b都有自己的值3</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>上面的代码正常编译和运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>, b = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>所有权和引用后面还会专门讲很多，这次算是先来个前奏。慢慢积累吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的所有权应该是Rust语言最难理解的一个，是初学者学习Rust遇到的第一个也是最大的陡坡。很多语言几乎不需要去花时间学习资源管理（Java，Go，Python等，C++当然是除外的），所以那些语言很流行，很受欢迎，因为只需要学习一下语法，关键字就能投入到项目中去了，但Rust学习单单是所有权（相当于资源管理）这一块内容，就可以成功劝退绝大部分程序员。&lt;/p&gt;
&lt;p&gt;这是Rust的劣势，决定了Rust流行不起来，也是Rust的优势，决定了Rust效率和正确率上都远优于其它语言（甚至包括C语言）。今天写个总结，把Rust所有权内容说一说。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>C++查看类型</title>
    <link href="https://www.jackhuang.cc/2023/01/01/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.jackhuang.cc/2023/01/01/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-01-01T06:33:22.000Z</published>
    <updated>2023-01-05T00:59:14.911Z</updated>
    
    <content type="html"><![CDATA[<p>在进一步研究右值引用或者说&amp;&amp;符号之前，先稍微说一下C++中如何查看一个变量的类型。</p><span id="more"></span><h2><span id="1-获取变量的类型">1. 获取变量的类型</span></h2><p>只需要用关键字decltype既可以拿到关键字的类型，例如下面的代码，d和s的类型都一样，都是const std::string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br></pre></td></tr></table></figure><h2><span id="2-c标准的查看类型方法">2. C++标准的查看类型方法</span></h2><p>C++标准使用的方法是std::type_info这个类来获取变量类型，但这个类无法直接构造，因为它的构造函数被deleted了，只能用C++关键字typeid来获得这个类对象。std::type_info有一个成员函数叫name，它返回变量的类型，只是这个变量类型会丢失一些关键信息，比如const或者引用，因此目前标准并没有给出很好的方法去查看变量类型是什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如上面这段代码，在xcode上打印的就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE</span><br></pre></td></tr></table></figure><p>这个信息丢失了const，甚至也很难看出这到底是什么东西，比如最简单的int类型居然也是一个迷惑的i：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下打印i，而不是const int&amp;</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>总之，C++的std::type_info（用关键字typeid）获得的信息真是没什么实用性，名字难看（可读性差），且会丢失一些重要的关键字，比如const，votlatile等。</p><p>顺便再强调一下，typeid是一个关键字，返回std::type_info对象，这个是在编译时期就确定的，因此，如果给一个父类指针，其指向子类对象，那么运行时期依然返回的是父类类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>以上，将会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PK4Base</span><br></pre></td></tr></table></figure><p>打印出来的是PK4Base，表示即p是一个指针，指向Base对象（很明显不准确），尽管实际是一个指针，其指向子类对象。因为，这一切都是在编译时期就确定name函数的返回值了。</p><h2><span id="3-让编译器告诉我们类型是什么">3. 让编译器告诉我们类型是什么</span></h2><p>标准的std::type_info无法准确的告诉我们类型是什么，这里有一个简单但依然不完美的方法，即通过编译器在编译的时候告诉我们，缺点是必须触发编译错误，这个方法偶尔临时应急用倒是挺实用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whatis</span>;</span><br></pre></td></tr></table></figure><p>上面的代码，因为Whatis类没有定义，若尝试实例化它，编译器就会告诉我们这个需要实例化的类没有定义，并且把T类型打印出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码xcode上编译报错：</span></span><br><span class="line"><span class="comment">// Implicit instantiation of undefined template &#x27;Whatis&lt;const std::__1::basic_string&lt;char&gt; &gt;</span></span><br><span class="line">Whatis&lt;<span class="keyword">decltype</span>(d)&gt; whatisd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码xcode上编译报错：</span></span><br><span class="line"><span class="comment">// Implicit instantiation of undefined template &#x27;Whatis&lt;const Base *&gt;&#x27;</span></span><br><span class="line">Whatis&lt;<span class="keyword">decltype</span>(p)&gt; whatisp;</span><br></pre></td></tr></table></figure><p> 这种方法能让编译器准确告诉我们T是什么，但需要编译错误，也是可惜。</p><h2><span id="4-使用boost告诉我们类型是什么">4. 使用boost告诉我们类型是什么</span></h2><p>目前最好的方法就是使用boost的boost::typeindex::type_id_with_cvr类，这个类的pretty_name方法会完美返回类型名称：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(d)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(p)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::__1::basic_string&lt;<span class="type">char</span>, std::__1::char_traits&lt;<span class="type">char</span>&gt;, std::__1::allocator&lt;<span class="type">char</span>&gt; &gt; <span class="type">const</span></span><br><span class="line">Base <span class="type">const</span>*</span><br></pre></td></tr></table></figure><p>可以看到，不需要编译失败，直接就打印出准确的类型，包含了const关键字和可阅读的指针符号。</p><p>有了这个工具，我们就可以研究&amp;&amp;符号了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在进一步研究右值引用或者说&amp;amp;&amp;amp;符号之前，先稍微说一下C++中如何查看一个变量的类型。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>快速说一下C++右值引用</title>
    <link href="https://www.jackhuang.cc/2022/12/31/%E5%BF%AB%E9%80%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://www.jackhuang.cc/2022/12/31/%E5%BF%AB%E9%80%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2022-12-31T12:43:52.000Z</published>
    <updated>2023-01-05T00:59:45.438Z</updated>
    
    <content type="html"><![CDATA[<p>希望用最简单的话把右值引用说清楚。</p><span id="more"></span><p>什么是右值引用：右值引用即资源传递，右值引用后，引用方会获得资源，被引用方，如同右值那样，被销毁，处于invalid状态。</p><p>为什么需要右值引用：在语义上表达资源传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="type">char</span>* s_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左值引用构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右值引用构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">        other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] s_;</span><br><span class="line">        s_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">strlen</span>(other);</span><br><span class="line">        s_ = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(s_, other, len);</span><br><span class="line">        s_[len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现输出</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyString&amp; s) &#123;</span><br><span class="line">    out &lt;&lt; s.<span class="built_in">what</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面的MyString类，构造函数分为左值引用构造函数和右值引用构造函数。</p><p>右值引用构造函数的实现中，需要release调other的指针，因为根据右值引用的协议，被引用的对象应该处于被销毁的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">d</span><span class="params">(std::move(s))</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// panic!</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如执行以上的代码，std::move是强制把s转为右值，从而触发调用MyString的右值引用构造函数，之后，s将会变成invalid状态，此时打印s会出现未定义状态现象。</p><p>当然这个协议完全可以不去遵守，即MyString的右值引用构造函数中不调用release()，这是C++灵活之处，编译器不会强制你遵守这个协议。但不按约定去做，右值引用存在就没有意义了。C++标准库都遵守右值引用的协议。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">d</span><span class="params">(std::move(s))</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如上面这段代码，s会变成长度为0的空字符串。相比我写的MyString这样更安全，也达到了资源传递的语义目的。</p><p>后面研究一下万能引用，这又是另一个话题。</p><p>新年快乐！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;希望用最简单的话把右值引用说清楚。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>今后要好好做的一些事情</title>
    <link href="https://www.jackhuang.cc/2022/12/30/%E4%BB%8A%E5%90%8E%E8%A6%81%E5%A5%BD%E5%A5%BD%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>https://www.jackhuang.cc/2022/12/30/%E4%BB%8A%E5%90%8E%E8%A6%81%E5%A5%BD%E5%A5%BD%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/</id>
    <published>2022-12-29T16:09:46.000Z</published>
    <updated>2023-01-03T03:43:25.532Z</updated>
    
    <content type="html"><![CDATA[<p>未来要做的东西：</p><p>1、打算用rust做一个学习水平的RPC系统。</p><p>2、写关于C++的博客。多年C++经验，应该是要总结点什么。</p><p>3、写关于mysql的博客。</p><p>4、学习数学。</p><p>对了，还要好好学习写作，倾尽所能，写点东西，在互联网的一个小小的角落里，刷刷存在感吧。</p><p>坚持写作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;未来要做的东西：&lt;/p&gt;
&lt;p&gt;1、打算用rust做一个学习水平的RPC系统。&lt;/p&gt;
&lt;p&gt;2、写关于C++的博客。多年C++经验，应该是要总结点什么。&lt;/p&gt;
&lt;p&gt;3、写关于mysql的博客。&lt;/p&gt;
&lt;p&gt;4、学习数学。&lt;/p&gt;
&lt;p&gt;对了，还要好好学习写作，倾尽所</summary>
      
    
    
    
    <category term="想法" scheme="https://www.jackhuang.cc/categories/%E6%83%B3%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
