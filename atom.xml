<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack 热爱积累与沉淀</title>
  
  <subtitle>这里将记录一些关于技术的积累和沉淀</subtitle>
  <link href="https://www.jackhuang.cc/atom.xml" rel="self"/>
  
  <link href="https://www.jackhuang.cc/"/>
  <updated>2023-02-25T10:53:20.239Z</updated>
  <id>https://www.jackhuang.cc/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链（四）：挖矿与脚本校验</title>
    <link href="https://www.jackhuang.cc/2023/02/25/blockchain-mining/"/>
    <id>https://www.jackhuang.cc/2023/02/25/blockchain-mining/</id>
    <published>2023-02-25T08:18:12.000Z</published>
    <updated>2023-02-25T10:53:20.239Z</updated>
    
    <content type="html"><![CDATA[<p>今天再讲讲挖矿和交易校验的一些细节。</p><span id="more"></span><h2 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h2><p>区块链诞生之初，一般的电脑都可以参与挖矿，但现在一般人已经很难参与挖矿了，因为比特币价值很高了（虽然最近一直熊市），参与挖矿的竞争对手越来越多，算力越来越强，大部分区块都是由非常有实力的矿池挖出的，比如写这篇文章时，最近 24 小时的出块前六情况如下（数据来自：<a href="https://www.blockchain.com/explorer/charts/pools">https://www.blockchain.com/explorer/charts/pools</a> ）：</p><div class="table-container"><table><thead><tr><th><strong>Miner / Pool</strong></th><th><strong>Percent</strong></th><th><strong>Blocks Mined</strong></th></tr></thead><tbody><tr><td>Foundry USA</td><td>32.679%</td><td>516</td></tr><tr><td>AntPool</td><td>18.049%</td><td>285</td></tr><tr><td>F2Pool</td><td>15.453%</td><td>244</td></tr><tr><td>Binance Pool</td><td>10.260%</td><td>162</td></tr><tr><td>ViaBTC</td><td>8.043%</td><td>127</td></tr><tr><td>Unknown</td><td>2.723%</td><td>43</td></tr></tbody></table></div><p>可以看到，Foundry USA 这个区块节点已经有 32.679% 的算力了。当算力接近 51% 的时候就相当于有了很大的区块控制权，这样和去中心化的初衷违背，一般会调整难度，使得难度下降，让其它节点更有可能抢到出块权（前面说过，挖矿的概率是独立的，即使算力很强，挖到矿的概率大家都是均等的，这样，降低难度可以让其它节点更有机会挖到矿）。</p><p>另外，即使挖到矿，也有可能不会获得出块奖励，因为如前面所说，区块链有可能出现分叉，这样自己挖到的那个区块可能不是出于最长链中，导致被回滚，这样也降低了区块链被中心化的概率。</p><h3 id="挖矿设备"><a href="#挖矿设备" class="headerlink" title="挖矿设备"></a>挖矿设备</h3><p>第一代挖矿设备就是我们的一般计算机，其主要是靠 CPU 挖矿，在竞争不激烈的时代这么做是没问题的。但随着比特币价值的上升，竞争激烈后，大家升级了挖矿硬件，由 CPU 升级为 GPU，即提高了并行计算的能力。但即使如此， GPU 毕竟是显卡设备，第三代设备则升级为专业的挖矿芯片设备 ASIC： application specific integrated circus。并且，大家也不再单独挖矿，而是以矿池的运作方式进行挖矿。</p><h3 id="矿主和矿工"><a href="#矿主和矿工" class="headerlink" title="矿主和矿工"></a>矿主和矿工</h3><p>所谓矿池，即分为矿主和矿工，矿主主要维护一个全节点，而矿工作为轻节点则只做区块头部的哈希运算，当矿工挖到区块后，就告诉矿主，由矿主提交给区块链。矿池在获得出块奖励后，会给各个矿工一部分奖励。</p><h4 id="激励矿工和防止划水"><a href="#激励矿工和防止划水" class="headerlink" title="激励矿工和防止划水"></a>激励矿工和防止划水</h4><p>那么，这么做会不会有划水矿工呢？矿主为了激励矿工尽可能的挖到区块，除了挖到目标区块以外，还会稍微降低区块的难度，即增大 target 值，并告诉矿工，只要能挖到越过这个降低难度的 target 值，即使最后没有挖到区块而是由其它矿工挖到的，那么也会享受到一部分奖励，这样，矿工就会尽可能的去挖新的区块，如果划水，那么因为没有越过矿主规定的 target 值，也就分不到奖励了。一般来说，矿工提交的次数越多，奖励也就越多。</p><h4 id="防止矿工独自提交区块获得奖励"><a href="#防止矿工独自提交区块获得奖励" class="headerlink" title="防止矿工独自提交区块获得奖励"></a>防止矿工独自提交区块获得奖励</h4><p>矿工挖到矿后，有没有可能自己提交到区块链并获得出块奖励呢？自己提交到区块链是有可能的，但获得出块奖励却不行。因为矿主给到矿工的区块头是包含了 merkle tree 的根哈希值的，这个 merkle tree 中，包含了铸币交易，而铸币交易中，填写的收款人地址（即矿主的公钥哈希值）是矿主，因此矿工如果越过矿主提交到区块链，那么，出块奖励还是会给到矿主而不是矿工。</p><h4 id="矿工攻击"><a href="#矿工攻击" class="headerlink" title="矿工攻击"></a>矿工攻击</h4><p>矿主之间会存在竞争，一种恶性竞争就是，一个矿主给另一个矿主派去大量无用的矿工，这些矿工只是拉那个矿主的后腿，即使挖到了矿也不会提交给矿主，导致矿主分配出去的任务无效。</p><h2 id="交易校验"><a href="#交易校验" class="headerlink" title="交易校验"></a>交易校验</h2><p>这一小节我们讲一下区块链的交易校验细节。我们知道，区块链交易分为两种，一种是出块奖励，此时称为铸币交易，这种交易的比特币是凭空产生的，当然金额是周期性递减直到为0。一种是转账交易，即多对多的转账，此时我们需要交易金额，即最基本的：</p><script type="math/tex; mode=display">上一笔交易的输出金额 = 本次交易的输入金额</script><p>简单来说即“输出 = 输入”。校验是依赖于脚本实现的，上一笔交易中，会指定输出脚本，而本次交易中，会指定输入脚本，分别依次执行输入脚本和输出脚本，脚本不报错则认为交易校验通过。</p><p>一笔简单的交易画成图如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-verify-dealing.svg" alt="交易的校验"></p><p>如上图，A 给 B 转账后，会输出 A 和 B 的余额，已经手续费等信息，同时还会有输出脚本，同样，B 转给 C时，会产生 B 的输入金额和撕咬签名，以及用于校验的输入脚本，区块链系统会依次执行输入脚本和输出脚本，只要不返回异常，那么交易就算通过了。</p><p>交易校验主要分为三种：</p><h3 id="P2PK-Pay-to-Public-Key"><a href="#P2PK-Pay-to-Public-Key" class="headerlink" title="P2PK (Pay to Public Key)"></a>P2PK (Pay to Public Key)</h3><p>这是最简单的一种，虽然现在已经很少用，但实际上确可以易于我们理解，其过程为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig)</span><br><span class="line">output script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey)</span><br><span class="line">CHECKSIG</span><br></pre></td></tr></table></figure><p>其只有三个步骤，第一个步骤即输入脚本的 PUSHDATA(Sig)，即把出钱方的私钥签名压入栈中，然后执行上一个交易的输入脚本第一条语句：PUSHDATA(PubKey)，即把上一个交易的输出方的公钥压入栈中，最后执行 CHECKSIG，即校验栈中的两个私钥签名和公钥是否匹配，若匹配则校验通过。</p><p>可以看出，区块链的这个脚本执行和汇编代码原理很像，即把数据压入栈中，相当于后面调用的函数的参数，然后调用参数同时出栈与之关联的参数。</p><h3 id="P2PKH-Pay-to-Public-Key-Hash"><a href="#P2PKH-Pay-to-Public-Key-Hash" class="headerlink" title="P2PKH (Pay to Public Key Hash)"></a>P2PKH (Pay to Public Key Hash)</h3><p>前面一种仅校验了出款方的私钥，设想，如果有一个恶意用户重放这笔交易，但公私钥签名是恶意用户的，但出款方地址是受害者的，那么 P2PK 方式是无法校验出来的。因此，输入脚本除了需要校验出款方的公私钥签名以外，还需要校验出款方的地址是否和输出脚本中的一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig)</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey)</span><br><span class="line">output script:</span><br><span class="line">DUP </span><br><span class="line">HASH160 </span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKeyHash) </span><br><span class="line">EQUALVERIFY </span><br><span class="line">CHECKSIG</span><br></pre></td></tr></table></figure><p>上面的代码中，首先执行输入脚本的 PUSHDATA(Sig) 将出款方的私钥签名压入栈中，然后 PUSHDATA(PubKey) 压入出款方的公钥。接着执行输出脚本的 DUP，DUP函数会把栈顶数据复制一份，即此时，栈如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key1.svg" alt=""></p><p>接着执行 HASH160，即把顶端的公钥进行哈希，而后 PUSHDATA(PubKeyHash) 压入出款方的公钥哈希，这里特别提示，公钥哈希即出款方的地址：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key2.svg" alt=""></p><p>EQUALVERIFY 指令则是将 栈顶的两个哈希值对比是否相等，即地址校验，成功后栈如下：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key3.svg" alt=""></p><p>因此，CHECKSIG 即校验公私钥签名完成校验。</p><h3 id="P2SH-Pay-to-Script-Hash-和-P2PKH-结合"><a href="#P2SH-Pay-to-Script-Hash-和-P2PKH-结合" class="headerlink" title="P2SH (Pay to Script Hash) 和 P2PKH 结合"></a>P2SH (Pay to Script Hash) 和 P2PKH 结合</h3><p>P2SH 是在 P2PKH 的基础上增加了 redeem 脚本，即赎回脚本，稍微解释即：出款方在输出的时候会指定校验细节，这个细节写入redeem 脚本供下一次交易校验。简单来说，即想用使用出款方的钱，就必须满足上一次交易时出款方定下的规则，否则不予交易。例如这么一个场景，A 获得比特币时，在输出脚本的 redeem 脚本中指定要想使用 A 的余额，B 也要出钱，如此 redeem 脚本会校验 B 的私钥签名和地址。</p><p>下面拿一个例子讲：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redeemScript：</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(Sig_A)</span><br><span class="line">  <span class="title function_ invoke__">PUSHDATA</span>(Sig_B)</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(PubKey_B)</span><br><span class="line">  <span class="title function_ invoke__">PUSHDATA</span>(PubKey_A)</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">CHECKSIG</span><br><span class="line">input script:</span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(serialized redeemScript)</span><br><span class="line">output script:</span><br><span class="line">HASH160 </span><br><span class="line"><span class="title function_ invoke__">PUSHDATA</span>(redeemScriptHash) </span><br><span class="line">EQUAL</span><br></pre></td></tr></table></figure><p>首先，从输入脚本开始，PUSHDATA(serialized redeemScript) 分别压入出款方的私钥签名和 redeem 脚本，然后 HASH160 将序列化后的 redeem 脚本做一次哈希，然后输出脚本的 PUSHDATA(redeemScriptHash) 指令也把自己的 redeem 脚本哈希压入栈：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-key4.svg" alt=""></p><p>此时执行 EQUAL 就可以对比两个 redeem 是否一致，保证本次交易 redeem 的代码时执行出款方的意愿。完成后，进入 redeemScript片段，片段中即将 A 和 B 的私钥及公钥压入栈中，然后进行验签，其原理大致同前不再赘述，通过后交易校验即通过。</p><h3 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h3><p>有一种特殊的输出脚本，它不管怎么样都会执行 RETURN 语句，这个语句会返回错误，也就是说，如果进行交易校验，那么一定会失败，也即校验不通过。相当于上一个交易的输出金额将无法使用。那么这种脚本有什么用呢？因为 RETURN 语句一定返回失败，因此，RETURN 语句后面的内容无论如何都无法执行，因此可以写入任何东西，例如，某人预测足球比赛的结果，他会把足球比赛的结果取哈希后写入输出脚本中，这个交易就相当于一个用来记一个不可篡改的信息的交易。当然，这样做的话，会给 UTXO 系统造成负担，毕竟， UTXO 是全节点所有的输出记录集合，如果大量写入这种无法使用的输出记录，那么 UTXO 会变得难以维护。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天再讲讲挖矿和交易校验的一些细节。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（三）：挖矿难度和网络部署</title>
    <link href="https://www.jackhuang.cc/2023/02/21/blockchain-target-network/"/>
    <id>https://www.jackhuang.cc/2023/02/21/blockchain-target-network/</id>
    <published>2023-02-21T05:14:27.000Z</published>
    <updated>2023-02-21T07:40:05.920Z</updated>
    
    <content type="html"><![CDATA[<p>上一节讲了区块链的协议，这一节主要讲区块链的挖矿难度和网络部署。</p><span id="more"></span><h2 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h2><p>前面讲了，区块链的安全是依靠挖矿难度来保证的，即依赖工作量证明（proof of work）来获取到写入区块链资格，只有算力很强的节点才能争取到写入区块链的权利。这里进一步细讲挖矿的难度。首先，为什么挖矿难度可以增加比特币的安全性呢？</p><p>假设如果区块链的挖矿难度很低，这样导致的结果就是很多人都可以在短时间内争取到写入区块链的权利，于是区块链就会很容易出现分叉：</p><p><img src="https://www.jackhuang.cc/svg/blokchain-mang-forks.svg" alt="区块链分叉"></p><p>图中，大量红色区块追加在黄色区块中，这种分叉不利于区块链的数据一致性保证，这样就很难保证到底哪一个新节点能成为最长的区块链，很难达到最终一致的结果。而且也很容易造成 doubel spending 攻击。</p><h3 id="double-spending-攻击"><a href="#double-spending-攻击" class="headerlink" title="double  spending 攻击"></a>double  spending 攻击</h3><p>所谓 double spending 攻击，就是恶意节点在完成一笔交易后，强行在交易节点前的同一个节点强行写入一个新节点，造成分叉，只要新节点最后变成最长链，根据前面讲的知识，区块链系统会接受最长链为正式节点，这样之前的交易就会被回滚，从而导致卖家损失，例如下图所示：</p><p><img src="https://www.jackhuang.cc/svg/double-spending-attack.svg" alt="double spending 攻击"></p><p>假设 A 是一个恶意用户，第一次交易，A 给 B 转账，但是 A 作为一个恶意节点，它新创建一个自己的另一个账户 A‘，发起第二次交易，A 给自己的 A‘ 转账，这回交易的输入还是老区块（图中的黄色区块）的输出，那么，图中的蓝色区块交易就有可能会被回滚，特别是如果挖矿难度值低的时候，蓝色的交易区块被回滚的可能性就非常之大，因为恶意节点可以短时间内继续写入更多的区块在红色区块之后，即图中后面的灰色区块，最终使得蓝色区块因为不是最长区块而被回滚。若此时 B 给 A 发货了，那么 B 将造成损失。</p><p>提升难度值可以让出现这种攻击的概率变低。而且一般交易平台，也会等待自己的交易区块之后有 6 个区块写入后才确认交易，进一步降低了区块被回滚的概率。这个概率，根据数学家的计算，是非常接近 0 的，可以信任。（这个世界上没有 100% 分布式数据一致性算法，均是极大接近于 0 而已）</p><h3 id="伯努利过程"><a href="#伯努利过程" class="headerlink" title="伯努利过程"></a>伯努利过程</h3><p>整个区块链的挖矿其实是一个伯努利过程，即类似抛硬币，每一次抛到正面或者反面的概率都是 50%，不会因为抛了 9 次都是正面，那么第 10 次是反面的概率而变得更大。通用点说，伯努利过程是每一次随机试验都是独立的概率，而不会因为前面的结果影响下一次的概率变化。</p><p>因此，挖矿虽然比拼算力，但若算力相当的情况下，每一个矿工节点获得写入区块链权利概率都是一样的。因此，只要大部分节点都是善意节点，那么恶意节点想做恶的可能性就很低，而且，正如上一节所说，有超强算力的节点都是希望系统稳定的，不然，一个不值得信任的区块链是没有价值的。</p><h3 id="挖矿难度的控制"><a href="#挖矿难度的控制" class="headerlink" title="挖矿难度的控制"></a>挖矿难度的控制</h3><p>挖矿难度是区块链安全的基石，那么区块链难度是怎么控制的呢？前面有讲，主要是靠区块头的两个字段：target 和 nonce，这里注意的是，nonce 字段只有 4 个字节，相较于哈希结果 sha256 的空间（2<sup>256</sup>）是很小的，因此，还需要区块的中的交易字段来增大哈希参数的输入空间。</p><p>还有要注意的是，难度值 difficulty 和 target 是反比关系，即 target 越大，难度越低，反之亦然。可见 target 前面的0越多，也就越难。</p><p>那么 target 是怎么控制的呢？中本聪首先他规定了，每隔十分钟要产生一个区块，每 2016 个区块就要产生一次新的 target（即每 14 天调整一次 target），新的 target 和老的 target 值关系如下：<br>$$<br>新 target &#x3D; 老 target * \frac{实际时间}{期望时间}<br>$$<br>上面的公示很容易理解，当实际时间和期望时间相等的时候，那么说明难度值可以不需要改变，因为我们的期望值就是每 14 天调整一次，如果实际时间不足 14 天，那么<font size=5> $\frac{实际时间}{期望时间}$ </font>会小于 1，此时新的 target 就会变小，导致难度值变大。相反如果实际时间比期望值长，说明难度变高了，此时 <font size=5>$\frac{实际时间}{期望时间}$ </font>会大于 1，那么新的 target 变大，难度值就变小了。</p><p>调整难度值的意义在于我们的算力一直都在增强，如果保持一成不变，10 分钟出一次新区块的频率就难以保证。</p><h2 id="区块链网络部署"><a href="#区块链网络部署" class="headerlink" title="区块链网络部署"></a>区块链网络部署</h2><p>区块链的网络部署是基于 p2p 网络的，其网络特点如下：</p><p>1、任何节点都是随意加入和离开区块链 p2p 网络；</p><p>2、节点的传输不依赖实际物理拓扑规则，有可能两个较远的节点也可以成为邻居节点；</p><p>3、区块链的块大小一般为 1 MB；因为区块链这种数据量大的数据库，如果每一块都很大，会非常的耗网络带宽，一些轻节点实际只是关心某一些交易，因此大块的区块是不利于在 p2p 网络传输的，小块传输可以增强传输的可用性；</p><h3 id="区块链的节点"><a href="#区块链的节点" class="headerlink" title="区块链的节点"></a>区块链的节点</h3><p>区块链的网络节点部署大致可以包含以下节点：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-nodes.svg" alt="区块链节点"></p><p>上面的图中，首先要注意的是，路由节点是所有节点必须要有的，因为区块链的任何一个节点不可能与区块链系统断开链接。而其它三个节点，则可有可无，例如手机这种轻客户端，我们可以只有钱包节点和网络节点即可，钱包节点只要能向其它的全节点发起交易和验证交易（即向全节点请求区块头和 merkle 树路径）就行了。</p><h3 id="区块链节点处理交易"><a href="#区块链节点处理交易" class="headerlink" title="区块链节点处理交易"></a>区块链节点处理交易</h3><p>一个区块链节点是如何处理交易的呢？首先，它维护了三个池子，一个是孤儿池，一个是交易池，还有一个是 UTXO 池。</p><p>孤儿池是当节点收到别的节点发来的交易时所存放的临时交易池子，顾名思义，它没有任何交易与之相连，它是等待验证，等待写入区块的。</p><p>交易池则是，当孤儿池有交易与之相连之后，则会被移入交易池中，它等待验证和写入区块。</p><p>UTXO 则是已经确认的交易池，UTXO 是 unspent  transaction output的缩写，即未被花费的交易输出，相当于我们常说的余额。简单回顾之前说的，除了铸币交易外，转账交易必须维持 “输入” 等于 “输出”，即这一次的交易输入是上一次交易的输出，任何输入输出都是可以追溯的，并且最后可以计算出每一个账户的余额，这些余额信息（即输出）会被放入到 UTXO 池中，等待作为下一次的输入。</p><p>孤儿池和交易池是位于内存中的，而 UTXO 则一般放在固化的物理存储文件中。下面是一个交易从处理到成为 UTXO 的过程：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-trade.svg" alt="交易池"></p><p>可以看到，首先交易先落在孤儿池中，等待父交易来验证，当父交易验证孤儿交易没问题后则会被移入交易池。交易池的交易经过写入区块处理，则进入 UTXO 池，可以作为下一次交易输入使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节讲了区块链的协议，这一节主要讲区块链的挖矿难度和网络部署。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（二）：Future 和 Wake</title>
    <link href="https://www.jackhuang.cc/2023/02/20/rust-futures/"/>
    <id>https://www.jackhuang.cc/2023/02/20/rust-futures/</id>
    <published>2023-02-20T01:56:48.000Z</published>
    <updated>2023-02-21T05:16:12.472Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们大概知道了一些异步编程概念，我们快速简单的复习一下：</p><p>1、Rust 依靠生产者和消费者模型来实现异步编程；</p><p>2、被定义为asyn 的函数，其返回值为一个 future，调用它的 await 方法会触发函数的执行；</p><p>3、 因此，IO 线程完成工作后给主线成发送消息，触发 await，从而实现异步。</p><p>以上是上一节讲的最最简单的异步编程模型，但 Rust 异步编程并不是这么简单，因为上一节的模型中，我们没有模拟 IO 阻塞，因此，await 实际上是不会阻塞的，但 Rust 异步编程中，恰恰是因为 await 中有 IO 操作会产生阻塞而设计的。</p><p>那么，await 到底是怎么用的呢？更关键的是，如果 await 是阻塞的，那么是怎么做到一个线程的情况下切换上下文的呢？如何做 await 的 IO 操作完成后继续往下执行的呢？</p><p>本节将会把 await 展开，引入关键的两个 trait： Future 和 Wake，把 Rust 的异步编程模型说清楚。</p><span id="more"></span><h2 id="异步函数改写成-Future"><a href="#异步函数改写成-Future" class="headerlink" title="异步函数改写成 Future"></a>异步函数改写成 Future</h2><p>上一节中，我们在函数前加了一个 async 关键字，此时会发现函数会变成一个feture，即我们的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">SayHelloInPending</span> <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>实际上，编译器会把它变成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) </span><br><span class="line">  <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>也就是，任何一个异步函数，都会被化成一个个 future。future trait 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键的函数就是poll，poll 主要是返回一个Poll enum，它要么是 Ready(T)，表示阻塞完成，可以继续执行，T 即函数的返回值，或者Pending 表示函数依然在等待 IO 完成。</p><p>因此，我们只需要把定义的函数写成一个 struct，struct 实现 Future trait，并实现函数需要的阻塞 IO 逻辑即可，当然这个逻辑是在线程中执行，因为不能阻塞 main 线程，main 线程调用 Future trait 的 poll 的会检查阻塞的状态，若未完成，这个 poll 返回 Pending，否则返回 Ready(T)。</p><p>例如我们要实现一个 n 毫秒后返回 completed 字符串的函数，main 主线成会不等这个 n 毫秒，而是继续处理其它已经就绪的 Future，当 n 毫秒完过后，会把 Future 放入队列等待主线程 调度。</p><p>我们的异步函数会被写成这样（此时不再使用 async）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    shared_data: Arc&lt;Mutex&lt;SharedData&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    completed: <span class="type">bool</span>,</span><br><span class="line">    waker: <span class="type">Option</span>&lt;Waker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">new</span>(millis: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>  &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = SayHelloInPending &#123; </span><br><span class="line">            shared_data: Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedData &#123; </span><br><span class="line">                completed: <span class="literal">false</span>, </span><br><span class="line">                waker: <span class="literal">None</span> </span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_data_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;task.shared_data);</span><br><span class="line">        std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(millis));</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = shared_data_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            data.completed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(w) = data.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                w.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        task</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SayHelloInPending</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: std::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) </span><br><span class="line">  <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_data</span> = <span class="keyword">self</span>.shared_data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(<span class="keyword">mut</span> data) = shared_data &#123;</span><br><span class="line">            <span class="keyword">if</span> data.completed &#123;</span><br><span class="line">                <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(<span class="string">&quot;completed&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        Poll::Pending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SayHelloInPending 就是我们的异步函数，现在换成了用 struct 实现，它的成员被放在了 SharedData 里面，并用 Arc 和 Mutex 保护起来，因为 Future 一来被 IO 线程读写，二来也会被主线程读写，因此需要这两个异步容器保护。SharedData 保护了 completed 字段，表示 IO 是否已经完成，初始值为 false。至于 waker 我们待会再说。</p><p>在 new 出 SayHelloInPending 的时候，我们启动了一个线程 sleep 了 n 毫秒用以模拟 IO 操作所需要的时间，可以看到，当 sleep 结束的时候，我们会调用 waker 的 wake 函数，这个名字看上去是要唤醒什么，实际上即触发我们之前提到的 sender 讲就绪的 Future 发给队列，等待 main 线程再次调用 poll 获得返回值。我们待会再说 waker 的更进一步细节。</p><p>之后的 impl Future for SayHelloInPending 块中，即实现了 Future trait，我们先不看 pin 和 context，就看里面的实现细节，可以看到，主要就是检查线程是否 completed，如果是，则返回 completed，否则返回 Pending状态。</p><p>这样我们就封装好了一个异步“函数” （Future）。</p><h2 id="封装Task"><a href="#封装Task" class="headerlink" title="封装Task"></a>封装Task</h2><p>那么主线程怎么调用上面封装的 Future 呢？这里封装了一个 Task，毕竟 Future 可以很多，但是我们需要抽象出 Task 方便 sender 发消息给到队列。</p><p>我们看看 Task 的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    fut: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;&gt;&gt;,</span><br><span class="line">    sender: SyncSender&lt;Arc&lt;Task&lt;T&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Task&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(sender: SyncSender&lt;Arc&lt;Task&lt;T&gt;&gt;&gt;, f: BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            fut: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(f)),</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; ArcWake <span class="keyword">for</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        arc_self.sender.<span class="title function_ invoke__">send</span>(arc_self.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to send task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的返回值我用了模板实现，不必太在意。主要看的是，Task 首先有一个 fut 成员，也即我们的 Future，因为是多线程，因此需要 Mutex 保护，Box 也变成了 BoxFuture，这个我们以后说，现在只需要知道这个字段是 Future 即可，它要等待调度的。另一个当然是 sender，因为当 我们的 fut 就绪的时候，需要 sender 把这个 Task 发到队列，可以看到，sender 实际上放着的是 Arc&lt;Task&lt;T&gt;&gt;，因为 Task 在队列中，可能被其它线程共享，当然本例中只有两个线程（IO 线程和主线程），但我们还是习惯加上了 Arc 容器。</p><p>Task 的 new 方法接受一个 Future 和 sender，这当然是为了初始化。重点是 impl&lt;T&gt; ArcWake for Task&lt;T&gt; 。是的，这个 Task 就是上面提到的 waker 的实现，只要调用 waker 的 wake 方法，那么就会触发 wake_by_ref 的调用，在 wake_by_ref 里面，会看到， Task 的 sender 给队列发送了 Task。</p><h2 id="总结-Future-和-Task"><a href="#总结-Future-和-Task" class="headerlink" title="总结 Future 和 Task"></a>总结 Future 和 Task</h2><p>可见，Rust 的异步是这么实现的：</p><p>0、主线程不停的在监听队列，取出等待调用的 Future，调用 Future 试图获得这个“函数”的返回值；</p><p>1、但Future 实现了阻塞 IO 逻辑，当 IO 逻辑未完成时，若调用其 poll 方法，会返回 pending。主线程第一次调用发现是 Pending 返回，于是忽略继续处理下一个队列中的 Task；</p><p>2、当 Future 的 IO 逻辑完成后，状态会被改成就绪，此时调用 waker 的 wake 方法触发后续操作；</p><p>3、waker 其实就是 Task，Task 的 wake_by_ref 是被 waker 的 wake 方法触发的，其中会调用 sender 的 send 方法把 Task 放入队列；</p><p>4、主线程不停的在监听队列，又遇到了刚才的 Task，于是又去 poll 了一下，发现此时可以返回 Ready 了，于是拿到了“函数”的返回值。</p><p>画成图是这样：</p><p><img src="https://www.jackhuang.cc/svg/rust-future-poll.svg" alt="异步调用示例"></p><p>可以看到，Future 在处理阻塞的 IO 逻辑时，是采用线程来完成的，因为不能阻塞主线程，主线程需要处理下一个 Future（Task）。还可以看到，Task 和 Future 是相互包含，引用的。</p><p>Task 实现了 Wake trait，放在 Future 中，当 Future 完成 IO 阻塞操作后，通过 Wake trait 调用 Task 的 wake_by_ref 函数激发 sender把 Task 重新放入队列中等待调度。</p><p>Future trait 同样也包含在 Task 中，因为 Task 被放入队列后会被 Receiver 调度，即调用其 poll 方法，获得 Pending 状态或者 Ready。Pending 状态则 Task 一边执行去，不阻塞 Receiver，而 Ready 状态则绑定了返回值。</p><p><img src="https://www.jackhuang.cc/svg/rust-future-task.svg" alt="Task 和 Future 的关系"></p><h2 id="Context-出场"><a href="#Context-出场" class="headerlink" title="Context 出场"></a>Context 出场</h2><p>了解上面的关系后，现在该讲讲 Context 了。为什么 Future 在获取 Task，也即 waker 的时候没有直接去使用 waker 呢？这是因为 Context 封装了上下文，目前的确只有 waker，但这也为以后扩展留下了更好的封装。</p><h2 id="executor-驱动"><a href="#executor-驱动" class="headerlink" title="executor 驱动"></a>executor 驱动</h2><p>现在，可以写我们的 executor 函数了，它无非就是把上面提到的receiver做的时候做一遍：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">excutor</span>(queue: Receiver&lt;Arc&lt;Task&lt;<span class="type">String</span>&gt;&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">           <span class="title function_ invoke__">Ok</span>(task) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_ref</span>(&amp;task);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">contex</span> = &amp;<span class="keyword">mut</span> Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker);</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fut</span> = task.fut.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> f) = fut.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">result</span> = f.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(contex);</span><br><span class="line">                    <span class="keyword">if</span>  result.<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                        *fut = <span class="title function_ invoke__">Some</span>(f);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(s) = result &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;finish and receive: &#123;&#125;&quot;</span>, s);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="title function_ invoke__">Err</span>(_) =&gt;  &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">let</span> (sender, queue) = sync_channel::&lt;Arc&lt;Task&lt;<span class="type">String</span>&gt;&gt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建任务，即我们的异步函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Task::&lt;<span class="type">String</span>&gt;::<span class="title function_ invoke__">new</span>(sender.<span class="title function_ invoke__">clone</span>(), SayHelloInPending::<span class="title function_ invoke__">new</span>(<span class="number">2</span> * <span class="number">1000</span>).<span class="title function_ invoke__">boxed</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送到队列，开始调度</span></span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(Arc::<span class="title function_ invoke__">new</span>(task)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 执行调度</span></span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">executor</span>(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，executor 执行的就是前面讲的内容，注意 Task 是如何转为 waker 的，以及 Context 对象的生成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上可见，Rust 的异步编程是靠 Future 这个关键 trait 实现的，通过调用 poll 方法知道“函数”的状态，若是阻塞，则我们的主线程也即executor 会处理下一个 Task，若就绪，则获得函数的返回值。</p><p>我们日常编程当然不需要写这么复杂的代码，这里主要是在学习 Rust 的异步编程模型，实际上，Rust 的异步库都帮我们封装好了以上这些内容，我们在使用各个异步库的时候，只需要像前面一节课讲的那样，调用 Future 的 await 即可实现异步编程了。我们看看，如果把本节内容实现的东西写成 await 是什么样子，以下是伪代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">SayHelloInPending</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;   </span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">SayHelloInPending</span>().<span class="keyword">await</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;result = &#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><p> 就一行 await 即可。当执行到 await 时，由于 SayHelloInPending 需要等待 IO 完成，此时主线程不会阻塞在 await 这个地方，此时相当于调用了 Future 的 poll 方法，主线程发现是Pending于是跑去执行别的 aysnc 函数（即下一个 Task 的 Future）去了，等到 await 返回才又继续往下执行println（即这个 Task wake 方法调用了 sender 把 Task 放入队列继续给调度器执行）。这段代码后面的奥妙，正是本节讲的内容。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>前面提到了一些我们直接忽略的东西，比如：Pin 这个类型，Pin 到底是什么，为什么 Future 放入 Box 的时候要变成 Pin&lt;Box&lt;T&gt;&gt;，也即 BoxFuture 呢？下一节我们继续前进吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们大概知道了一些异步编程概念，我们快速简单的复习一下：&lt;/p&gt;
&lt;p&gt;1、Rust 依靠生产者和消费者模型来实现异步编程；&lt;/p&gt;
&lt;p&gt;2、被定义为asyn 的函数，其返回值为一个 future，调用它的 await 方法会触发函数的执行；&lt;/p&gt;
&lt;p&gt;3、 因此，IO 线程完成工作后给主线成发送消息，触发 await，从而实现异步。&lt;/p&gt;
&lt;p&gt;以上是上一节讲的最最简单的异步编程模型，但 Rust 异步编程并不是这么简单，因为上一节的模型中，我们没有模拟 IO 阻塞，因此，await 实际上是不会阻塞的，但 Rust 异步编程中，恰恰是因为 await 中有 IO 操作会产生阻塞而设计的。&lt;/p&gt;
&lt;p&gt;那么，await 到底是怎么用的呢？更关键的是，如果 await 是阻塞的，那么是怎么做到一个线程的情况下切换上下文的呢？如何做 await 的 IO 操作完成后继续往下执行的呢？&lt;/p&gt;
&lt;p&gt;本节将会把 await 展开，引入关键的两个 trait： Future 和 Wake，把 Rust 的异步编程模型说清楚。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（二）：区块链的交易协议</title>
    <link href="https://www.jackhuang.cc/2023/02/18/blockchaion-protocol/"/>
    <id>https://www.jackhuang.cc/2023/02/18/blockchaion-protocol/</id>
    <published>2023-02-18T12:24:26.000Z</published>
    <updated>2023-02-20T07:49:28.485Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要讲区块链的交易协议细节，即一笔交易是如何写入区块链的交易数据中的。</p><span id="more"></span><h2 id="去中心化的交易需要解决的问题"><a href="#去中心化的交易需要解决的问题" class="headerlink" title="去中心化的交易需要解决的问题"></a>去中心化的交易需要解决的问题</h2><p>我们先看看中心化的交易是怎么样的。中心化的交易，货币是靠央行发行的，发行货币和发行多少货币一切都是它说的算，交易的清结算也是以它的账簿为准，任何交易数据只要写进它的账簿那么就是生效的。相比下，去中心化的交易系统因此有两个问题需要解决：</p><p>1、如何发行货币；</p><p>2、交易怎么进行才能做到可信。</p><p>因为是去中心化的，谁都可以有机会去更新区块链的数据，那么，货币发行怎么控制呢？同样，因为谁都可以有机会去写入交易数据，那么谁写入的数据才算是真实有效的呢？这些问题就需要区块链的交易协议去解决。</p><p>为了讲清楚交易协议，我们会提出一个个问题，然后看看区块链的去中心化交易协议是如何解决的。</p><h2 id="区块链中的交易过程"><a href="#区块链中的交易过程" class="headerlink" title="区块链中的交易过程"></a>区块链中的交易过程</h2><p>抛开货币的发行问题，先看看交易是如何做到可信的，即一笔交易数据，如何保证双方都是出于真实意图的交易呢？</p><p>区块链两大加密技术之一就是公私钥，公私钥对就代表了一个区块链账户。其中公钥用于个人 ID 的标识，私钥用于签名，保证某一笔交易行为是这个人的意愿。我们举个例子，假设 A 需要转账给 B 和 C，那么交易记录就需要至少记录：</p><p>1、使用 A 的私钥签名交易数据，保证 A 的转账行为是 A 真实发起的。这个签名大家都认可，因为 A 的公钥是公开的，可以验证 A 的私钥签名；</p><p>2、交易记录中还需要 B 和 C 的公钥，因为此时想表达 B 和 C 这两个身份，就必须用他们的公钥，公钥此时就相当于区块链的身份 ID；</p><p>3、交易货币数量。</p><p>似乎以上数据就够了，但试想这样一个场景：</p><p>一个恶意用户，自己生成了公私钥对，告诉 B 和 C 说他是 A，那么，按照上面的三条数据要求，这个恶意用户是可以完全自己伪造出 A 转钱给 B 和 C 用户的。因此，这里就需要一些额外的信息，保证 B 和 C 是知道对方是不是 A。自然想到的是验证 A 的公钥，但 B 和 C 如何验证恶意用户出示的 A 的公钥是否真的是 A 的公钥呢？</p><p>这就需要上一节讲的区块链性质了——区块链上的信息都难以修改，因此是可信的。B 和 C 看到恶意用户出示 A 的公钥后，会去查区块链对应的公钥信息，即对应的余额，看是否有足够的钱支付本次转账，如果足够，那么这次交易就是安全的，这样，哪怕恶意用户不是 A，但他出示的公钥在区块链上的确有足够的余额，那就没问题。</p><p>因此，区块链只认公私钥对，只要交易时有足够的余额，那么交易就可以促成，是不是 A 也就无所谓了。</p><p>上面的文字，如果画成图形，那么看起来就是这样：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-deal-verify.svg" alt="交易时，需要校验身份和资金来源"></p><p>简单来说，就是每次交易，都需要能完成以下重要步骤：</p><p>1、出示付款发公钥和收款方的公钥；</p><p>2、付款方的公钥在区块链中能被找到；</p><p>3、在区块链中对应的付款方公钥下的余额足够支付本次交易；</p><p>4、付款方的公钥能验证交易签名。</p><p>校验通过后，交易信息将被写到区块中，交易就正式生效。如果此后 B 要转账给 D 和 E，那么同样也会进行上面的操作，画成图形，看起来像这这样：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-deal-verify-another.svg" alt="再一次交易"></p><p>由此可见，每一次交易，都有输入和输出双方，每一个输入都是上某次的输出，每一个输出都是下某次的输入，这样就保证的“输入 &#x3D; 输出” ，账目是平的。</p><h2 id="记账权的争夺——共识机制"><a href="#记账权的争夺——共识机制" class="headerlink" title="记账权的争夺——共识机制"></a>记账权的争夺——共识机制</h2><p>以上，当然会有不少问题，即，因为任何人都可以往区块链写入交易数据，那么，</p><p>1、到底谁去做这个写入操作呢？</p><p>2、如果大家都写，那么势必会造成数据不一致，如果数据不一致了，那么又怎么做到以谁写入的为准呢？</p><p>3、如果有恶意用户争夺到写入权但拒绝写入某个交易从而使某个人无法完成交易怎么办呢？</p><p>这里就需要获得写入权的争夺了。在上一节讲到，区块头部有两个字段，一个是“目标难度值”，即 target，一个是随机字符串，即  nonce，它们就是用于控制记账权争夺的。</p><p>其算法思想如下：为了获取记账权，必须找到一个 nonce值，使得头部的 sha256 值小于 target。由于找到这样一个 nonce 值计算出的  sha256 需要枚举 nonce，因此对争夺记账权的 就依赖于争夺者的算力，算力越高，获得记账权的机会就越大。</p><p>这种依赖算力而不依赖投票的算法，我们叫做比特币的共识机制，它有一个好处就是规避了恶意用户制造大量僵尸账户进行投票影响正常结果的攻击。当然有人会问，如果恶意用户有很强的算力怎么办，要知道，算力很高的用户意味着有很强大的计算机系统，绝非个人所能做到，而拥有强大计算机系统的用户都是希望系统稳定的，就好像一个有权势的国王，他肯定是希望他的国家泰平，不然他自己也就当不成国王了，所以，需要算力极强的计算机系统用户才能写入区块链，保证了区块链的稳定，单个恶意用户是无法撼动区块链的。</p><p>总之，只要找到了 nonce，满足 sha256(区块链头部) &lt; target，那么这个用户就可以写入区块链，他就会把结果广播给其它全节点。其它节点很快就可以验证他的结果，从而接受他的写入结果。</p><h2 id="铸币交易"><a href="#铸币交易" class="headerlink" title="铸币交易"></a>铸币交易</h2><p>前面提到，交易的时候，算力高的用户会写入区块链，一般都是算力高的用户，他们绝非等闲之辈，因为能有这么高算力的人，现实中肯定也是很有能力的（不管是金钱还是权利），他们希望区块链系统稳定，以获取更多的好处，这个好处之一，就是铸币权。</p><p>铸币权就是每次写入交易时，都可以收取交易的手续费和创造出额外的货币，这类似中心化的央行印钱。手续费不用说，额外的货币即每次都可以往区块链的池子里加更多的余额，这个余额不需要像转账那样通过上一次的输出获得，而是直接创造出来，只需要记录记账者本人的公钥和余额即可。像比特币的规则，初始阶段，每次写入交易都可以创造出 50 个比特币，而后每 21 万个区块后则减半，即只能创造出 25 个比特币了，然后如此循环递减，直至为 0。</p><p>这就是区块链货币创造货币的规则。可见，区块链中主要有两种交易，一个是前面提到的转账交易，一个就是这里说的铸币交易。</p><h2 id="区块链的分叉"><a href="#区块链的分叉" class="headerlink" title="区块链的分叉"></a>区块链的分叉</h2><p>前面说了通过算力来解决争夺的两个问题（记账权提出的 1 和 3 问题），问题 2 如果有两个算力都很强大的用户都算出 nonce，都往区块链中写怎么办？</p><p>一种情况，是往中间写，例如下图中，红色节点也是一个找到对应 nonce 值的节点，也打算往区块链中写入，但它的前置节点是在区块链的中间而不是末尾，按照记账权的规则，它是有权写入的，但又很明显，如果允许红色节点写入，那么原本黄色节点后面的蓝色节点将会失效，这对于已经确认交易的用户来说是不可接受的。</p><p><img src="https://www.jackhuang.cc/svg/blockchain-fork.svg" alt="区块链的分叉"></p><p>对于这种想在中间插入的动作，由于其比较短，因此会被认为是孤儿节点（orphan block），这样的孤儿节点是不会被接受的。采用最长的分叉区块链是防止恶意用户插入恶意节点的方法。那么等长的插入呢？即同时都想往区块链中的最后一个节点插入新的区块，比如下图两个红色节点都想往最后一个黄色插入：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-fork-end.svg" alt="等长区块插入"></p><p>此时就属于分布式事务中的未决事务，即只能同时存在两个交易数据，那么什么时候能解决这个分叉呢？一般认为，某一个分叉后有超过 6 个区块节点，则认为另一个分叉的区块无法再超越它，因此短的分叉将会被大家舍弃掉（这种结论，是基于概率学得出来的，实际上，世界上没有 100% 能保证事务最终一致的设计，或者说数学上无法证明某个算法设计能 100% 保证数据最终一致，但实际经验告诉我们反超概率趋近于 0 的设计是可靠的），因此，区块链交易时，收入方会等待 6 个节点确认写入（只需要一小时的时间，因为区块的写入难度控制在每 10 分钟一个区块）或 T + 1日后，即保证交易已经写入区块链中且有了足够长的深度才会放心发货给出款方，这种在交易数额很大的时候会比较常见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要讲区块链的交易协议细节，即一笔交易是如何写入区块链的交易数据中的。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链（一）：基本结构</title>
    <link href="https://www.jackhuang.cc/2023/02/12/block-chain-basic/"/>
    <id>https://www.jackhuang.cc/2023/02/12/block-chain-basic/</id>
    <published>2023-02-12T12:47:38.000Z</published>
    <updated>2023-02-17T17:39:47.388Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们就开始总结一下区块链方面的知识吧，从最基本的区块链结构讲起。</p><span id="more"></span><h2 id="区块链基本信息"><a href="#区块链基本信息" class="headerlink" title="区块链基本信息"></a>区块链基本信息</h2><p>顾名思义，区块链，即一个个块连接起来的链表，但的确加了不少附加信息在上面，我们先看三个最基本的信息：</p><p>1、创世区块；</p><p>2、区块的高度；</p><p>3、区块链难以修改的特性。</p><p>我们先直观的看一下区块链的样子吧：</p><p><img src="https://www.jackhuang.cc/svg/blockchain-first-view.svg"></p><p>我们最先看到的是这是一个链表，但要注意，这个链表的增长方式是从创世区块开始的，也就是区块链和普通链表不一样，是反向增长的，即新增的区块指向最后一个区块，第一个区块是图中的创世区块。</p><p>创世区块是一个很特殊的区块，它一般硬编码在代码中，万事总是要有一个起头，所以创世区块作为区块链的头，要特殊编码，再往后，每一个区块的加入都必须遵循区块链的规则了。</p><p>区块中会分为区块头和与之相关的区块交易体，我们先关注一下区块头。可以看到每一个区块都有一个区块头，即上图红色框框部分，其中一个字段是前一个区块头的sha256结果，也即，每一个区块的标识符都用区块头的sha256来表示，这个结果会写在下一个区块的区块头的字段中，这样，这些区块就组成了一个有序且难以更改的区块链了。</p><p>有序，是因为每一个区块的头部字段都记录前一个区块的头部sha256，因此区块顺序不能变。</p><p>难以修改，是因为区块头一旦被修改，那么其sha256也被跟着改，也即区块的标识符被修改，这会影响下一个区块的区块头内容，也就导致下一个区块的标识也要修改，于是如此串联下去，一处改则处处改。随着区块的增多，修改难度会越来越大，这也就是难以修改的原因。也可以看出，越是古老的区块，修改的难度越大。</p><p>尾部的区块它的头部sha256值，也即其标识符可以保存起来，这样，我们就可以验证整条区块链是否有被修改。例如轻客户端（比如手机）很难去保存所有的区块，但它又想验证最近几个区块是否被修改，这样只需要从全区块链那里获取最近几个区块的头部，然后验证区块链标识是否和所持有的区块链标识是否相等，即可知道这些区块是否被修改，是否信得过了。</p><p>最后讲一下区块链的高度，区块链的高度即区块的多少，当然要注意，创世区块的高度是 0，也就是说，如果有 n 个区块，那么其高度是 n - 1。我们引用一个区块时，除了可以用它的标识符以外，还可以用它的所处高度来表达。例如高度为 0 的区块即创世区块。</p><h2 id="区块头部"><a href="#区块头部" class="headerlink" title="区块头部"></a>区块头部</h2><p><img src="https://www.jackhuang.cc/svg/blockchain-head.svg" alt="区块头部"></p><p>上面的头部是被我们简化的，区块链的头部不仅仅有前块标识字段，还有其它字段，我们放大看看：</p><p>首先是版本，似乎没什么可说的。</p><p>接着就是前面提到的前块区块的头部 sha256，即其区块标识。</p><p>默克尔（merkle）值，是用于检验交易数据的，我们马上讲到。由于有了默克尔值，后面的交易数我们就可以校验，这样我们标识一个区块的时候只需要头部sha256即可，并不需要整个区块 sha256。</p><p>随机难度值和随机数是用于挖矿的，我们将来讲到。</p><h2 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>当我们有很多交易数据时，我们怎么校验它们是否被修改信得过呢？一种直观的方法当然是把它们放在一起然后算一次 sha256，如果有 n 个交易，那么算法时间和空间复杂度为 O(n)。</p><p>默克尔树提供了一个更快更省空间的方案，即将每一笔交易数据做一次 sha256（比特币中是连续计算两次 sha256，以下简称算 sha256 不特地强调），然后这些结果两两做一组再算一次 sha256，再两两做一组算 sha256，如此循环，最后只剩下一个 sha256 值，这个值就是默克尔树根值，有了这个值，我们就可以很快的校验交易是否被修改。其计算过程和结构如下：</p><p><img src="https://www.jackhuang.cc/svg/merkle-tree.svg" alt="默克尔（merkle）树"></p><p>从上面看出，默克尔树树叶节点即我们的交易数据，往上每一层都是下一层数据两两结合计算 sha256 的结果，直到我们算出默克尔树根为止。</p><h3 id="校验交易"><a href="#校验交易" class="headerlink" title="校验交易"></a>校验交易</h3><p>我们需要校验某个交易是否被修改时，尤其是手机这种轻节点，只需要从全节点处拿到从下往上算的路径上的 sha256 节点即可去验证某个交易是否在这个区块中或者是否被修改过。</p><p>例如我们需要计算下图红色节点是否在区块交易数据中，轻节点只需要请求全节点下发黄色 sha256数据给它，它依次从下往上计算出蓝色节点的 sha256 值，直至计算出默克尔树树根值，对比区块头的默克尔树根值是否一致就可以知道交易是否在此区块中（区块头的sha256 我们是由区块标识符保证不被串改的，前面已经讨论）。</p><p><img src="https://www.jackhuang.cc/svg/merkle-tree-verify.svg" alt="默克尔树校验交易过程"></p><p>由于不需要全节点所有的交易数据，此时算法复杂度和空间复杂度只有 O(log<sub>2</sub>n) 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们就开始总结一下区块链方面的知识吧，从最基本的区块链结构讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://www.jackhuang.cc/categories/Blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 异步编程（一）：基本概念和编程模型</title>
    <link href="https://www.jackhuang.cc/2023/02/10/rust-futures-basic-concept/"/>
    <id>https://www.jackhuang.cc/2023/02/10/rust-futures-basic-concept/</id>
    <published>2023-02-10T15:41:58.000Z</published>
    <updated>2023-02-12T08:10:15.579Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 的异步编程内容太庞大了，从最基础的 futures，到各种第三方库，都有很多内容可讲，今天开始，Rust 编程会聚集到异步编程上，当然，异步编程不仅仅是异步，实际也会涵盖比如网络编程等方面。现在，先来个最基础的开胃菜，基本概念和简单的异步编程。</p><span id="more"></span><h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>现在的服务器操作系统都是多任务可打断式的，即多个任务同时在跑，任务之间会争夺CPU和内存资源。操作系统会有一套算法来调度这些任务，Linux 系统中最经典的就是公平调度算法，算法的思想很简单，就是每次总是运行获得CPU时间最小的那个任务。</p><p>那么什么时候触发这个调度算法呢？有两个时间点：</p><p>1、周期性的调度；即操作系统总是周期性的做一些事情，这个是不可打断的，比如周期性的更新系统时间，周期性的看看IO是否OK，当然也就包括周期性的执行任务的调度算法；</p><p>2、系统调用的时候；即用户态在调用系统调用的时候，会陷入内核态，内核态除了完成用户态的请求，还会执行一次任务调度。</p><p>周期性的执行是不可打断的事情，属于实时调度，这方面我们的进程作为用户态的程序，一般没有机会去优化。</p><p>但系统调用却是靠我们用户态的程序来触发的。所谓系统调用，就是调用操作系统的原生接口，比如sleep，poll等，也就是说，如果我们的程序调用系统调用，会触发一些列的操作系统操作：</p><p>1、切换上下文到内核态；</p><p>2、完成用户态请求；</p><p>3、进行任务调度；</p><p>4、切换上下文回到用户态。</p><p>可能还有其它更多的事情，因此，系统调用代价是很大的。如果有两个线程，那么这两个线程的争夺将触发一系列的代价。</p><h2 id="IO密集型和CPU密集型任务"><a href="#IO密集型和CPU密集型任务" class="headerlink" title="IO密集型和CPU密集型任务"></a>IO密集型和CPU密集型任务</h2><p>我们从系统资源的角度去看线程任务的话，那么主要分为两种：IO 密集型任何和CPU 密集型任务。前者主要会有大量的 IO 操作，因为需要 IO，因此会产生大量的系统调用，比如 read，write，accept 等等，按前面所说，这里将有巨大的上下文切换代价；后者则主要占用 CPU 资源，几乎没有系统调用，但会有大量的应用代码，比如 for， while ，loop，以及对 cache 对内存的频繁访问。</p><p>因此，分离 IO 密集型的任务和 CPU 密集型任务到不同的线程，就有助于提高线程的执行效率，比如一个请求，需要算一算，再读一下DB，最后再算一算，再返回给客户端，一共四个步骤，如果我们按照 IO 密集型和 CPU 密集型任务分离，那么就是两类操作，即读 DB 和返回客户端是 IO密集型任务，算一算则是 CPU 密集型任务，我们的思路是：遇到 IO 任务，则挂起，去做别的事情，保证我们的工作线程跑满 CPU，这样分离后，CPU 利用率就能极大提高，而且，因为遇到 IO 任务，我们去做别的事情不是线程切换，而是应用层的一种调度，这样减少了上下文的切换，减少了系统调度的代价。</p><h2 id="Rust-的异步trait库——futures"><a href="#Rust-的异步trait库——futures" class="headerlink" title="Rust 的异步trait库——futures"></a>Rust 的异步trait库——futures</h2><p>futures 库提供了最基本的上面说的任务模型最基本的trait，官方文档中给了一个比较复杂的例子（其实不复杂，但对于最初的学习者来说，可能会遇到大量的信息应付不过来，工程上，已经有很成熟的 tokio 库实现，这个库以后再讲，我们先把底层原理学清楚），我这里打算从一个更简单的例子开始慢慢演化成 Rust 官方文档案例的样子，有助于理解。</p><p>其实，Rust 的 futures 库并不完整，更多是在定义一个 trait，虽然给了一些实现宏，但还是留有大量的空间给我们去实现，好在第三方库tokio 给出了很好的实现，但正如官方文档所说，你的确可以直接去学习那些库的用法，但最后总是要回过头来了解，futures 库做了什么，或者说定义了什么，Rust 期待的异步模型是什么样子的，这些底层原理还是要搞懂的。</p><p>不像官方文档直接拿出futures trait做例子，这一节，暂时不细讲 futures trait 都定义了什么，我们先把最基础的异步模型讲清楚，再引入 futures trait ，以及其它更多概念，这样，我们先引入一个基本模型，然后再逐个引入各种概念（比如futures trait）从而理解引入的概念解决了什么问题，或者用于做什么的，这样比官方文档直接把大量概念加入进来更容易理解。</p><p>为了更简单更容易理解，我的例子甚至不使用网络库，文件库这些 IO 库，只留下最精简的模型代码，这样我们可以完全聚焦在异步编程模型上，后面我们再加入 IO 库，从而理解 IO 任务和 CPU 任务分离模型基础。</p><p>当我们把这些事情都完全展现出来后，再去看 tokio 库，就有了然于胸的感觉了。</p><h2 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h2><p>异步编程最经典的模型就是生产者和消费者模型，它的原理非常简单：即生产者生产消息，消息放入队列，队列的消息先进先出，因此消费者在队列另一头读出消息然后处理。把这个模型套到上面提到的 IO 任务和 CPU 任务上，那就是，生产者是 IO 任务，而 消费者是 CPU 任务，中间用队列通信，当 CPU 任务遇到 IO 时因为要被阻塞了，因此，会把任务放回队列中，待下次调度，自己会去做其它的CPU任务，用一张简单的图画出来就是这个样子：</p><p><img src="https://www.jackhuang.cc/svg/basic-async-task.svg" alt="基本生产者消费者模型"></p><p>这个模型中，除了 IO 线程会陷入内核态（因为需要调用系统的 IO 接口，属于系统调用），其它地方一般不会再有系统调用，至少不会再有明显阻塞式的 IO 系统调用，保证了 CPU 线程再各个任务间切换时，没有系统调用产生的上下文切换代价。</p><p>那么我们就开始实现这个最基本的模型吧。当然我这里不是实现一个通用的生产者消费者异步处理库，因此代码会比较偏硬，属于教学代码，我们重点放在模型的理解，以及后续各个概念引入时我们可以很方便的理解这些东西的作用，或解决了什么问题。</p><h3 id="Rust-的消息队列模型"><a href="#Rust-的消息队列模型" class="headerlink" title="Rust 的消息队列模型"></a>Rust 的消息队列模型</h3><p>Rust 提供了原生的消息队列模式，这个在之前提到过：</p><p><a href="https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/#channel">https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/#channel</a></p><p>这里我们打算使用 sync_channel。sync_channel 和 channel 都是用于实现生产者消费者模型的，不同之处是：</p><p>1、channel 的队列是“无限”大的，当然不可能是“无限大”，因此为了限制队列的大小，应该使用 sync_channel，它接受一个参数，若队列满了，那么 send 会被阻塞；由于 channel 的队列 “无限大”，因此理论上 send 是不会被阻塞的。</p><p>2、而sync_channel 维护了一个 buffer 队列，接受一个参数控制队列大小。参数可以是 0，当参数为 0 的情况下，send 会被阻塞，知道receive 取走消息。因此，sync_channel 的send 是会被阻塞的。</p><p>我们实现生产者消费者模型，就是利用 sync_channel 来为我们维护中间的消息队列。</p><h3 id="async-函数和-wait调用"><a href="#async-函数和-wait调用" class="headerlink" title="async 函数和 wait调用"></a>async 函数和 wait调用</h3><p>这里，我们开始引入第一个 Rust 异步编程概念，即 async 函数。函数这个概念我们很熟悉了，函数前面加上 async 关键字相当于表示，这个函数会被异步调度执行。</p><p>记住，是异步调度执行，即：函数不会马上执行，是由我们调度后才能执行，举个简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">print_helloworld</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fut</span> = <span class="title function_ invoke__">print_helloworld</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = fut.<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;return: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看第一行，是一个函数，打印 hello world 后返回一个 hello world 字符串，和之前不同的是，函数前面有一个 关键字 async。先暂时不管它，往下看，第 7 行，来了一个 block_on 调用，这是因为所有的异步编程都必须用异步的方式调用，而main 函数是同步函数，那么异步和同步函数之间，必须用像 block_on 这样的同步函数连接，实际上 block_on 帮我们做了一件简单的事情：即等待异步调用结束，避免异步调用还未结束 main 函数就退出了，这样进程就没有了。</p><p>block_on 中有一个 async 块，表示里面的代码将会是异步执行的，可以看到，里面调用了 print_helloworld，但实际上，因为是异步执行，此时 print_helloworld 并没有执行，至于什么时候触发呢？就是第 9 行的 fut.await。</p><p>但 print_helloworld 不是返回一个 String 吗？String 没有 await 字段。这就是 async 的作用，当函数前被加上 async 后，函数的返回值会变成—— future，future 封装了返回值和一些特性，但之前说了，这一节我们暂时不深入到 future，这一节，我们关键去理解生产者消费者模型，此处，我们只需要认为， async 的 出现，使得函数返回值变成了future，而 future 封装了函数的返回值就行。</p><p>future 提供了一个 await 调用，我们一旦调用 await 函数就会被触发执行，正如第 9 行那样，它将会触发 print_helloworld 的执行。await 的返回值就是函数的返回值。</p><p>网上看到很多疑问，就是这并不是异步执行啊，只是单个线程延迟执行了函数而已，类似闭包。</p><p>的确如此，我们并没有开启多线程，一个线程怎么可能会异步执行呢？Rust 没有这种魔力。所以这里我就要提醒一下我已经说的话：</p><p>1、Rust 没有完全实现异步调用模型，它留下了很多空白，tokio 库补上了；这里的 asyn 和 await 只是提供了能异步调用某个函数的能力，并不是实现了异步调用。</p><p>2、想异步执行函数，需要生产者消费者模型，async 和 await 只是给生产者和消费者模型提供了语言上的工具，剩下的我们还是需要自己去实现，当然，tokio 已经为我们实现很多常用场景了，我们后面再说，现在我们需要做的是：理解 Rust 提供的 async 和 await 做了什么即可，后面我们将会看到，它们在生产者消费者这个异步模型中的作用。</p><p>运行上面的代码，程序会按照调用顺序打印出两个hello world：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line"><span class="keyword">return</span>: hello world!</span><br></pre></td></tr></table></figure><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>有了消息队列和 async&#x2F;await 特性，我们可以去实现生产者消费者模型了。其思路是：创建一个任务类Task，Task 封装 上面提到的future，因此，我们的生产者生产 Task 对象，放入队列，消费者从队列取出 Task 对象，然后调用 await 执行，就是这么简单，往后我们会把这个模型引入更多概念和做法，最终理解整个 Rust 异步编程都有什么内容，现在，就从这个简单的模型开始吧。</p><p>我们先说一下我们的任务：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;T&gt; &#123;</span><br><span class="line">    fut: Mutex&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Task&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(f: BoxFuture&lt;<span class="symbol">&#x27;static</span>, T&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            fut: Mutex::<span class="title function_ invoke__">new</span>(f),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，任务只有一个字段 fut，即我们之前提到过的 future，它有await字段可以触发函数的执行。其中，Mutex 我们已经很熟悉，而 BoxFuture&lt;T&gt; 是 Pin&lt;Box&lt;T&gt;&gt;  的 type 别名。Box 我们也很熟悉了，但 Pin 是什么呢？现在我们简单理解 Pin 是帮我们实现内存拷贝的一个辅助结构，后面我会提出一个问题，并用 Pin 解决它，那个时候就很好理解了，总之我们现在还是先聚焦在生产者消费者模型吧。</p><p>总之，Task 是一个任务，它的 fut 保存着 async 函数，在 CPU 线程中等待 await 的调用。我们的生产者会生产 Task 对象，即调用上面的 new 方法，然后 send 到队列中，等待消费者调用 await 实现异步。泛型 T 是函数的返回值，用于限定 let x &#x3D; fut.await; 中的 x 类型的。</p><h3 id="将要被异步调用的函数"><a href="#将要被异步调用的函数" class="headerlink" title="将要被异步调用的函数"></a>将要被异步调用的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_hello</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_world</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">say_bye</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写出三个简单的将要被异步调用的函数，函数非常简单，没有 IO ，还是那句话，我们本节聚焦生产者消费者模型的实现。</p><p>这三个函数将会返回 future，他们将会被传入三个 Task 对象中去，然后进入队列，等待消费者线程异步拉起 await 调用。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">excutor</span>(queue: Receiver&lt;Task&lt;<span class="type">String</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">           <span class="title function_ invoke__">Ok</span>(task) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r</span> = task.fut.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_mut</span>().<span class="keyword">await</span>;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;await return: &#123;&#125;&quot;</span>, r);</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="title function_ invoke__">Err</span>(_) =&gt;  &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行器是我们这次又引入的一个概念，它的任务就是执行消费者要做的事情，甚至可以起名叫消费者都可以，但有些框架，会在执行器中spawn 出新的线程去跑逻辑，逻辑被 IO 阻塞的时候才返回给执行器并通知 IO 线程处理，等待任务重新进入队列被调度。</p><p>我们这次这个例子很简单，不去起新的线程，直接在执行器中从消息中取出任务，拿到 future 对象后调用 await 执行函数，当三个函数都被执行后则退出。</p><p>可以看到执行器函数也是 async 的，之前也说了，async 函数才能调用 另一个asyn 函数，因为我们饿 future 已经是 async的了，所以我们的执行器也必须是 async 的。</p><h3 id="main函数的实现"><a href="#main函数的实现" class="headerlink" title="main函数的实现"></a>main函数的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">let</span> (sender, queue) = sync_channel::&lt;Task&lt;<span class="type">String</span>&gt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个即将被异步调用的函数，其返回 future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello_fut</span> = <span class="title function_ invoke__">say_hello</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world_fut</span> = <span class="title function_ invoke__">say_world</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bye_fut</span> = <span class="title function_ invoke__">say_bye</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个Task，存放之前三个函数的future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = Task::<span class="title function_ invoke__">new</span>(hello_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = Task::<span class="title function_ invoke__">new</span>(world_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t3</span> = Task::<span class="title function_ invoke__">new</span>(bye_fut.<span class="title function_ invoke__">boxed</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下创建三个生产者线程，用以模拟多个IO生产的数据操作</span></span><br><span class="line">    <span class="comment">// 第一个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender1</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender1.<span class="title function_ invoke__">send</span>(t1).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender2</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender2.<span class="title function_ invoke__">send</span>(t2).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个生产者线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender3</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender3.<span class="title function_ invoke__">send</span>(t3).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消费者工作，从队列中取出Task，触发await</span></span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">excutor</span>(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是 main 函数做的事情，注释已经写得很清楚，我们实现了一个简单的生产者消费者模型，这是最简单最基本的异步编程模型，利用了 Rust 以下特性：</p><p>1、消息队列；</p><p>2、async&#x2F;await 调用；</p><p>3、future trait；</p><p>4、线程函数。</p><p>这个模型非常简单，也因此，其实有很多地方可以讨论，有很多问题待解决，因此我们在后续的文章中会对这个模型提出一些问题，从而引入更多细节的东西解决这些问题，最终理解 Rust 异步编程。</p><p>下一节，我们首先讨论是：future 到底是什么？我们将聚焦 future，看看 future在这个模型中扮演的角色，解决了什么问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 的异步编程内容太庞大了，从最基础的 futures，到各种第三方库，都有很多内容可讲，今天开始，Rust 编程会聚集到异步编程上，当然，异步编程不仅仅是异步，实际也会涵盖比如网络编程等方面。现在，先来个最基础的开胃菜，基本概念和简单的异步编程。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>如何构造自定义错误类型和向下转化</title>
    <link href="https://www.jackhuang.cc/2023/02/05/rust-my-error/"/>
    <id>https://www.jackhuang.cc/2023/02/05/rust-my-error/</id>
    <published>2023-02-05T07:02:44.000Z</published>
    <updated>2023-02-05T07:02:47.727Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 所有的错误都是实现了 std::error::Error 这个trait，因此我们只要也实现这个 trait 就可以自定义自己的错误类型了。</p><span id="more"></span><h2 id="实现自定义错误"><a href="#实现自定义错误" class="headerlink" title="实现自定义错误"></a>实现自定义错误</h2><p>那么怎么实现 Error 这个 trait呢？实际上并不需要实现这个 trait 的太多方法，只要有 Debug 这个 trait 就行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyError</span>(<span class="type">u32</span>, <span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Error</span> <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了 MyError，绑定了 u32 和 String 两个变量，用于记录错误码和错误信息。下面的 impl Error for MyError 我们不实现任何方法，Debug trait 都已经有了。</p><p>接下来我们有必要实现 std::fmt::Display 这个 trait，因为大多数标准库的错误都支持 to_string 方法，方便日后我们打印错误 log：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;error code = &#123;&#125;, error message = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">make_my_error</span>(error_code: <span class="type">u32</span>, error_message: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">MyError</span>(<span class="number">999</span>, error_message.<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，除了实现 Display trait，我们还提供了一个静态方法，方便生成错误对象，不用每次去敲Box::new  这种代码。这样我们的自定义错误就做好了，可以写个函数测试一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_error_happen</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(MyError::<span class="title function_ invoke__">make_my_error</span>(<span class="number">999</span>, <span class="string">&quot;some error happen&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解统一错误处理"><a href="#理解统一错误处理" class="headerlink" title="理解统一错误处理"></a>理解统一错误处理</h2><p>前面说了，标准库的所有专属错误都是实现了 std::error::Error ，因此，我们也应该遵守这个规则，方便则任何时候都可以统一的进行错误处理。</p><p>此外，标准库大多数时候也都是使用 Result&lt;T, E&gt; 来表示方法或者函数返回值，正常则放在 Ok(T)，异常则放在 Err(E)，这里的 E 一般就是 Box&lt;dyn Error&gt;。因为，异常需要脱离函数范围在外部处理，所以错误对象需要 Box 存放，然后各个不同的库都有自己的错误定义，统一的是都实现 std::error::Error trait，因此 Box 需要处理的是 dyn Error，即运行时 dispatch。我们以后也应该遵守这个守则，方便统一进行错误处理，即返回值应该是：Result&lt;X, Box&lt;dyn Erro&gt;&gt; 。</p><h2 id="向下转化"><a href="#向下转化" class="headerlink" title="向下转化"></a>向下转化</h2><p>前面说我们返回出去的时候是 Error 这个 trait，那么，我们怎么获得具体的实际类呢？这就涉及到一个向下转化的问题。有两种方法，一种是直接用原始指针进行强行转化，这个是属于 unsafe 的过程，不建议这么干：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">some_error_happen</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = &amp;result &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in raw, error code: &#123;&#125;, error message: &#123;&#125;&quot;</span>, </span><br><span class="line">                    (*(e.<span class="title function_ invoke__">deref</span>() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">dyn</span> Error <span class="keyword">as</span> *<span class="keyword">const</span> MyError)).<span class="number">0</span>,</span><br><span class="line">                    (*(e.<span class="title function_ invoke__">deref</span>() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">dyn</span> Error <span class="keyword">as</span> *<span class="keyword">const</span> MyError)).<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">down_obj</span> = e.downcast_ref::&lt;MyError&gt;();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(e) = down_obj &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in main, error code: &#123;&#125;, error message: &#123;&#125;&quot;</span>, e.<span class="number">0</span>, e.<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，第 5 到 第 7 行使用了 原始指针的方式去进行向下转化。e.deref() 先获得 &amp;T，也即&amp;Error，然后 as 为原始指针，这里就会产生 unsafe 代码，因此这几行都要包含在 unsafe 中，再从 *const Error 转为*const MyError，即两次 as，第一次转为原始指针，第二次转为向上转化的指针。这些直接错做原始指针的行为都是 unsafe的，毕竟，向上转为是有可能失败的。</p><p>因此，Box 提供了安全的 downcast 方法，如果转化失败，则返回None，否则返回 Some，当然其内部也是用 unsafe 实现的，但我们不必感知，应该推荐用这种方法进行向上转化，如第 11行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 所有的错误都是实现了 std::error::Error 这个trait，因此我们只要也实现这个 trait 就可以自定义自己的错误类型了。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 的高级特性</title>
    <link href="https://www.jackhuang.cc/2023/02/03/rust-advance/"/>
    <id>https://www.jackhuang.cc/2023/02/03/rust-advance/</id>
    <published>2023-02-03T10:57:38.000Z</published>
    <updated>2023-02-05T02:50:34.300Z</updated>
    
    <content type="html"><![CDATA[<p>今天讲一下 Rust 的高级特性。</p><p>包括：</p><p>1、unsafe 代码；</p><p>2、高级trait；</p><p>3、高级类型；</p><p>4、高级函数和闭包；</p><p>5、宏。</p><span id="more"></span><h2 id="unsafe-代码"><a href="#unsafe-代码" class="headerlink" title="unsafe 代码"></a>unsafe 代码</h2><h3 id="使用-raw-指针"><a href="#使用-raw-指针" class="headerlink" title="使用 raw 指针"></a>使用 raw 指针</h3><p>最 unsafe 的行为莫过于直接使用 raw 指针，这时会绕过 Rust 的安全检查，比如经典的不能同时有可变和不可变引用规则，若使用 raw 指针，那么就需要我们很清楚的说，这是 unsafe 代码，Rust 才放心的运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">x</span> = &amp;a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsafe</span> &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;*x = &#123;&#125;, *y = &#123;&#125;&quot;</span>, *x, *y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>类似的还有比如存在两个&amp;mut 引用同一个变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> a[..index], &amp;<span class="keyword">mut</span> a[index..])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;split at 3: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> a, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，split_at_mut 函数最后一行两次 &amp;mut a 会违反引用规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> | <span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">  |                    - <span class="keyword">let</span><span class="symbol">&#x27;s</span> call the lifetime of this reference `&#x27;<span class="number">1</span>`</span><br><span class="line"><span class="number">3</span> |     <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line"><span class="number">4</span> |     (&amp;<span class="keyword">mut</span> a[..index], &amp;<span class="keyword">mut</span> a[index..])</span><br><span class="line">  |     -----------------------^----------</span><br><span class="line">  |     |     |                |</span><br><span class="line">  |     |     |                second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*a` is borrowed <span class="keyword">for</span> `&#x27;<span class="number">1</span>`</span><br></pre></td></tr></table></figure><p>这是因为 Rust 担心两个引用数组所包含的区间会相互覆盖。如果我们告诉 Rust 这个是 unsafe 代码，那么， Rust就会让编译通过并运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(a.<span class="title function_ invoke__">len</span>() &gt;= index);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = a.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(p, index),</span><br><span class="line">         slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(p.<span class="title function_ invoke__">add</span>(index),  a.<span class="title function_ invoke__">len</span>() - index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-unsafe-函数或者方法"><a href="#调用-unsafe-函数或者方法" class="headerlink" title="调用 unsafe 函数或者方法"></a>调用 unsafe 函数或者方法</h3><p>如果一个函数或者方法是 unsafe 的，那么当然我们也必须告诉 Rust 我们知晓这个行为 unsafe，运行吧。</p><h3 id="调用-C-函数也是-unsafe-的"><a href="#调用-C-函数也是-unsafe-的" class="headerlink" title="调用 C 函数也是 unsafe 的"></a>调用 C 函数也是 unsafe 的</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，调用 C 函数的 abs，extern “C” 表示调用 C 函数库。</p><p>当然反过来， C 函数调用 Rust 函数却是 safe 的，这里不展开来说。关于 C 和 Rust 互调以后有机会再说。</p><h3 id="访问静态可变变量也是-unsafe-的"><a href="#访问静态可变变量也是-unsafe-的" class="headerlink" title="访问静态可变变量也是 unsafe 的"></a>访问静态可变变量也是 unsafe 的</h3><p>Rust 中，如果按照存储特性来分，有三种类型：</p><p>const：运行时存放于常量区，非运行时被固化在文件中；const 数据允许出现在任何地方定义。</p><p>static：进程开始后有固定的内存地址；static 数据允许出现在任何地方定义。</p><p>堆栈：堆栈数据则动态分配。堆栈数据则只能在局部中定义。</p><p>这里，若 static 是可变的，那意味着很多地方都可以去访问 static mut，这当然相当于打破了一个变量值允许一个 mut 引用的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> a: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时编译输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |     a += <span class="number">1</span>;</span><br><span class="line">  |     ^^^^^^ <span class="keyword">use</span> of mutable <span class="keyword">static</span></span><br></pre></td></tr></table></figure><p>明确告诉我们，去使用一个 static mut 的变量是不允许的，应该用unsafe：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> a: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-unsafe-trait-也当然是-unsafe-代码"><a href="#实现-unsafe-trait-也当然是-unsafe-代码" class="headerlink" title="实现 unsafe trait 也当然是 unsafe 代码"></a>实现 unsafe trait 也当然是 unsafe 代码</h3><p> 这个调用了 unsafe 函数或者方法一样。</p><h3 id="使用union-也是-unsafe-的"><a href="#使用union-也是-unsafe-的" class="headerlink" title="使用union 也是 unsafe 的"></a>使用union 也是 unsafe 的</h3><p>和 C 一样，Rust 也有union，它是 unsafe的。</p><h3 id="什么时候用-unsafe"><a href="#什么时候用-unsafe" class="headerlink" title="什么时候用 unsafe"></a>什么时候用 unsafe</h3><p>自己能保证没问题的时候，例如上面的 split 数组，很明显，不管怎么样，split 出来的数组都不会相互有空间的覆盖，虽然 Rust 有这方面的考虑，但既然我们能确定不会有，那么我们就告诉 Rust，这个是已知 unsafe 代码，已确保无误。</p><h2 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h2><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 是 trait 的其中特性之一，比如我们有一个 trait 用于表示给人加年龄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中的 item 即某种类型，实现这个 trait 的 struct 来决定它是什么类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">truct Person &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，为什么不用泛型呢？它和泛型区别在于，泛型可以定义多个 Person 实例，而 type 只能一个，比如我们将 AddAge 修改成使用泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in i32&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span>&lt;<span class="type">u32</span>&gt; <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in u32&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age <span class="keyword">as</span> <span class="type">u32</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们可以定义多个 Person::add，根据不同的类型调用不同的 add：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = a.<span class="title function_ invoke__">add</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">u32</span> = a.<span class="title function_ invoke__">add</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">u32</span></span><br></pre></td></tr></table></figure><p>而使用 type 方法，我们就只能定义一种 add 方法了。</p><p>究其原因，还是因为泛型是类型的一部分，所以两个 add 是两个类型，即两个不同的 add 方法。但 type 则只能选其一。</p><h3 id="默认类型参数"><a href="#默认类型参数" class="headerlink" title="默认类型参数"></a>默认类型参数</h3><p>有时我们可以给 trait 的泛型加上默认类型参数，比如上面的例子中， AddAge 这个 trait 大概率就是给 Person 增加年龄，那么，我们可以默认的写出一些代码，使用方只需关心哪个字段是 age 就行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的 T &#x3D; Self 即实现 AddAge 的类型。即默认情况下，使用实现这个 trait 的类型。</p><h3 id="消除相同方法歧义"><a href="#消除相同方法歧义" class="headerlink" title="消除相同方法歧义"></a>消除相同方法歧义</h3><p>如果一个 struct 实现了两个 trait，而这两个 trait 有相同的方法怎么办呢？此时就需要显式的指定调用的是哪个 trait 的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAge</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">AddFamilyName</span>&lt;T = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAge</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddFamilyName</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Huang &quot;</span>) + &amp;<span class="keyword">self</span>.name;</span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add age: &#123;&#125;&quot;</span>, AddAge::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add family name: &#123;&#125;&quot;</span>, AddFamilyName::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AddAge 和 AddFamilyName 都有一个叫 fn add(&amp;mut self) -&gt; Self::item; 的方法，那么，在调用它们的时候，需要显式指定是哪一个的 add 方法，如上面的 39 和 40 行所显示。</p><p>但如果是静态 trait 方法呢？比如这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">AddAll</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>() <span class="punctuation">-&gt;</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AddAll</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">item</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::item &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此时需要使用模板的表达告诉编译器使用 AddAll的 add 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;add all: &#123;&#125;&quot;</span>, &lt;Person <span class="keyword">as</span> AddAll&gt;::<span class="title function_ invoke__">add</span>());</span><br></pre></td></tr></table></figure><h3 id="trait-还可以增加-bond"><a href="#trait-还可以增加-bond" class="headerlink" title="trait 还可以增加 bond"></a>trait 还可以增加 bond</h3><p>可以给 trait 增加 bond 限制实现实体必须满足其它的 trait 才可以实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;from outline print: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，第一行的trait 定义中， OutlinePrint 需要实现实体必须能满足 fmt::Display 输出的trait，但 Person 没有，此时 impl OutlinePrint for Person  会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">19</span>:<span class="number">21</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> | <span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">   |                     ^^^^^^^^^^^^ required by this bound <span class="keyword">in</span> `OutlinePrint`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加上 Display 的实现后（可以用 to_string 方法了）正常编译和运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;i am &#123;&#125; years old and my name is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.age, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给外部-struct-增加-trait"><a href="#给外部-struct-增加-trait" class="headerlink" title="给外部 struct 增加 trait"></a>给外部 struct 增加 trait</h3><p>如果我们想给不受我们控制的 struct 增加 trait 怎么办？简单的方法当然是用一个新的 struct 把它包裹起来，然后用新 struct 增加新 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;*&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">MyString</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更多是一个编程技巧。</p><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="用-type-起个短名"><a href="#用-type-起个短名" class="headerlink" title="用 type 起个短名"></a>用 type 起个短名</h3><p>前面说到了使用 type 可以在 trait 中定义一个类型，留待实现者填上具体类型，和泛型不同，trait 里面的 type 只能实现一个。但这里讲的是 trait 以外， type 的其它用法。</p><p>最经典的莫过于可以给复杂的名字起个简短的名字了；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ArcMutex</span>&lt;T&gt; = Arc&lt;Mutex&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new_arcmutex</span>&lt;T&gt;(t: T) <span class="punctuation">-&gt;</span> ArcMutex&lt;T&gt; &#123;</span><br><span class="line">    Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(t))    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">new_arcmutex</span>(Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在多线程中经常用到多个线程共同所有切需要修改某个对象的场景，当然就需要使用 Arc&lt;Mutex&lt;T&gt;&gt; 这样的 类型，因此为了少打尖括号，使用 type 起个好打出来的名字也挺好，并且封装了 new 函数，省去每次连续打 new 的麻烦。</p><p>在很多标准类库中，也经常看到类似这样的定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, Error&gt;</span><br></pre></td></tr></table></figure><p>这就是说，错误都是 Error，但 Ok 的情况下，返回值和 T 相关，这样错误类型的代码就可以少打一些。</p><h3 id="表示不返回值"><a href="#表示不返回值" class="headerlink" title="! 表示不返回值"></a>! 表示不返回值</h3><p>不返回值表示对某种情况下，不返回任何东西。该如何理解呢？比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="keyword">match</span> x &#123;</span><br><span class="line">            <span class="number">5</span> =&gt; x,</span><br><span class="line">            _ =&gt; <span class="keyword">continue</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，初始化下，x &#x3D; 0，进过 x +&#x3D; 1，x 变为 1，match 后发现不等于 5，于是 continue，此时 match 即不返回任何值，而是回到 loop 开头，a 的值为定义。直到 x &#x3D; 5，a 才赋值为5。</p><p>函数可以声明为没有返回值的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in print something&quot;</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;will panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不能删去 panic!，除非用其它不会让 print_something 返回的函数或者宏代替（比如写一个死循环），否则，只要 print_something 返回，那么就不是 ! 返回值，比如删去 panic!  的话，返回值就是空tuple：() 。</p><p>unwrap 就是这样的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123; <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h3><p>思考一下 &amp;str 的 str，每次用到它的时候，总是加上 &amp;，因为 Rust 在编译的时候无法知道 str 的具体大小，加上 &amp; 后， Rust 只要知道 str 的地址和其长度就行了，地址和长度（usize）都是在编译时就知道其所需内存空间的，因此 &amp;str 就可以编译。</p><p>所以，Box&lt;str&gt; 和 Rc&lt;str&gt;  就不需要加上 &amp;，因为它们是用 unsafe 代码直接使用指针来实现的，指针大小当然也是编译的时候就知道了。</p><p>任何一个泛型，都默认是 Sized trait的，即编译的时候就知道其大小：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，print_something 是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> + <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sized 是默认的 trait，一般情况下都会被省略。那么，我们的确也可以指定一种实际上编译的时候还未能确定其大小的泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T&gt;(t: &amp;T) <span class="keyword">where</span> T: <span class="built_in">Debug</span> + ?<span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(&amp;Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们把 Sized 改成 ?Sized 后，T 就表示一个编译时不能确定大小的泛型了，那么，此时就只能修改成引用类型了（不知道 T 的大小，但&amp;T的大小是可以确定的，即地址是确定的）。</p><h2 id="函数指针和闭包"><a href="#函数指针和闭包" class="headerlink" title="函数指针和闭包"></a>函数指针和闭包</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>之前使用的都是闭包，但实际 Rust 是可以用函数指针的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">multiple2_if_odd</span>(i: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = multiple2_if_odd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_a</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(f).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;new_a = &#123;:?&#125;&quot;</span>, new_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，用闭包似乎更精炼一点。</p><h3 id="闭包也是一个-Sized"><a href="#闭包也是一个-Sized" class="headerlink" title="闭包也是一个 ?Sized"></a>闭包也是一个 ?Sized</h3><p>和 str 一样，闭包也是一个编译的时候并不知道其大小的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_closure</span>()  <span class="punctuation">-&gt;</span> <span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">make_closure</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3 + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">a</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fn（类似的还有FnMut和FnOnce）在编译期间也是不知道其大小的，对于编译器不知道的类型，要么用引用要么用box（或类似容器）来存放即可，这里只能用box（或类似容器，如Rc），因为需要把闭包的生命周期从函数中延长至外部：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_closure</span>()  <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">make_closure</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3 + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">a</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="写一个自己的函数宏（也叫元编程）"><a href="#写一个自己的函数宏（也叫元编程）" class="headerlink" title="写一个自己的函数宏（也叫元编程）"></a>写一个自己的函数宏（也叫元编程）</h3><p>函数宏是 Rust 最复杂的一个概念，即是官方教程，也没有给出很详细的例子，直接说大部分 Rust 程序员都只是使用函数宏而不是创建函数宏，因此没有详细讨论，当然如果真的很想学习 Rust 的函数宏，官方也给出了很详细的教程：</p><p><a href="https://doc.rust-lang.org/rust-by-example/macros.html">https://doc.rust-lang.org/rust-by-example/macros.html</a></p><p>这里只给一个非常简单的函数宏例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;9 + 1 = &#123;&#125;&quot;</span>, my_macro!(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，macro_rules! 即将定义一个函数宏，函数宏名叫 my_macro，后面的大括号就是函数宏要干的内容。函数宏，其实就是匹配参数，匹配中的，就做对应的事情，很像 match，比如上面的代码中，匹配模式即为($a:expr)，expr表示第一个参数表达式，$a 为这个表达式的值，匹配中了，那么就做 &#x3D;&gt; { … } 里面的事情，做什么的呢， $a + 1，即 expr 表达式的值 + 1。</p><p>所以，my_macro!(9) 表达式 expr 为 9，即 $a 为9，也即 9 + 1为10，即 my_macro 函数宏返回 10。</p><p>实现任意参数输入，即反复匹配：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr, $($b:expr), *) =&gt; &#123;</span><br><span class="line">        my_macro!($a) + my_macro!($($b), *)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, my_macro!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即实现任意参数相加，其中 $($b:expr), * 即反复匹配，在第 6 行这个匹配模式中，先拿出第一个匹配出来，剩余的递归匹配，直到为没有参数位置，展开后即各个数相加。</p><p>其输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>符合预期。</p><p>注意最开头的 #[macro_export] 表示这个宏可以导出使用。</p><h3 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h3><p>还记得我们给自己的 struct 加上 #[derive(Debug)] 的宏吗？这个就是过程宏，它帮我们不用写什么代码，直接就实现了 Debug trait，从而可以 println 出来，这就是过程宏。现在我们就写一个自己的过程宏。</p><p>首先新建一个 library，不妨就叫 mymacro 里面简单的定义一个 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">PrintSelf</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_self</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最终要的效果即：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(MyMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>, </span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">print_self</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，只要在我们的 stuct 上加上 #[derive(MyMacro)]，那么就可以实现 PrintSelf trait ，不需要自己写太多代码。</p><p>因此，我们新建一个 library，约定俗成叫 mymacro_drive，在里面，首选要在 Cargo.toml 文件中增加依赖和告诉cargo我们要定义过程宏了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-<span class="keyword">macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">mymacro = &#123;path = <span class="string">&quot;../mymacro&quot;</span>&#125;</span><br><span class="line">syn = <span class="string">&quot;*&quot;</span></span><br><span class="line">quote = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>其中的 syn 库可以解析 Rust 代码，而quote 库可以生成 Rust 代码，在mymacro_drive的 lib.rs 文件中增加以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(MyMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">impl_my_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_my_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">PrintSelf</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">print_self</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;hello, i am &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，#[proc_macro_derive(MyMacro)] 表示定义了一个过程宏 MyMacro，一旦编译器遇到 #[derive(MyMacro)] ，就会调用 my_macro_derive函数。而TokenStream则是编译器解析给我们的 struct 流，syn::parse 则可以读取解析出来内容，内容即为 strut 的属性，第 14 行的quote 宏可以生成 Rust 代码，里面的 15 - 19 行其事是给 quote 生成代码用的，#name 即替代 13行的宏，stringify!(#name) 即转为字符串方便打印。</p><p>重新把代码编程 TokenStream 输出给编译器，编译器即可把 quote 里面的宏内容在使用 #[derive(MyMacro)] 的地方展开，从而少写了 quote 宏里面的代码。这就是过程宏的展开过程。</p><p>类似这样的还有属性宏，即展开后 struct 获得一些字段，还有类函数宏，即自行解析宏里面的代码，比如：</p><p>sql!(select name from table_name where id &#x3D; 3);</p><p>也都是机遇 syn 和 quote这两个库来实现的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天讲一下 Rust 的高级特性。&lt;/p&gt;
&lt;p&gt;包括：&lt;/p&gt;
&lt;p&gt;1、unsafe 代码；&lt;/p&gt;
&lt;p&gt;2、高级trait；&lt;/p&gt;
&lt;p&gt;3、高级类型；&lt;/p&gt;
&lt;p&gt;4、高级函数和闭包；&lt;/p&gt;
&lt;p&gt;5、宏。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>无惧并发</title>
    <link href="https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/"/>
    <id>https://www.jackhuang.cc/2023/01/31/rust-multiple-thread/</id>
    <published>2023-01-31T09:46:41.000Z</published>
    <updated>2023-02-06T01:52:54.235Z</updated>
    
    <content type="html"><![CDATA[<p>前面所有的例子，都是单线程的，现在我们来看看 Rust 都提供了什么多线程能力。</p><span id="more"></span><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>使用 thread 库的 spawn 方法生成一个 thread，其入参是一个closure：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，main 线程结束没等子线程运行完就直接整个线程退出了。</p><h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>所以，我们需要在主线程 join 子线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p> 此时可以保证子线程结束的时候主线程才退出，因为 join 会挂起，直到子线程完成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">5</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">6</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">7</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">8</span></span><br><span class="line"><span class="keyword">in</span> thread: <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="子线程panic"><a href="#子线程panic" class="headerlink" title="子线程panic"></a>子线程panic</h3><p>子线程 panic 是不会影响主线程，也不会影响其它线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;thread panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in thread2: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">handle2.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">1</span></span><br><span class="line">thread &#x27;&lt;unnamed&gt;&#x27; panicked at <span class="symbol">&#x27;thread</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">35</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看到，尽管thread 线程 panic了，但 thread2 和 main 线程并没有停止，依然继续打完了所有数字。</p><h3 id="主线程panic"><a href="#主线程panic" class="headerlink" title="主线程panic"></a>主线程panic</h3><p>主线程的 panic 则会打断所有子线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">     <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">         thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">     <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;in thread2: &#123;&#125;&quot;</span>, i);</span><br><span class="line">         thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">     thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">     <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line"> handle2.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> thread2: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可见，main 线程 panic 会中断所有的线程。</p><h3 id="panic-与析构"><a href="#panic-与析构" class="headerlink" title="panic 与析构"></a>panic 与析构</h3><p>既然 main 线程panic会中断所有线程，那么会影响析构吗？答案是：</p><p>1、若果是 main 线程的对象，不会影响 main 线程的对象析构；</p><p>2、若是子线程的对象，那么子线程的对象析构不会被触发。</p><p>先看看主线程panic的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;person is being destroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">            age: <span class="number">99</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">45</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可见子线程中 Person 的析构没有被调用。但如果 Person 对象是在主线程（不再贴出实现 Drop trait 的代码）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;main panic!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;main</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">46</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">person is being destroyed</span><br></pre></td></tr></table></figure><p>可见，Person 对象的析构被调用，主线程的对象析构没有受到影响。</p><p>那么，如果是子线程 panic 呢？比如子线程 panic，对象也在子线程上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">            age: <span class="number">99</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>));</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;thread panic!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> thread: <span class="number">1</span></span><br><span class="line">thread &#x27;&lt;unnamed&gt;&#x27; panicked at <span class="symbol">&#x27;thread</span> <span class="built_in">panic!</span>&#x27;, src/main.rs:<span class="number">40</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">person is being destroyed</span><br><span class="line"><span class="keyword">in</span> main: <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> main: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可见，子线程 panic，其拥有的对象还是会及时析构。可见 panic 对析构的影响如下：</p><table><thead><tr><th></th><th>对象在主线程</th><th>对象在子线程</th></tr></thead><tbody><tr><td><strong>主线程panic</strong></td><td>对象析构</td><td><font color="red">对象不会被析构</font></td></tr><tr><td><strong>子线程panic</strong></td><td>对象析构</td><td>对象析构</td></tr></tbody></table><h3 id="move-所有权到子线程"><a href="#move-所有权到子线程" class="headerlink" title="move 所有权到子线程"></a>move 所有权到子线程</h3><p>之前在讲 closure 的时候，有说过：闭包只是引用上下文，除非使用 move 否则闭包不会获得上下文对象的所有权。我们启动一个线程的时候，也是使用闭包，但 Rust 的线程闭包如果要 catch 上下文，就必须 move：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;peson in m = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">m</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，闭包 m 不会夺走 p 的所有权，因为它的定义前面没有 move，这样没问题。但线程的闭包却不行，线程的闭包必须获得上下文的所有权（如果线程有使用的话）。因为线程 catch 上下文对象，如果不获得所有权，那么可能会造成悬空指针的问题，因此上面的代码编译报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">36</span>:<span class="number">32</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |     <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">   |                                ^^ may outlive borrowed value `p`</span><br><span class="line"><span class="number">37</span> |         <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">   |                                   - `p` is borrowed here</span><br><span class="line">   |</span><br><span class="line">note: function requires argument <span class="keyword">type</span> <span class="title class_">to</span> outlive `<span class="symbol">&#x27;static</span>`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">36</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">   |  __________________^</span><br><span class="line"><span class="number">37</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;person = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line"><span class="number">38</span> | |     &#125;);</span><br><span class="line">   | |______^</span><br><span class="line">help: to force the closure to take ownership of `p` (and any other referenced variables), <span class="keyword">use</span> the `<span class="keyword">move</span>` keyword</span><br><span class="line">   |</span><br><span class="line"><span class="number">36</span> |     <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |                                ++++</span><br></pre></td></tr></table></figure><p>我们按照编译起的提示，在线程闭包前加上 move 即可正常运行。注意，此时 p 已经失去所有权，主线程后续不能再使用 p。</p><h2 id="信息传递的两种主要方式"><a href="#信息传递的两种主要方式" class="headerlink" title="信息传递的两种主要方式"></a>信息传递的两种主要方式</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>使用 move 方式 显然不是最好的，按 Go 语言的哲学：“Do not communicate by sharing memory; instead, share memory by communicating”。即用复制传递信息，而不是共享的方式传递。 Rust 的 sync::mpsc 库提供了 channel 方式来实现线程直接的消息通讯。mpsc 即 multiple producer single consumer，多生产者单消费者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (sender, recv) = sync::mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = recv.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;receive a person: &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(p).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，首先第 7 行生成了一对 channel tuple，一个是 消息发送者sender，和接受者 recv，然后第 9 行 我们将 recv move 进（因为子线程中使用了recv，但没有使用 sender，因此 sender 还在主线程中）子线程，在子线程中，我们调用 recv 来拉取 sender 给过来的对象。</p><p>注意，sender 是在第 14 行，因此，子线程的 recv 是会阻塞的，直到主线程的 sender 发消息过来。recv 方法返回的是 Result，如果没问题，我们将会在子线程收到 Person 对象，否则则是Err。</p><p>主线程启动子线程后，会使用sender 调用 send 方法将 Person 传递给子线程，此时 recv 会结束阻塞，返回Result，若成功，unwrap 出来则是Person对象。</p><p>注意，Person 对象 send给子线程后，主线程就失去所有权了。</p><p>子线程若不想阻塞，可以调用 try_recv，如果子线程需要周期性的处理一些事情，可以写个循环，try_recv 一次，然后再处理一下其它事情，可以用多 sender 写个例子。</p><h3 id="多sender"><a href="#多sender" class="headerlink" title="多sender"></a>多sender</h3><p>对于 sender，我们可以简单的调用 clone 来获得更多的生产者：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, recv) = sync::mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> recv.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(message) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;receive messge: &#123;:?&#125;&quot;</span>, message);</span><br><span class="line">                &#125;,</span><br><span class="line">                TryRecvError =&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;!&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">m</span> <span class="keyword">in</span> message &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_sender</span> = sender.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        new_sender.<span class="title function_ invoke__">send</span>(m).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第 21 行就是 sender 通过 clone 方法直接创建了多个生产者。接受者则使用了 try_recv 来拉取消息。</p><h3 id="Mutex-lt-T-gt-与-Arc-lt-T-gt"><a href="#Mutex-lt-T-gt-与-Arc-lt-T-gt" class="headerlink" title="Mutex&lt;T&gt; 与 Arc&lt;T&gt;"></a>Mutex&lt;T&gt; 与 Arc&lt;T&gt;</h3><p>前面一节讲过，Rc 和 RefCell 是不能用于多线程的，如果有一个资源需要多线程共享，那么我们就需要 Arc&lt;T&gt; 来进行引用计数，因为它的引用计数是原子的，即 atomic reference count。Arc&lt;T&gt; 和 Rc&lt;T&gt; 是一样的，只是它还能支持多线程使用。</p><p>同样，因为多个线程要修改这个资源，那么就需要 Mutex&lt;T&gt; 去代替 RefCell&lt;T&gt;。Mutex&lt;T&gt; 同样和  RefCell&lt;T&gt; 一样，但还能用于多线程。</p><p>因此，若想实现多个线程同时修改一个资源，那么就需要 Arc&lt;Mutex&lt;T&gt;&gt; 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, sync::&#123;<span class="keyword">self</span>, mpsc::&#123;Sender, RecvError, TryRecvError&#125;, Arc, Mutex&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    title: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">boy</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        score: <span class="number">0</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        title: <span class="literal">None</span>,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score_arc</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;boy);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score_handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = score_arc.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;no person!&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;add the score&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> p.score == <span class="number">8</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;score is up to 8&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.score += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;one year pass&quot;</span>);</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title_arc</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;boy);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title_handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = title_arc.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;no person!&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;check the score&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> p.score == <span class="number">8</span> &#123;</span><br><span class="line">                p.title = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;PhD&quot;</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(title) = &amp;boy.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().title &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the boy get title: &#123;&#125;&quot;</span>,title);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，score_handle 这个线程不停的加分数，title_handle 这个线程不停的检查分数是否达标，若达标，则授予PhD，而主线程则不停的检查 title。</p><p>三个线程都在争夺 Person 对象资源，因此，Person 对象资源放在Mutex中。同时，多个线程需要访问 Mutex，需要对 Mutex 进行引用计数，因此，Mutex 放在 Arc 中。</p><p>其中的 lock 函数将会获得资源，若资源被占用，则线程 阻塞在 lock 函数。lock 函数返回 LockGuard，当超出作用域（即每次 loop 循环）则自动释放 lock，因此，三个线程都在争夺 Person 资源，从输出可以看出的确如此：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">one year pass</span><br><span class="line">add the score</span><br><span class="line">score is up to <span class="number">8</span></span><br><span class="line">check the score</span><br><span class="line">the boy get title: PhD</span><br></pre></td></tr></table></figure><h2 id="注意死锁"><a href="#注意死锁" class="headerlink" title="注意死锁"></a>注意死锁</h2><p>尽管 Rust 已经做了很多防止悬挂指针的操作，但依然还是无法防止运行时的错误，死锁就是这样，因为这个不可能通过编译时就能找出来。</p><p>最常见的死锁就是两个线程户等对象已经持有的锁，比如 A 线程拿着 A 锁等 B 线程释放 B 锁，而 B 线程拿着 B锁等 A 线程释放 A 锁，这样A 和B永远无法解开。</p><p>防止这种死锁发生的关键是，每次使用锁的时候，应该多考虑以下问题；</p><p>1、是否必须加锁不可；实际上，胡乱加锁是出现死锁的重要原因，所以每次想到要加锁，那么就要好好思考：是否有不需要加锁的设计或者现有的锁已经可以满足需求；加锁并不是一件很酷的事情，实际上不到万不得已，就不去加锁。</p><p>2、如果非要加锁，那么对同一个资源的加锁操作需要保证顺序一致，互等死锁的问题就在于两个线程加锁顺序不一致造成的；也可以理一下，为什么访问一个资源要加两个锁？这种设计是否已经出问题？</p><p>3、锁的粒度是否过细；过细的锁很容易造成死锁，当然过粗的锁也会降低并行效率；可以回到第一步好好考虑是否应该加锁。</p><p>4、针对业务逻辑建立标准的生产者消费者模型或者规范可以很好的防止死锁发生。因为模型或者规范一旦建立，我们只需要集中写逻辑就行了，无需再对资源争夺问题想太多，少写危险代码就少点风险。底层的逻辑一旦建立好，就应该依赖或者复用，防止反复踩坑。</p><h2 id="Send-和-Sync-trait"><a href="#Send-和-Sync-trait" class="headerlink" title="Send  和 Sync trait"></a>Send  和 Sync trait</h2><p>Send trait 可以让类型获得可以 send 的能力，Rust 几乎所有的类型都是有 send trait 的除了 Rc&lt;T&gt;。</p><p>Sync trait 则可以让类型获得多线程访问的能力，同样， Rc&lt;T&gt; 也是不能用于多线程的，RefCell&lt;T&gt; 也是，必须用 Mutex&lt;T&gt;代替。</p><p>一般情况下不会去手动实现 Send  和 Sync trait，因为它们是 unsafe 的，而且大部分类型都已经是有这两个 trait了，用它们组合而成的 类型也会带有 Send  和 Sync trait。</p><h2 id="注意-join-方法"><a href="#注意-join-方法" class="headerlink" title="注意 join 方法"></a>注意 join 方法</h2><p>spawn生成一个线程后，其返回值是一个 JoinHandle，我们调用它的 join 方法等待线程结束，需要留意的是，join 方法的入参是 self 而不是&amp;self，也就是说，join 后 handle 会失效。这就会有可能造成悬空指针。</p><p>可见，join 一般是等待线程结束时使用，之后就不应该再去操作线程了。</p><h2 id="多线程下-trait-的-‘static-属性"><a href="#多线程下-trait-的-‘static-属性" class="headerlink" title="多线程下 trait 的 ‘static 属性"></a>多线程下 trait 的 ‘static 属性</h2><p>之前的 move 会把所有权移入线程中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        score: <span class="number">100</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> move会把 p 所有权移入线程，但如果改成移入一个引用就会报错了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    score: <span class="number">100</span>,</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;p;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `p` does not live long enough</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |       <span class="keyword">let</span> <span class="variable">a</span> = &amp;p;</span><br><span class="line">   |               ^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">15</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  __________________-</span><br><span class="line"><span class="number">16</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">17</span> | |     &#125;);</span><br><span class="line">   | |______- argument requires that `p` is borrowed <span class="keyword">for</span> `<span class="symbol">&#x27;static</span>`</span><br><span class="line">...</span><br><span class="line"><span class="number">20</span> |   &#125;</span><br><span class="line">   |   - `p` dropped here <span class="keyword">while</span> still borrowed</span><br></pre></td></tr></table></figure><p> 这个很容易理解，主线程可能已经析构 p，但 a 引用还在，此时就是典型的悬挂指针了。因此这里是不应该允许 move 引用的。改成 template 也会出现同样的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    score: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_print</span>&lt;T, F&gt;(f: F) </span><br><span class="line">        <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">              F: <span class="title function_ invoke__">Fn</span>() <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">some_print</span>(|| &#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            score: <span class="number">100</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面的代码会有以下错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `T` cannot be sent between threads safely</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  __________________^^^^^^^^^^^^^^^^^^_-</span><br><span class="line">   | |                  |</span><br><span class="line">   | |                  `T` cannot be sent between threads safely</span><br><span class="line"><span class="number">14</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> | |     &#125;);</span><br><span class="line">   | |_____- within this `[closure@src/main.rs:<span class="number">13</span>:<span class="number">37</span>: <span class="number">15</span>:<span class="number">6</span>]`</span><br><span class="line">   |</span><br><span class="line">note: required because it<span class="symbol">&#x27;s</span> used within this closure</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">37</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |       <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |  _____________________________________^</span><br><span class="line"><span class="number">14</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> | |     &#125;);</span><br><span class="line">   | |_____^</span><br><span class="line">note: required by a bound <span class="keyword">in</span> `spawn`</span><br><span class="line">help: consider further restricting this bound</span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> |         <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span> + std::marker::<span class="built_in">Send</span>,</span><br><span class="line">   |                                  +++++++++++++++++++</span><br></pre></td></tr></table></figure><p>这里的问题就是出在我们打算把 a move 进线程中时，Rust 需要我们保证 a 有以下能力：</p><p>1、可以 move 的能力，这个需要Send trait；（详见：<a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/marker/trait.Send.html">https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/marker/trait.Send.html</a> ）</p><p>2、保证 a 的生命周期覆盖整个线程生命周期。这个是似乎是显而易见的，但为什么呢？因为 Rust 怕我们把引用给 move 进去了，就好像前一个例子，a 是 p 的引用，此时 move a 到线程中是会出现悬空指针的。解决方案是向 Rust 保证：move a 到线程后，它的生命周期会完全覆盖线程的生命周期，直接点讲，在模板中增加 ‘static trait 意味着此处只能使用实际类型，而不能使用引用类型作为模板。（这里和引用参数中的 ‘static 不一样，引用参数的 ‘static 是说这个引用是固化在常量存储区中的，它随进程的生命周期一起开始和结束）。修改方法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_print</span>&lt;T, F&gt;(f: F) </span><br><span class="line">        <span class="keyword">where</span> T: std::fmt::<span class="built_in">Debug</span> + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">              F: <span class="title function_ invoke__">Fn</span>() <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = std::thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面所有的例子，都是单线程的，现在我们来看看 Rust 都提供了什么多线程能力。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的RefCell容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-refcell/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-refcell/</id>
    <published>2023-01-29T13:43:59.000Z</published>
    <updated>2023-02-05T02:51:15.274Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了Box&lt;T&gt; 和 Rc&lt;T&gt; 两个指针容器，本节要讲的是 RefCell&lt;T&gt; ，和 Box&lt;T&gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&lt;T&gt; 和  Box&lt;T&gt;有什么不一样呢？</p><span id="more"></span><h2 id="RefCell-lt-T-gt-和-Box-lt-T-gt-的区别"><a href="#RefCell-lt-T-gt-和-Box-lt-T-gt-的区别" class="headerlink" title="RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别"></a>RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别</h2><p>Rust 的优点（可能也是别人认为的缺点）就是尽可能的在编译时发现问题，令有可能产生问题的代码编译失败，强迫程序员按照既定的规则写代码，从而保证高质量代码。</p><p>例如，Rust 有一条规则：引用一个资源，要么是可变且只允许一个可变引用，要么是不可变的但可以多个不可变引用，决不允许同时存在对一个资源进行可变引用和不可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会产生失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">10</span> |     <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">   |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">11</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">   |                 ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">12</span> |</span><br><span class="line"><span class="number">13</span> |     <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">   |                                    - immutable borrow later used here</span><br></pre></td></tr></table></figure><p>因为此时 b 是不可变引用，而 c 是可变引用，违反了 Rust 的编译规则。</p><p>Box&lt;T&gt; 当然也遵循这点，编译时期 Rust 也检查：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = a.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第 10 行 b 从Box 那里得到了一个不可变的Person对象引用，这没问题。但 11 行又试图获得一个 可变的 Person 对象引用，这就违反了 Rust 最基本的规则。</p><p>那么 RefCell&lt;T&gt;  呢？当然也遵守，因为一个可变引用和不可变引用同时存在是很危险的，这会导致数据或者逻辑不一致。但其区别就是，RefCell&lt;T&gt; 是运行时期才检查，编译时期是可以通过的，一旦运行时被发现违反了这个规则，程序就会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    y.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Box&lt;T&gt; 和 Rc&lt;T&gt; 不一样，RefCell&lt;T&gt; 不支持解引用操作（*a），必须显式调用 borrow_mut 方法才能获得其封装的 RefMut&lt;T&gt; 对象， RefMut&lt;T&gt; 才支持 Deref trait。出于可读性，这里不直接用 “&amp;*a.borrow_mut() ” 这样的写法，而是依赖  RefMut&lt;T&gt; 的封装，假设 y 就是 &amp;T （实际上是 RefMut&lt;T&gt;，但其表现得像 &amp;T一样）。</p><p>编译上面的代码，不会像 Box&lt;T&gt; 那样出现失败，而是成功编译，但运行到 11行时，会产生 panic，因为 Rust 不允许可变引用和不可变引用同时存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = RefCell &#123; value: &lt;borrowed&gt; &#125;, y = Person &#123; age: <span class="number">100</span>, name: <span class="string">&quot;jack&quot;</span> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;already</span> mutably borrowed: BorrowError&#x27;, src/main.rs:<span class="number">19</span>:<span class="number">15</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>也可以看到，一旦 x 被可变引用了，其 value 状态变为被借用，如果两个不可变引用同时存在，那么一点问题都不会有：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码正常编译且运行无误。</p><p>由此可见，RefCell和Box 本质区别就在于，虽然只能有唯一的所有权方，但前者是运行时期检查引用规则，若有违反，则panic，后者在编译时期检查引用规则，若有违反，则编译失败。</p><p>当然方法的区别也是有的Box 两个获取 T 引用的方法是 as_ref 和as_mut，而 RefCell 的两个方法是 borrow 和 borrow_mut 。</p><h2 id="RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型"><a href="#RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型" class="headerlink" title="RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型"></a>RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型</h2><p>我们可以利用Rc&lt;T&gt;的 clone 方法绕过 Rust 的运行时检查，从而获得同时存在多个可变引用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    y.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    z.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码首先用 Rc&lt;RefCell&lt;T&gt;&gt; 的方式创建了一个对象 x，它终究是Rc，因此，可以利用Rc::clone() 方法又获得一个 y 和 z，然后我们通过点操作直接调用放在 Rc 里面的 Refcell 的 borrow_mut 方法，最终达到了同时多个可变引用的目的。</p><h2 id="RefCell-lt-T-gt-导致的内存泄漏问题"><a href="#RefCell-lt-T-gt-导致的内存泄漏问题" class="headerlink" title="RefCell&lt;T&gt; 导致的内存泄漏问题"></a>RefCell&lt;T&gt; 导致的内存泄漏问题</h2><p>由于我们可以使用RefCell&lt;Rc&lt;T&gt;&gt; 创建这么一种类型：即可变且多引用的类型，那么，如果有两个节点，相互引用，那么它们的 Rc 永远无法到达0，也就无法被析构，最终造成内存泄漏：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Next</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;Node&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> Node::Next;</span><br><span class="line"><span class="keyword">use</span> Node::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(t, _) = <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the node will be drop, &#123;&#125;&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先 x 和 y 都是 Rc，然后它们内部又有指针指向另一个Rc，初始化的时候先都初始化为 Nil，然后通过RefCell&lt;T&gt; 的可变性，把它们都各指向对方，于是，main 函数结束的时候，x 的Rc减 1，但原始值为 2，因为 y 有它的引用，所以 2 - 1 &#x3D; 1，不为 0，x不析构，同理，y 也不会析构，于是内存泄漏了。</p><p>上面的 p 是用于观察正常情况下析构是否进行的。上面的代码输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the node will be drop, <span class="number">999</span></span><br></pre></td></tr></table></figure><p>x 和 y 不会被析构。</p><p>解决方案是引入 weak&lt;T&gt; 。weak&lt;T&gt; 即若引用，相对于强引用，若引用首先并不获得所有权，也就是若引用计数是不是 0 并不影响对象的析构。因此，weak&lt;T&gt; 可能持有一个无效的 T 引用，所以 weak&lt;T&gt; 获取 T 引用的时候是返回的 Option&lt;T&gt; ，如果 weak&lt;T&gt; 已经无效，则返回 None，如果 weak&lt;T&gt; 依然有效，则返回Some(T) 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n <span class="title function_ invoke__">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = t.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">None</span> = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;it is None initially&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;y);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of y is &#123;&#125; and strong count of y is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;y), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;y));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(other) = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;other = &#123;:?&#125;&quot;</span>, other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;x);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of x is &#123;&#125; and strong count of x is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;x), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先第二三行的代码 RefCell::new(Rc::new(Nil)) 被修改为 RefCell::new(Weak::new()) ，可以看到我们直接用了weak::new() 初始化 weak&lt;T&gt; 指针，因为 weak&lt;T&gt; 并不需要主动初始化，它是 Rc 的弱引用，先有 Rc 才能有 weak&lt;T&gt;。</p><p>先略过 5 到 9 行，x 和 y 初始化结束后，我们把 x 和 y 互相指向对方，注意第 12 行没有再使用 Rc::clone，而是 Rc::downgrade，与 Rc::clone 返回 Rc 不同，Rc::downgrade 返回一个 weak&lt;T&gt; 对象（这也是获得一个可能非None的 weak&lt;T&gt; 对象的方法），赋值给了 x 的 weak&lt;T&gt;。同理，y 这边也是这样。</p><p>这样 x 和 y 都相互引用了对方，但由于是弱引用，因此，即是它们相互引用，也不妨碍最后离开 main 函数时被析构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it is <span class="literal">None</span> initially</span><br><span class="line">the weak count of y is <span class="number">1</span> and strong count of y is <span class="number">1</span></span><br><span class="line">other = <span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell &#123; value: (Weak) &#125;)</span><br><span class="line">the weak count of x is <span class="number">1</span> and strong count of x is <span class="number">1</span></span><br><span class="line">the node will be drop, <span class="number">999</span></span><br><span class="line">the node will be drop, <span class="number">2</span></span><br><span class="line">the node will be drop, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，最后 x 和 y 都被析构了，我们也打印了weak count 和 strong count，都是 1， 结束的时候，x 和 y 都是Rc，因此 strong count 减 1，x 和 y 析构。weak count 不管多少，都不影响 Rc 被析构。 </p><p>weak&lt;T&gt; 不拥有所有权，依靠调用 upgrade 来获取 T 引用，upgrade 返回 Option&lt;T&gt; ，若原 Rc 已经被析构，则返回 None，否则返回 Some(Rc&lt;T&gt;)。没有初始化的情况下，则直接返回None。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left"></th><th>Box&lt;T&gt;</th><th>Rc&lt;T&gt;</th><th>RefCell&lt;T&gt;</th><th>RefMut&lt;T&gt;&#x2F;Ref&lt;T&gt;</th><th>Weak&lt;T&gt;</th></tr></thead><tbody><tr><td align="left">所有权规则</td><td>只有一个所有权</td><td>依靠强引用计数实现多个所有权</td><td>只有一个所有权</td><td>只有一个所有权</td><td>依靠弱引用计数实现多个所有权，但实际并不获得所有权，依靠Option&lt;T&gt; 来判断资源是否有效</td></tr><tr><td align="left">什么时候使用</td><td>1、大资源，想减少拷贝的时候；2、实现多态；3、实现栈分配；4、实现无限大小的对象。</td><td>需要多个所有权方时。</td><td>若Box&lt;T&gt;编译时期规则（一个资源同一个时间内，要么只有一个可变引用，要么有多个不可变引用，禁止可变引用和不可变引用同时存在）检查无法满足需求，需要在运行时检查，则可以使用RefCell&lt;T&gt;。</td><td>由RefCell&lt;T&gt;的borrow_mut&#x2F;borrow方法返回，一般不直接使用。一般情况下，用户不感知这个类的存在。可以认为borrow_mut&#x2F;borrow返回的就是对应的资源引用即可。</td><td>由 Rc&lt;T&gt;的downgrade方法返回，相比Rc&lt;T&gt;的强引用，Weak&lt;T&gt;用于弱引用。</td></tr><tr><td align="left">解引用方法</td><td>实现Deref trait 和 Copy trait，即let b &#x3D; *a。</td><td>因为有引用计数规则，不能直接拿走所有权，因此不能直接解引用获取资源，即禁止let b &#x3D; *a，必须通过 Rc::clone 和self.as_ref 方法对资源进行访问。当然写成 let b &#x3D; &amp;*a（这样没有拿走所有权，不违反规则） 也可以，但可读性差。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。应该使用self.upgrade方法（返回Option）判断资源是否有效。</td></tr><tr><td align="left">不可变引用方法</td><td>as_ref</td><td>as_ref</td><td>borrow</td><td>直接点运算操作即可</td><td>upgrade判断返回值Option</td></tr><tr><td align="left">可变引用方法</td><td>as_mut</td><td>不支持，但可以结合 RefCell&lt;T&gt; 实现，即Rc&lt;RefCell&lt;T&gt;&gt;</td><td>borrow_mut</td><td>直接点运算操作即可</td><td>不支持，但可以结合Rc&lt;RefCell&lt;T&gt;&gt;实现。</td></tr></tbody></table><p>注意，以上所有的容器都无法在多线程的时候使用。</p><p>那么，多线程怎么办呢？下面就开始无惧并发的学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了Box&amp;lt;T&amp;gt; 和 Rc&amp;lt;T&amp;gt; 两个指针容器，本节要讲的是 RefCell&amp;lt;T&amp;gt; ，和 Box&amp;lt;T&amp;gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&amp;lt;T&amp;gt; 和  Box&amp;lt;T&amp;gt;有什么不一样呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的Rc容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-rc/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-rc/</id>
    <published>2023-01-29T02:14:33.000Z</published>
    <updated>2023-02-05T02:51:10.214Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了 Box&lt;T&gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&lt;T&gt;了。</p><span id="more"></span><h2 id="使用Rc-lt-T-gt-实现多个不可变资源共享"><a href="#使用Rc-lt-T-gt-实现多个不可变资源共享" class="headerlink" title="使用Rc&lt;T&gt; 实现多个不可变资源共享"></a>使用Rc&lt;T&gt; 实现多个不可变资源共享</h2><p>之前的Box&lt;T&gt;实现了一个如同以下的链表：</p><p><img src="https://www.jackhuang.cc/svg/conforbox.svg" alt="Box\&lt;T\&gt;实现无限链表"></p><p>其代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果串入另一个链表如下，Box&lt;T&gt;就不能实现了，因为Box&lt;T&gt;是只能有一个所有权方的：</p><p><img src="https://www.jackhuang.cc/svg/conforrc.svg" alt="两个链表串起来"></p><p>写成代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   Compiling greeting v0.<span class="number">1.0</span> (/Users/jack/Documents/code/rust/vsrust/greeting)</span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `common_list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> |     <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">   |         ----------- <span class="keyword">move</span> occurs because `common_list` has <span class="keyword">type</span> `<span class="type">Box</span>&lt;List&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">   |                    ----------- value moved here</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line">   |                      ^^^^^^^^^^^ value used here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>可见，common_list在第12行的时候就给了 a 链表，b 链表想用是用不了了。此时就需要Rc&lt;T&gt;，它和Box&lt;T&gt;不同之处就是它实现了多个不可变对象的共享资源（Box&lt;T&gt;可变不可变资源都可以，但只能有一个所有权方）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以正常编译并运行。</p><p>注意，Rc&lt;T&gt; 对象之间在赋值的时候需要使用 Rc::clone 方法，如果直接使用赋值，还是会走到Rust的默认行为：所有权转移。</p><h2 id="顺带一提：clone和copy方法"><a href="#顺带一提：clone和copy方法" class="headerlink" title="顺带一提：clone和copy方法"></a>顺带一提：clone和copy方法</h2><p>顺带提一下 clone 和 copy 方法。clone 和 copy 都是带有复制的意思，但 copy 则比较暴力，是资源的安位拷贝，而 clone 则是和具体是类型实现相关，比如上面的 Rc::clone 实现的是浅拷贝，并且引用计数加 1。而String 的 clone 则是字符串拷贝：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        b = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        std::mem::<span class="title function_ invoke__">drop</span>(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，a 虽然超出作用域，甚至调用了drop，但 b 依然能正常打印，因为 String的 clone 是深拷贝。</p><h2 id="打印计数"><a href="#打印计数" class="headerlink" title="打印计数"></a>打印计数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，每次赋值或者走出作用域后都打印一次Rc的内部计数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可见，每次clone，引用计数加 1，对象被销毁，则计数减 1，为 0 时，资源被析构。</p><p>为什么这里用的是 Rc::strong_count 呢？为什么不是调用 Rc::count，因为还有一个 Rc::weak_count 与 Rc::strong_count 对应。这里就引出了一个问题：资源的相互引用。这在引入RefCell&lt;T&gt;  的时候将可能会发生，留待下节讲。</p><h2 id="Rc-lt-T-gt-的方法"><a href="#Rc-lt-T-gt-的方法" class="headerlink" title="Rc&lt;T&gt; 的方法"></a>Rc&lt;T&gt; 的方法</h2><h3 id="解引用"><a href="#解引用" class="headerlink" title="*解引用"></a>*解引用</h3><p>和Box不一样，Box 我们可以通过解引用的方式获得 T 的所有权，但如果我们对Rc进行解引用，那么会编译错误，因为这样越过 Rc 的计数法则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只能得到 Rc&lt;T&gt;  的引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;*x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>修改成 &amp;*x 后 y 将是 Person 的对象引用，一切正常。</p><p>这种方式也是安全的，因为编译器在编译的时候就会检查无误，不会出现悬挂指针。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>调用 &amp;*x 可读性实在是比较差，调用 as_ref 则清晰很多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>和 &amp;*x 等效。</p><h3 id="没有-as-mut"><a href="#没有-as-mut" class="headerlink" title="没有 as_mut"></a>没有 as_mut</h3><p>Rc&lt;T&gt; 不会提供可变 T 引用方法，因为它是针对不可变 T 来设计的。</p><h2 id="什么时候使用-Rc-lt-T-gt"><a href="#什么时候使用-Rc-lt-T-gt" class="headerlink" title="什么时候使用 Rc&lt;T&gt;"></a>什么时候使用 Rc&lt;T&gt;</h2><p>如果 Box这种只能有一方所有权的容器无法满足需求，且不涉及可变资源，那么就可以使用 Rc&lt;T&gt; 了。简单来说可以按以下步骤来确定是否可以使用Rc&lt;T&gt;：</p><p>1、能用 Box&lt;T&gt; 那就用；</p><p>2、若不能用  Box&lt;T&gt;，比如需要多个所有权方，且不涉及可变资源，那么使用 Rc&lt;T&gt;。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Rc&lt;T&gt; 和 Box&lt;T&gt; 一样，都实现了Deref 和 Drop 这两个 trait，即解引用（*a  操作）和 自动析构；</p><p>2、Rc&lt;T&gt; 通过引用计数维护不可变资源是否应该释放，当引用计数为 0 的时候资源将被释放；</p><p>3、应该通过 Rc::clone 来赋值，因为不同的类型 clone 有不同的实现，而如果不用 clone 方法则会发生所有权转移；</p><p>4、和Box&lt;T&gt; 一样，Rc&lt;T&gt; 也是一个单线程容器，不允许多线程使用；</p><p>5、使用as_ref 提高可读性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了 Box&amp;lt;T&amp;gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&amp;lt;T&amp;gt;了。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的box容器</title>
    <link href="https://www.jackhuang.cc/2023/01/28/rust-box/"/>
    <id>https://www.jackhuang.cc/2023/01/28/rust-box/</id>
    <published>2023-01-28T00:22:51.000Z</published>
    <updated>2023-02-05T02:52:59.883Z</updated>
    
    <content type="html"><![CDATA[<p>Box&lt;T&gt;就是模仿Rust的指针行为：</p><p>1、可以解引用访问，即*a操作；</p><p>2、超出生命范围区域会主动释放资源。</p><p>Rust还提供了Rc&lt;T&gt;，RefCell&lt;T&gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&lt;T&gt;。</p> <span id="more"></span><h2 id="为什么需要-Box-lt-T-gt"><a href="#为什么需要-Box-lt-T-gt" class="headerlink" title="为什么需要 Box&lt;T&gt;"></a>为什么需要 Box&lt;T&gt;</h2><p>Rust最大的优点定（当然可能也是一把双刃剑）就是编译的时候确定实体大小。但总有需要运行时才知道的时候，例如多态（往后会讲），或者例如本例这种struct&#x2F;enum类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 List 枚举的Con 类型绑定了一个 i32 和 另一个 List，因此它的大小在编译的时候无论如何都是未知的。编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> | <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  | ^^^^^^^^^ recursive <span class="keyword">type</span> <span class="title class_">has</span> infinite size</span><br><span class="line"><span class="number">3</span> |     <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">  |              ---- recursive without indirection</span><br></pre></td></tr></table></figure><p>这是因为编译的时候编译器就需要给它一个大小定义。这时就可以使用Box&lt;T&gt;来做到确定的大小。当然Box&lt;T&gt;不是未卜先知，而是编译器看到Box&lt;T&gt;就知道它是一个固定大小的struct，因为Box&lt;T&gt;封装了T的原始指针，它的大小是已知的。我们修改List定义，并sizeof打印它的大小：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof i32 = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">i32</span>&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;List&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;List&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;f64&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">f64</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;i16&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">i16</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof list = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;List&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sizeof <span class="type">i32</span> = <span class="number">4</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;List&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">f64</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">i16</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof list = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这里可以看到，不管 Box&lt;T&gt; 的 T 是什么，其大小都是 8，因为  Box&lt;T&gt;其实就是一个封装了 unsafe 原始指针，不管 T 是什么，其大小都是 *mut T，即 8个字节（指针大小）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: *<span class="keyword">mut</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust的标准库大多数都是使用unsafe机制实现的，也就是unsafe代码实现了一套safe库。在其中用sta::alloc库实现了 unsafe 内存分配和释放。</p><p>因此，当我们无法在编译时期就能确定一个 T 的具体大小时（比如 T 是一个 trait，我们不知道 trait 背后的具体对象是什么的时候），就需要Box&lt;T&gt;。另外，Box&lt;T&gt;还可以让对象生命周期延长到其范围之外，即Box&lt;T&gt;封装了一个栈对象。</p><h2 id="实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait"><a href="#实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait" class="headerlink" title="实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait"></a>实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait</h2><h3 id="定义-MyBox-lt-T-gt"><a href="#定义-MyBox-lt-T-gt" class="headerlink" title="定义 MyBox&lt;T&gt;"></a>定义 MyBox&lt;T&gt;</h3><p>MyBox&lt;T&gt;是一个空struct，但它绑定了一个 T 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure><p>new的时候返回MyBox&lt;T&gt;对象即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deref-方法"><a href="#deref-方法" class="headerlink" title="deref 方法"></a>deref 方法</h3><p>为了让MyBox&lt;T&gt;能做到解引用（*），我们必须实现 Deref trait，其中就是要实现deref方法，它就是返回一个 &amp;T：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a 是一个 Box&lt;T&gt; 的话，那么调用 *a 就相当于在调用 *(a.deref())。即获得 T 对象。</p><h3 id="drop-方法"><a href="#drop-方法" class="headerlink" title="drop 方法"></a>drop 方法</h3><p>接着就是Drop trait，即在超出作用域的时候会调用，类似析构函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;nothing to do but println it to see it was called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察分配和析构"><a href="#观察分配和析构" class="headerlink" title="观察分配和析构"></a>观察分配和析构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 a 将会 act like a dynamic pointer，即支持 *a 运算（相当于调用了 a.deref() ），当作用域走出 main 函数后，a会自动销毁，此时a.drop() 被调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">what the a is: <span class="number">100</span></span><br><span class="line">nothing to <span class="keyword">do</span> but println it to see it was called</span><br></pre></td></tr></table></figure><h3 id="主动析构"><a href="#主动析构" class="headerlink" title="主动析构"></a>主动析构</h3><p>有些时候我们想主动析构一个box对象，比如主动释放连接之类的，但如果我们主动的调用drop是会编译失败的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会发现编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">23</span>:<span class="number">7</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> |     a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">   |     --^^^^--</span><br><span class="line">   |     | |</span><br><span class="line">   |     | explicit destructor calls not allowed</span><br><span class="line">   |     help: consider using `drop` function: `<span class="title function_ invoke__">drop</span>(a)`</span><br></pre></td></tr></table></figure><p>这里也给出了提示，使用std::mem::drop 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以主动析构 Box了。</p><h2 id="Box-lt-T-gt-的方法"><a href="#Box-lt-T-gt-的方法" class="headerlink" title="Box&lt;T&gt; 的方法"></a>Box&lt;T&gt; 的方法</h2><p>Box&lt;T&gt; 提供了一些方法供我们访问被封装的对象，但注意这种方式打破了 Box&lt;T&gt;的封装，不过好在 Box&lt;T&gt; 是编译时就能检查所有权和引用规则，所以一般不会出问题（要出也是编译时期就被检查出来），相对这个来讲，RefCell 就比较危险了。</p><h3 id="使用-解引用"><a href="#使用-解引用" class="headerlink" title="使用*解引用"></a>使用*解引用</h3><p>解引用操作会使 Box&lt;T&gt; 返回被封装的对象，这会造成 Box&lt;T&gt;  失去对 T 对象的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">     age:<span class="number">99</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>上面的第 4 行代码会使得 x 失去对 Person对象的所有权，编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">16</span>:<span class="number">36</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line">   |                 -- value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">   |                                    ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>当然其实 改为 let mut y &#x3D; x; 也会使 x:  Box&lt;T&gt;  失去所有权。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>使用as_ref 方法则获得 Box&lt;T&gt; 的 T 引用。除非函数参数必须传入引用，否则一般情况下也不需要使用这个方法，好在不管怎么样，编译器都会帮助我们检查悬空指针的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">print_age</span>(x.<span class="title function_ invoke__">as_ref</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h3 id="as-mut"><a href="#as-mut" class="headerlink" title="as_mut"></a>as_mut</h3><p>相比as_ref，as_mut 则返回一个可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change_age</span>(p: &amp;<span class="keyword">mut</span> Person) &#123;</span><br><span class="line">    p.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">change_age</span>(x.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h2 id="什么时候需要使用-Box-lt-T-gt"><a href="#什么时候需要使用-Box-lt-T-gt" class="headerlink" title="什么时候需要使用 Box&lt;T&gt;"></a>什么时候需要使用 Box&lt;T&gt;</h2><p>总结看来，Box&lt;T&gt; 是一个其实是对 unsafe 指针的封装，那么什么时候会使用Box&lt;T&gt; 呢？一般以下几种情况可以使用：</p><p>1、当 T 是一个大 size 类型时，可以减少拷贝；</p><p>2、需要实现堆的内存特性，即如果资源超出作用域依然不想析构，此时可以用 Box&lt;T&gt; 传递出去；例如在函数中分配内存，在函数外使用，如果不使用 Box&lt;T&gt;，那么代码看起来像这样： </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="keyword">dyn</span> SelfIntroduce &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        SchoolType::school_teacher =&gt; Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 和 Teacher 两个对象都会在函数结束的时候被析构调，外面的使用方将会变成悬挂指针。但如果改成Box&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> SelfIntroduce&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        SchoolType::school_teacher =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;),   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当函数返回的时候，内部的 Box&lt;T&gt; 将指针所有权全传递给外面使用方，指针所指资源依然存在不会被析构。</p><p>3、正如上面的例子，Student 和 Teacher 都实现了 SelfIntroduce trait，因此可以使用 Box&lt;T&gt; 来实现多态；</p><p>4、也正如最开始的例子，如果是一个无限大的 struct&#x2F;enum，那么也可以用 Box&lt;T&gt;，因为 Box&lt;T&gt; 是对指针的封装，大小总是固定的，可以在编译时确定。</p><h2 id="Box-lt-T-gt-要留意的地方"><a href="#Box-lt-T-gt-要留意的地方" class="headerlink" title="Box&lt;T&gt; 要留意的地方"></a>Box&lt;T&gt; 要留意的地方</h2><p>1、Box&lt;T&gt; 只能有一个所有权方；</p><p>2、Box&lt;T&gt; 只能单线程使用；</p><p>3、Box&lt;T&gt; 的三个方法（解引用，as_ref 和 as_mut）可以让我们方法 T 对象，解引用可能会失去所有权，而引用不会，编译器会检查，防止悬空指针出现。</p><p>那么如果需要多个所有权就需要后面讲的 Rc&lt;T&gt; 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Box&amp;lt;T&amp;gt;就是模仿Rust的指针行为：&lt;/p&gt;
&lt;p&gt;1、可以解引用访问，即*a操作；&lt;/p&gt;
&lt;p&gt;2、超出生命范围区域会主动释放资源。&lt;/p&gt;
&lt;p&gt;Rust还提供了Rc&amp;lt;T&amp;gt;，RefCell&amp;lt;T&amp;gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&amp;lt;T&amp;gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的工作空间（workspace）</title>
    <link href="https://www.jackhuang.cc/2023/01/26/rust-workspace/"/>
    <id>https://www.jackhuang.cc/2023/01/26/rust-workspace/</id>
    <published>2023-01-26T09:27:20.000Z</published>
    <updated>2023-02-05T02:51:30.286Z</updated>
    
    <content type="html"><![CDATA[<p>前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。</p><span id="more"></span><h2 id="为什么需要workspace"><a href="#为什么需要workspace" class="headerlink" title="为什么需要workspace"></a>为什么需要workspace</h2><p>正如前面所说，项目中，个人既要能做到对自己的代码进行单元测试，也要能和别人的代码进行集成测试，因此，项目必须能同时满足独立构建和协同构建。Rust 的workspace正是这个概念。它可以创建独立的 library 工程，也可以同时对几个 library 工程进行依赖构建，也即独立工作时可以非常独立，需要协作时又能迅速集成，期间不需要太多复杂的操作，仅仅只是从工程子目录切换到工程workspace目录，简单而有效。</p><h2 id="如何构建workspace"><a href="#如何构建workspace" class="headerlink" title="如何构建workspace"></a>如何构建workspace</h2><p>我们以 <a href="https://github.com/jackzhhuang/rscount">https://github.com/jackzhhuang/rscount</a> 为例，说说workspace的结构是怎么样子的。</p><p>首先，切换到 workspace_example 分支，因为master分支还在开发中，可能目录结构等等都会变化，为了说明 workspace 结构，我新拉了一个示例分支用来讲 workspace 的结构。</p><p>拉取分支后，可以看到，其目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rscount</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── rsconfig</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── config.rs</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── rscount_main</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── rsfile</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src</span><br><span class="line">        ├── lib.rs</span><br><span class="line">        ├── rs_code_dir.rs</span><br><span class="line">        └── rs_code_file.rs</span><br></pre></td></tr></table></figure><p>首先 rscount 就是我们的workspace根目录，这个目录是用mkdir命令创建的，cd进入rscount就可以开始workspace的创建了。</p><p>需要说的是，rscount&#x2F;Cargo.toml 是 workspace 的结构说明，里面主要展示 workspace 都有哪些子工程，该文件内容是手动写入的，每创建一个子工程就需要手动写入一次工程名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;rscount_main&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsfile&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsconfig&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，一共有三个子工程，名字分别是：rscount_main，rsfile和rsconfig。这些子工程都是用 cargo new 命令来创建的。对于 rscount_main 这种执行文件工程，直接在rscount目录下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new rscount_main</span><br></pre></td></tr></table></figure><p>即可。</p><p>而对于rsfile和rsconfig，因为是 library 工程，需要加上 –lib参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new rsfile --lib</span><br><span class="line">cargo new rsconfig --lib</span><br></pre></td></tr></table></figure><p>创建好这些工程后，就可以写代码编译了，当然可以一起编译，即在rscount下cargo build，也可以分别在各个子工程下分别编译。这里还需要注意的是，rscount_main依赖了rsfile和rsconfig两个工程，因此需要在其rscount_main&#x2F;Cargo.toml中告诉编译器这个依赖关系：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="设置编译选项-编译release版本"><a href="#设置编译选项-编译release版本" class="headerlink" title="设置编译选项-编译release版本"></a>设置编译选项-编译release版本</h2><p>编译的时候，cargo build加上 –release参数即可编译release版本，我们还可以指定release版本的参数，比如最常见的优化级别，debug版本优化级别我们设置为0，release版本优化级别设置为3:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>还有很多编译选项可以甚至，具体可以参考官方文档。</p><h2 id="使用crates-io"><a href="#使用crates-io" class="headerlink" title="使用crates.io"></a>使用crates.io</h2><p>除了自己写 library，还可以求助crates.io，上面有很多其他人编写的 libray库，例如我们需要mysql客户端库，但我们不想自己写一个，肯定有人已经写好了，于是我们上crates.io搜索mysql： <img src="https://www.jackhuang.cc/images/WX20230127-101853@2x.png" alt="使用create.io搜索第三方库"></p><p>​将mysql这个库写入dependencies中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br><span class="line">mysql = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>然后编译，可以看到cargo可以自动下载库并建立依赖，直接使用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>闭包和迭代器</title>
    <link href="https://www.jackhuang.cc/2023/01/25/closure-and-iter/"/>
    <id>https://www.jackhuang.cc/2023/01/25/closure-and-iter/</id>
    <published>2023-01-25T06:44:32.000Z</published>
    <updated>2023-02-05T02:52:48.473Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。</p><span id="more"></span><h2 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h2><p>闭包，即closure，简单说即：</p><p>1、匿名函数；</p><p>2、可以当作value赋值，灵活调用；</p><p>3、闭包的入参和出参除了定义闭包的时候可以指定，还可以由编译器推断（这样更简洁）。</p><p>以下是最简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>(), </span><br><span class="line">                              <span class="string">&quot;hello rust!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                              <span class="string">&quot;hello jack!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),];</span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;print in closure: &#123;&#125;&quot;</span>, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的闭包即“|x| println!(“print in closure: {}”, x)”，这是一个匿名函数，入参为x，编译器会推理为String，根据代码的实现，没有返回参数，只是简单的打印了String的值。</p><p>关于闭包这里不在对其定义阐述更多基本的内容，只需要知道，Rust的闭包入参和出参都是可以依靠编译器推断的就行，关键是Rust的闭包相对于其它语言需要留意的地方。</p><h3 id="是move还是引用？"><a href="#是move还是引用？" class="headerlink" title="是move还是引用？"></a>是move还是引用？</h3><p>闭包最大的特点就是可以capture上下文变量，那么，这个capture在Rust中是move还是引用呢？答案是：引用。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面的例子中，show这个闭包不接受任何参数，但capture了上面的list，show被调用后，list所有权没有被show拿走，依然还在，第7行正常打印list。</p><p>那么，如果闭包就是像move走所有权呢？需要在闭包的前面加上move：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>此时编译出错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">51</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">4</span>  |     <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">   |         ---- <span class="keyword">move</span> occurs because `list` has <span class="keyword">type</span> `<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">   |                ------- value moved into closure here</span><br><span class="line"><span class="number">6</span>  |         <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                     ---- variable moved due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> |     <span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                   ^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>因为list的所有权被show拿走了，最后的print对list的访问将会报错。</p><h3 id="mut闭包"><a href="#mut闭包" class="headerlink" title="mut闭包"></a>mut闭包</h3><p>默认情况下，和Rust基本特性一样，闭包对上下文的capture都是immutable的，如果需要在闭包中更改变量，除了被capture的上下文需要是mut的以外，闭包也需要声明为mut：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">more</span> = || &#123;</span><br><span class="line">    list.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">more</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面这个例子中，list和more都需要mut才能编译通过。</p><h3 id="FnOnce，-FnMut和Fn"><a href="#FnOnce，-FnMut和Fn" class="headerlink" title="FnOnce， FnMut和Fn"></a>FnOnce， FnMut和Fn</h3><p>闭包结合Rust的所有权特性，会对闭包的调用有所限制。闭包的trait有三个：FnOnce，FnMut和Fn。</p><p>FnOnce，顾名思义，表示因为有所有权转移，该闭包只能被调用一次。</p><p>FnMut，Mut即表示改变的意思，意思是该闭包会修改上下文变量，但不会产生所有权转移。</p><p>Fn则比较佛性，即不修改上下文变量名，也不产生所有权转移。</p><p>看下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">70</span>,</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">100</span>,</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[r1, r2, r3];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;return once&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">operation</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the list is &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本意是调用一次sort_by_key方法就会push一次字符串，但编译不通过的是，sort_by_key的入参中，闭包需要是FnMut，可上面的代码中，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只能被调用一次，因为第二次s已经没所有权了，即此时闭包的trait是FnOnce属性的，打开sort_by_key方法的代码可以发现的确是需要FnMut的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(no_global_oom_handling))]</span></span><br><span class="line">  <span class="meta">#[rustc_allow_incoherent_impl]</span></span><br><span class="line">  <span class="meta">#[stable(feature = <span class="string">&quot;slice_sort_by_key&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">  <span class="meta">#[inline]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort_by_key</span>&lt;K, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> f: F)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">      F: <span class="title function_ invoke__">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> K,</span><br><span class="line">      K: <span class="built_in">Ord</span>,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="title function_ invoke__">merge_sort</span>(<span class="keyword">self</span>, |a, b| <span class="title function_ invoke__">f</span>(a).<span class="title function_ invoke__">lt</span>(&amp;<span class="title function_ invoke__">f</span>(b)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>闭包是迭代器最常用的工具，而迭代器又是批处理集合最常用的方法，下面我们就看看Rust的迭代器是怎么用的吧。</p><h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>迭代器是Rust处理集合最最最常用的方法，可以说没有之一。如果依然使用for语句去处理集合，一来不够Rust，二来效率不如迭代器快，因为迭代器是零成本抽象实现。</p><p>关于零成本抽象有很多介绍，但很多人不太理解，这里尝试用最简单的人话说：即只仅仅实现需要的代码，无需额外的代码（成本）。</p><p>再简单一步说，即人类目前设计出最抽象的代码，以至于你不可能再写出更抽象的了（如果可以，请提交PR），因为已经是最抽象的代码，已经没有简化优化的空间，因此效率是最高的。</p><p>迭代器就是高度零成本抽象的代码，我们应该尽可能使用迭代器去处理集合，而不是写for语句。</p><p>Rust中迭代器是一个trait，基本定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of the elements being iterated over.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>其主要的方法是next，每次调用next迭代器都会返回当前元素Some(T)，并且跳到下一个元素，直到所有元素被完全枚举，此时返回None。如果自己定义一个集合也想有迭代器trait，那么也需要去实现这个next方法。</p><p>从上面看出，迭代器是有状态的，即它会记录目前在集合中的位置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><p>那么，当手里拿着一个集合时，如果需要逐个处理，我们应该首先把它变成迭代器，Rust的集合有三个不同的迭代器变化方法，分别对应三个用途，即：iter，into_iter和iter_mut。</p><h3 id="iter，into-iter和iter-mut"><a href="#iter，into-iter和iter-mut" class="headerlink" title="iter，into_iter和iter_mut"></a>iter，into_iter和iter_mut</h3><p>iter是把集合转成引用迭代器，即访问集合元素时以引用的方式访问，不会有所有权转移。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line"> ];</span><br><span class="line"></span><br><span class="line"> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面第7行 x 其实是&amp;String，因此第9行访问 v 时，v 依然时有效的集合。顺便所一下，for_each会拉起对集合的处理流程，即对每一个元素都以参数的方式传入 for_each 中的闭包，即上面的 x。</p><p>如果改成into_iter方法，那么 x 就会变成 String，导致 v 中元素对 String 所有权丢失（都跑 x 去了）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> |     v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line">   |       ----------- `v` moved due to this method call</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> |     <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">   |                              ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>而 iter_mut 即上面的 x 为可变引用（&amp;mut String），注意此时集合本身也必须是可变的才行。这里不多举例了。</p><p>稍微总结一下：</p><p>iter方法：转为引用访问的迭代器，因此没有所有权转移；</p><p>into_iter方法：转为所有权转移的迭代器，因此集合会丧失对所有元素的所有权；</p><p>iter_mut：转为可变引用访问的迭代器，因此也没有所有权转移，且还可以修改元素。</p><h3 id="map和collect"><a href="#map和collect" class="headerlink" title="map和collect"></a>map和collect</h3><p>前面演示了迭代器的 for_each 方法，它只是遍历一遍元素，实际上我们不仅可以遍历一遍元素，还可以把这些被处理的元素以新的集合返回出来，例如map和collect组合，我们先用map：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面的例子中 map 的 x 就是&amp;mut String，我们对 x 进行追加一个 “!”  操作，它作为返回值返回给新的迭代器，但这里并没有把新的迭代器写出来，编译执行以上代码，发现 v 并没有变化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all v = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello rust&quot;</span>, <span class="string">&quot;hello jack&quot;</span>]</span><br></pre></td></tr></table></figure><p> 这是怎么回事呢？因为和 for_each 不同，map 是个偷懒的函数，如果没有新的迭代器去装返回值，那么它就不会被触发，另外，新的迭代器类型是靠返回值类型来推断出来的，我们可以用其它迭代器来装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list</span>: LinkedList&lt;_&gt; = v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>); </span><br><span class="line">    x.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">&#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all list = &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>这里用了 LinkedList&lt;_&gt; 来装。调用迭代器的collect方法会迫使迭代器去产生新的迭代器进而产生新的集合。</p><p>为什么这里 LinkedList&lt;_&gt; 省略了模板类型呢？用了下划线 _ 来代替，因为编译器可以推理出下划线 _ 即 String，我们可以省略不写太多字母。</p><p>此外，我们的map中的闭包返回了 x.clone()，即&amp;mut String的 clone，这是因为如果返回 x，即 LinkedList&lt;_&gt;为LinkedList&lt;&amp;mut String&gt;，最后两句print宏会产生歧义，即 v 是immutable引用，而v是mutable引用，Rust不允许对同一个对象即有mut又有immut引用。</p><p>总之，我们可以用迭代器产生新的迭代器，其产生映射可以用 map 函数来生成新的集合元素，map返回新的迭代器。</p><p>而用迭代器的 collect方法把迭代器重新变回为集合，集合类型可以用返回值推导出来。这是最常用的方法了。</p><p>除了map，还有不少其它引射方法，比如filter，其输入的闭包若返回true则进入到新的迭代器中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evens</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evens = &#123;:?&#125;&quot;</span>, evens);</span><br></pre></td></tr></table></figure><p>输出为偶数集合：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的测试框架</title>
    <link href="https://www.jackhuang.cc/2023/01/21/rust-test/"/>
    <id>https://www.jackhuang.cc/2023/01/21/rust-test/</id>
    <published>2023-01-21T01:16:18.000Z</published>
    <updated>2023-02-05T02:51:25.618Z</updated>
    
    <content type="html"><![CDATA[<p>测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。</p><span id="more"></span><h2 id="生成测试框架"><a href="#生成测试框架" class="headerlink" title="生成测试框架"></a>生成测试框架</h2><p>在生成 library 库的时候，Rust一定会生成一个简单的测试模板，例如，我们建立一个名叫jacktest的库：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new jacktest --lib</span><br></pre></td></tr></table></figure><p>此时就会在src目录下生成lib.rs文件，里面就是一个简单的测试模板，简单的对 2+2 进行测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里先注意到的是之前我们用过的一个语法 #[]，即表明增加某个属性（attribute），比如之前用的 #[derive(Debug)] 就是指这是一个派生（derive）属性，具体属性为Debug，即这个struct可以用于Debug，比如格式化打印观察里面的数据。</p><p>这里 #[test] 则表示it_works是一个 testing 函数，会被命令cargo test调起。执行cargo test后，会打印出it_works被执行的测试信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们就可以自己添加自己想要测试的内容了。这里不去讨论太多assert宏的使用，这个在官方文档花了大量篇幅介绍，这里不去一一介绍那些assert宏。关于assert宏的要说的有两点：</p><h3 id="assert宏的应用"><a href="#assert宏的应用" class="headerlink" title="assert宏的应用"></a>assert宏的应用</h3><p>第一，我们应该尽量选择合适的assert去体现测试原意，比如计算两个值是否相等，使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b);</span><br></pre></td></tr></table></figure><p>就比使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(a == b);</span><br></pre></td></tr></table></figure><p>要好。因为assert_eq出来的信息比assert出来的信息更能反映测试目的。</p><p>第二，assert后面可以打印一些format信息帮助我们在看测试结果的时候能看到更多有用的信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>测试框架遇到panic会直接报错，但和平常的panic处理方法不同，测试框架里面的panic不会停止测试流程，只是单个测试会中断而已，例如我们在上一个测试代码中增加一个测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_will_panic</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;something goes wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试框架还是会执行其它的测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line"><span class="keyword">in</span> partial_cmp of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">240</span></span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_will_panic&#x27; panicked at <span class="symbol">&#x27;something</span> goes wrong!&#x27;, src/lib.rs:<span class="number">41</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">test tests::equal ... ok</span><br><span class="line">test tests::it_will_panic ... FAILED</span><br></pre></td></tr></table></figure><p>这是因为测试框架是用多线程来拉起测试用例的，某一个用例panic只会影响某一个线程，不会使整个测试框架进程都退出。</p><p>panic也可以format我们输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;the value is &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><h3 id="should-panic"><a href="#should-panic" class="headerlink" title="should_panic"></a>should_panic</h3><p>有些时候panic就是我们所期望的，特别是我们需要测试一些失败用例的情况下，比如设计一个类，关联一个 1 到 100 的数字，如果输入不在这个范围内则panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果输入200到new方法中，则理应在13行panic，这是我们期待的，但如果直接执行测试，那结果是不通过的，这时就需要should_panic宏来告诉测试框架，这个是我们期待的panic，可以认为通过。那么怎么告诉呢，其原理是检查panic宏打印的log是否包含should_panic中指定的字符串，如果包含，则认为如预期panic，测试用例通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，#[should_panic(expected &#x3D; “less than or equal to 100”)] 就是指定期待panic的地方，其中expect所等于的字符串，就是子串，只要逻辑代码中panic信息包含这个子串，那么认为测试通过而不是报失败。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::greater_than_100 - should panic ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><p>如果我们交换Guess函数中 if - else 语句的panic，此时panic信息自然就不是期待的那样了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行测试，走入if value &gt; 100分支中，但提示信息和should_panic不一样，那么会被判定为不期待的panic，测试失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">note: panic did not contain expected string</span><br><span class="line">      panic message: `<span class="string">&quot;Guess value must be greater than or equal to 1, got 200.&quot;</span>`,</span><br><span class="line"> expected substring: `<span class="string">&quot;less than or equal to 100&quot;</span>`</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greater_than_100</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">0</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h2 id="控制测试框架"><a href="#控制测试框架" class="headerlink" title="控制测试框架"></a>控制测试框架</h2><h3 id="测试框架的参数"><a href="#测试框架的参数" class="headerlink" title="测试框架的参数"></a>测试框架的参数</h3><p>测试框架参数分成两种，一种用于过滤测试代码用例（比如执行或者不执行某些测试用例），一种是用来控制测试框架行为的（比如用例的执行方式，怎么打印信息等）。</p><p>两种参数用 – 隔离。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test 测试用例过滤参数 -- 控制测试框架行为参数</span><br></pre></td></tr></table></figure><h3 id="控制测试用例行为"><a href="#控制测试用例行为" class="headerlink" title="控制测试用例行为"></a>控制测试用例行为</h3><h4 id="控制测试线程数量"><a href="#控制测试线程数量" class="headerlink" title="控制测试线程数量"></a>控制测试线程数量</h4><p>之前也提到过，测试框架使用的是多线程拉起各个测试用例的，也就是测试用例是并行运行的，一般情况下不会有什么问题，但如果比如两个用例同时写一个文件那么久会出现不可预知的后果，这时就需要我们告诉测试框架，使用单线程去执行用例，这个是控制测试框架行为的，所以放在 – 的右边：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --test_threads=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就不会有并发运行测试了。</p><h4 id="在测试流程中打印print信息"><a href="#在测试流程中打印print信息" class="headerlink" title="在测试流程中打印print信息"></a>在测试流程中打印print信息</h4><p>假设我们现在有一个矩形面积类：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要测试哪个矩形的面积哪个面积大，那么我们必须先实现PartialEq（需要实现eq方法）和PartialOrd（需要实现partial_cmp方法）这两个trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialEq</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eq</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in eq of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() == other.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialOrd</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">partial_cmp</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;std::cmp::Ordering&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in partial_cmp of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() &gt; other.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Greater);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Less);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但我们在进行测试的时候，发现println!并没有打印出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            width: <span class="number">10</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">120</span>,</span><br><span class="line">            width: <span class="number">2</span>,</span><br><span class="line">            name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是因为cargo test不会打印出标准输入输出，为了打印print信息，控制测试框架行为，需要这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --nocapture</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output</span><br></pre></td></tr></table></figure><p>这样，我们在代码中print出来的数据就能看到了。</p><h3 id="过滤测试用例"><a href="#过滤测试用例" class="headerlink" title="过滤测试用例"></a>过滤测试用例</h3><h4 id="运行指定用例"><a href="#运行指定用例" class="headerlink" title="运行指定用例"></a>运行指定用例</h4><p>在默认情况下，如果只是运行cargo test那么所有被标记为 #[test] 属性的用例都会被执行，但偶尔我们只想运行其中某个用例，此时就可以直接用名字来指定某个用例，例如增加一个这么个用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eq</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">10</span>,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不想执行large测试用例，只想执行eq测试用例，那么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test eq -t- --show-output</span><br></pre></td></tr></table></figure><p>因为是过滤，所以eq写在 – 的左边。表示执行以eq为开头的用例。这样large用例就不会被拉起。</p><p>如果想运行多个，那么用前缀匹配即可，例如增加一个eq_fail：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"> <span class="meta">#[should_panic(expected = <span class="string">&quot;not equal!&quot;</span>)]</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">eq_fail</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">10</span>,</span><br><span class="line">         name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">20</span>,</span><br><span class="line">         name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> a.<span class="title function_ invoke__">area</span>() != b.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">         <span class="built_in">panic!</span>(<span class="string">&quot;the area of a&#123;&#125; and b&#123;&#125; are not equal!&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样运行之前的命令，此时eq开头的测试用例都会被拉起：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::eq ... ok</span><br><span class="line">test tests::eq_fail - should panic ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- tests::eq stdout ----</span><br><span class="line"><span class="keyword">in</span> eq of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">---- tests::eq_fail stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::eq_fail&#x27; panicked at <span class="symbol">&#x27;the</span> area of a1000 and b2000 are not equal!&#x27;, src/lib.rs:<span class="number">54</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    tests::eq</span><br><span class="line">    tests::eq_fail</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">2</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">1</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h4 id="忽略某些用例"><a href="#忽略某些用例" class="headerlink" title="忽略某些用例"></a>忽略某些用例</h4><p>有些用例很特殊，比如可能某个版本会出错，此时我们需要暂时忽略这些用例，那么可以用ignore属性忽略掉，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore = <span class="string">&quot;no testing anymore&quot;</span>]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>此时即使使用cargo test也不会拉起large用例了。</p><h4 id="运行所有用例（包括已忽略的）"><a href="#运行所有用例（包括已忽略的）" class="headerlink" title="运行所有用例（包括已忽略的）"></a>运行所有用例（包括已忽略的）</h4><p>如果想运行所有用例即使是被 igore 的呢？那么一种方法当然是删掉 ignore 属性，一种是使用控制测试框架行为的参数，把被 ignored 的用例 include 进来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --include-ignored</span><br></pre></td></tr></table></figure><p>当然，如果只想运行被 ignored 的用例，那么就指定使用 ignored 用例即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --ignored</span><br></pre></td></tr></table></figure><h2 id="测试用例结构"><a href="#测试用例结构" class="headerlink" title="测试用例结构"></a>测试用例结构</h2><h3 id="测试代码与二进制文件"><a href="#测试代码与二进制文件" class="headerlink" title="测试代码与二进制文件"></a>测试代码与二进制文件</h3><p>当某个mod被声明test的时候，编译二进制文件讲不会包含测试代码，测试代码和生产用的代码是被分别编译成不同的产物的，这样即节省了编译时间，也减少了测试代码对生产代码的影响：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">cfg</span>(test)]</span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p>可以看到我们一直以来都是在测试非pub的函数，那么方法一样，我们测试的所有函数和方法都不是mod test里面的，也没有声明为pub，但实际我们一直在测试，所以Rust是允许 test 越过访问权限来测试的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::*;</span><br></pre></td></tr></table></figure><p>Test 框架中use supper也说明它引入了所有其它mod，无需担心是否有pub属性。</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>前面说的都是单元测试，所谓单元测试，即对某一个模块的某一个函数或者方法进行测试，而集成测试，则是对某一个模块所导出的接口进行测试，这个模块可能依赖多个其它模块。和单元测试不同，单元测试是和生产代码（放在src目录下）放在一起的，只是都集中放在mod tests里面，并标记 cfg(test)] ，集成测试则是放在和生产代码目录src同级目录下，名叫tests，这些名字都是固定的。cargo会根据目录名而知道，tests下放的每一个文件都是一个testing crate（Rust的基础模块单元）。集成测试不需要再把测试代码放进mod tests里面，只要保证在tests目录下即可。</p><p>例如我们把之前的RectangleArea的测试代码移动到tests目录下，最后目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rectangle</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── rectangle_area.rs</span><br><span class="line">└── tests</span><br><span class="line">    └── test_rectangle_area.rs</span><br></pre></td></tr></table></figure><p>其中lib.rs导出rectangle_area：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> rectangle_area;</span><br></pre></td></tr></table></figure><p> 而内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rectangle::rectangle_area::RectangcleArea;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_area_eq_large</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;a.area() = &#123;&#125; is not larger than b.area() = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，测试框架因为被移出src目录，需要使用use把rectangle目录引入，而且，由于不再是单元测试，如果是私有的字段或者方法，将需要声明为pub，否则tests是无法使用的。</p><p>运行cargo build将会编译库文件，运行cargo test将会执行tests目录下的测试模块，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test --test test_rectangle_area -- --nocapture</span><br></pre></td></tr></table></figure><p>即运行 test_rectangle_area.rs的测试用例，且打印print信息。如果不指定test_rectangle_area，那么tests中所有的测试用例都会被拉起执行，而且如果其中某一个失败，会中断所有的测试流程。</p><p>这里似乎不能像python test那样指定到某个函数进行测试，而且对于执行文件（main.rs）是不能使用测试框架的，因为Rust官方认为，执行文件的逻辑应该是很少的，大部分逻辑应该都在库文件中，执行文件只需要简单的运行起来就能测试了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的生命周期（lifetime）</title>
    <link href="https://www.jackhuang.cc/2023/01/19/rust-lifetime/"/>
    <id>https://www.jackhuang.cc/2023/01/19/rust-lifetime/</id>
    <published>2023-01-19T08:19:54.000Z</published>
    <updated>2023-02-05T02:50:48.809Z</updated>
    
    <content type="html"><![CDATA[<p>生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。</p><span id="more"></span><h2 id="生命周期是什么"><a href="#生命周期是什么" class="headerlink" title="生命周期是什么"></a>生命周期是什么</h2><p>生命周期（lifetime）是annotation，即一个标记。仅此而已。不管我们怎么做，生命周期就是一个标记，它没有改变任何东西，尤其不会改变对象的生命周期，尽管我们把它叫做生命周期。所以，遇到生命周期时，记住，它只是一个标记，相当于给编译器看的注释，用于给它提示对象的生命周期的。</p><h2 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h2><p>为什么我们要关注生命周期呢，看看下面这个例子，找出一句话的第一个单词：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(&amp;[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> words.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个find_first_word函数入参是一个引用，出参也是一个引用，这么做完全没问题，因为如果出参引用的是入参，那么出参的生命周期和入参一样，如果出参是内部new出来的，那么如果出现悬空指针，那么编译器是可以知道的，所以此时不需要生命周期标记。但如果有两个参数就不一样了，比如返回最长的那个字符串引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，find_longest函数可能返回s1也可能返回s2，那么其返回值的生命周期到底是s1还是s2呢？这个是要靠运行时才能知道的，由于不知道到底返回哪个，编译器自然也无法知道返回值的生命周期，那么无法编译使用这个函数的地方的代码，因为Rust必须在编译时就精确知道各个变量的生命周期，这样才能避免悬空指针，比如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    longest_string = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><p>显然，现在函数find_longest会返回s1，那么longest_string将会引用s1，但s1在离开大括号后就没有了，于是第 8 行的print代码显然在打印一个悬空指针。</p><p>如果没有生命周期标记，Rust编译器无法知道第 5 行longest_string拿到的返回值生命周期到底有多长，也就很难（实际上是可以发现的，可能未来会优化）发现悬空指针问题。</p><p>我们加上生命周期后如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和模板很像，首先在函数名的简括号里面生命一个生命周期，以 ‘ 开头，这个是生命周期语法的要求，后面的 a 则是一般约定俗成的写法，一般使用小写字母，短的单词表示某个某个生命周期，唯一比较特殊的是 ‘static 这个生命周期，这个放后面讲。</p><p>声明完生命周期后，后面引用的时候在&amp;符号后面加上这个’a就表示这个引用的生命周期是’a，那么上面的代码中，s1和s2以及返回值这三个引用的生命周期都是’a，即表示，他们这三个变量中，最小的生命周期必须覆盖其它两个变量的使用范围。</p><p>前一个例子中，s1的生命周期是最小的，它只能活在大括号内，而s2和longest_string在可以存活在大括号外面，所以，s1的生命周期最小，它必须覆盖完s2和longest_string的使用范围。但很明显，出了大括号后，我们访问了longest_string，此时s1已经被销毁，不满足上述要求，因此编译器报错。修复它当然很简单，延长s1的生命周期范围即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span> = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><h2 id="struct的生命周期"><a href="#struct的生命周期" class="headerlink" title="struct的生命周期"></a>struct的生命周期</h2><p>和函数一样，struct也有生命周期问题，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: &amp;<span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，name这个字段是个引用，那么为了避免有悬空指针出现，Person的对象的生命周期小于等于name引用的对象的生命周期，否则，如果Person的对象还存在，但name所引用的对象已经销毁，那么就会出现悬空指针了。于是为了说明这一点，我们加上生命周期标记，让编译器也让使用方知道，我们必须保证Person的对象生命周期小于等于name所引用的对象的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和函数类似，在Person后的尖括号内声明生命周期’a，name的引用符号&amp;后加上’a，这样就表示Person的对象和这个name字段引用的对象它们的生命周期必须保证Person对象能在name引用对象之前销毁。</p><p>那么，如果我们给这个Person加上方法，是否也需要跟着都加上生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是需要的，即使不管是入参还是返回值，都没有去碰name这个引用，返回值也不是引用，为什么需要加上’a声明呢？</p><p>因为Rust其实是把生命周期和泛型看成差不多一样的对待，大家也看到了，生命周期的声明和模板的声明一样，都在一个地方，他们都是在标记带有某个类型或者声明周期的struct，也就是说，既然我们声明了struct Person&lt;’a&gt;，那么Person&lt;‘a&gt;就是一个叫做“生命周期为’a的struct，struct名叫Person”的类型，那么，给这个类型添加方法，也需要带上’a，简单说也就是Person&lt;‘a&gt;是一个整体，就好像模板Person&lt;T&gt;一样。</p><p>那么返回name这个引用呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">    <span class="keyword">self</span>.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，依然顺利通过编译，但get_name如果改成可能某种情况下会返回pre或者self.name：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">     <span class="keyword">if</span> pre == <span class="string">&quot;hello&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> pre;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会报类似前面的错误了。这是为什么呢？这里就需要Rust的声明周期检查三个规则来解释了。</p><h2 id="生命周期的三个规则"><a href="#生命周期的三个规则" class="headerlink" title="生命周期的三个规则"></a>生命周期的三个规则</h2><p>Rust发现在函数（方法也类似）签名（即入参和出参）或者struct中发现有引用时，会使用这三个规则来检查我们是否需要增加生命周期，如果都通过，那么就不需要，如果有失败，则提示需要增加生命周期。</p><h3 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h3><p>编译器给函数的输入参数都加上自己的生命周期。</p><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器先自己尝试这个给它们都加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即s1和s2都有自己的生命周期 ‘a 和 ‘b。这一步一般不会有什么错误。</p><h3 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h3><p>编译器给函数的输出参数加上自己的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译器发现 ‘c 会出现问题，因为 ‘c这个生命周期 ‘a 和 ‘b 相关，那么，’c 应该选 ‘a 还是 ‘b 呢？似乎都不确定，这就需要写这段代码的人告诉编译起怎么选择。</p><p>因此编译器报错，提示我们请准确告诉它用哪一个生命周期。我们把s1和s2都写成同一个生命周期，这样就相当于告诉编译器，s1和s2在这个函数中有相同的生命周期，返回参数也可以用这个生命周期，问题得以解决：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以修改这个函数加深理解，忘记这个函数是做什么的，假如这个函数就是只返回s2，那么，哪怕我们把s1和s2都声明称不同的声明周期也没问题，因为编译起看到代码，发现函数只返回s2，所以返回值使用s2的即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写是没有问题的，因为返回值就只能是s2，那么返回参数的生命周期当然和s2是一样的。如果返回参数用的s1的生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译起报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |                 --  -- lifetime `<span class="symbol">&#x27;b</span>` defined here</span><br><span class="line">   |                 |</span><br><span class="line">   |                 lifetime `<span class="symbol">&#x27;a</span>` defined here</span><br><span class="line"><span class="number">23</span> |     <span class="keyword">return</span> s2;</span><br><span class="line">   |            ^^ function was supposed to <span class="keyword">return</span> data with lifetime `<span class="symbol">&#x27;a</span>` but it is returning data with lifetime `<span class="symbol">&#x27;b</span>`</span><br></pre></td></tr></table></figure><p>因为它们的生命周期不匹配。可见，生命周期是引用的一部分，这点类似于Class&lt;T&gt;不能赋值给Class&lt;F&gt; 一样，它们虽然名字都叫Class，但就是不一样的类型。</p><p>如果只有一个引用参数的话呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，编译起尝试给入参加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现返回值只能是s的生命周期，所以推理出返回值的生命周期为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译器不会发生之前那种歧义的地方，编译通过，我们不需要手工加上生命周期。</p><p>总之，规则二就是编译器主动自己给每一个引用入参加上生命周期的过程，只要它能推理出确定的返回值生命周期，编译就能顺利通过。经验上来讲，如果入参只有一个引用，编译器一般都能推理出返回参数的生命周期，但如果是多于一个引用参数，那么就需要我们给编译器提示了。</p><h3 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h3><p>这个规则是和方法相关的，如果是一个方法，那么除了规则二的应用，还会加上规则三，即，如果引用返回值的生命周期和引用self相关，那么它的生命周期就使用引用self的生命周期。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照规则二announce方法会出现错误，但规则三却可以弥补规则二的问题。即因为引用返回值的生命周期和引用self相关，所以他们的返回值是一样的，即确定的。但如果我们改成返回参数s，这个时候就需要我们加入生命周期标记了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static生命周期"><a href="#static生命周期" class="headerlink" title="static生命周期"></a>static生命周期</h2><p>之前讲的生命周期都是叫a，b或者c，可以说是起了一个短且小写的名字，一般是随意起的，约定俗成是短且小写即可，但有一个特殊的生命周期标记是保留的，即static，表示引用一个从程序执行开始到结束都存在的数据，实际上，static表示这个对象是已经被固化在二进制文件里面了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> =  <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>上面的代码中，”hello world!”这个字符串就是被编译器写入二进制可执行文件的常量区域中，它永远不会被销毁，一致都存在，这个时候就可以用static生命周期标记这种变量。</p><p>一般来说，如果在没有引入常量区的情况下编译器提示使用static引用，多少都说明在设计上可能出现了问题，此时不应该直接用static引用解决编译问题，而是看看哪里引用设计不合理。</p><h2 id="生命周期优化"><a href="#生命周期优化" class="headerlink" title="生命周期优化"></a>生命周期优化</h2><p>诚然在Rust文档中有提到过是否可以优化这些生命周期标记，但目前还是不可或缺，未来版本拭目以待吧。</p><h2 id="生命周期和模板混用"><a href="#生命周期和模板混用" class="headerlink" title="生命周期和模板混用"></a>生命周期和模板混用</h2><p>正如前所说，生命周期非常类似模板，它们可以混在一起用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    age: F </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; Person&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的限制是生命周期的声明必须放在模板之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生命周期是帮助Rust编译器（其实也是帮助程序员）确定引用返回值的生命周期，或者保证struct结构的引用字段中不会出现悬空指针问题。但需要注意的是，生命周期并不改变变量的生命，他只是一种标记，表示某个引用的生命周期相对其它引用的生命周期关系，即生命周期是仅仅只是标记，且有相对性，单个生命周期标记是没有意义的。</p><p>我们可以用前面介绍的三个推理规则来判断如何帮助编译器确认生命周期。</p><p>生命周期和模板非常类似，它们都是类型属性之一，如果因为帮助编译起确定生命周期而进行了生命周期声明，那么它就是类型的一部分，外后增加方法的时候不能省略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的模版和trait编程</title>
    <link href="https://www.jackhuang.cc/2023/01/17/rust-template/"/>
    <id>https://www.jackhuang.cc/2023/01/17/rust-template/</id>
    <published>2023-01-17T05:13:33.000Z</published>
    <updated>2023-02-05T02:51:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>要开始学习Rust比较高级的内容了。</p><p>今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。</p><p>那么，今天就好好看看Rust的模板编程吧。</p><span id="more"></span><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>假设我们需要做查处整型和字符型数组中，最大的那个元素，那么需要两个函数分别处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_int</span>(array: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_char</span>(array: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，两个函数都差不多，更抽象的写法是使用模板，即不管什么类型，都执行加法运算：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find_largest_template&lt;T&gt;的T表示T是一个种类型的模板，即模板声明， array: &amp;[T]则表示array是一种类型的slice引用，返回值这是一种类型的引用。具体类型在编译确定的代码时会确定。目前为止没错。</p><p>但在第4行，会报一个错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">26</span> |         <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">   |            ------- ^ - &amp;T</span><br><span class="line">   |            |</span><br><span class="line">   |            &amp;T</span><br><span class="line">   |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T`</span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> | <span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">   |                           ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `greeting` due to previous error</span><br></pre></td></tr></table></figure><p>意思是，需要确保调用者知道，这个模板T类型需要实现std::cmp::PartialOrd这个trait（partial order），即这个模板类型需要能做&lt;，&gt;，&lt;&#x3D;和&gt;&#x3D;的运算。这个用法相当于函数对调用方的要求，限制。也就是trait bond，即想调用这个函数，调用方必须保证模板类型能满足指定的trait。我们按照编译器的指示，加上对应的trait bond后，编译器检查无误，可以通过编译并正常运行了：</p><p>这个例子我们可以看出三点：</p><p>1、通过函数入参来推断模板类型；</p><p>2、返回值也可以用于模版；</p><p>3、函数设计方可以对模板进行trait bond设计，保证使用方知道这个trait需要满足什么特性（trait）。</p><h3 id="返回值模板"><a href="#返回值模板" class="headerlink" title="返回值模板"></a>返回值模板</h3><p>不但函数的输入参数可以推断类型，返回值也可以用于推断类型。比如我们需要split一个字符串，把split的结果放到一个数组中，代码可以这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(&amp;[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> words.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里split()   方法返回一个iterator，并调用其collect() 方法返回一个集合，看源码知：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect</span>&lt;B: FromIterator&lt;<span class="keyword">Self</span>::Item&gt;&gt;(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> B</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    FromIterator::<span class="title function_ invoke__">from_iter</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其返回的是一个模板B，那么在编译s.split(&amp;[‘ ‘, ‘,’, ‘.’]).collect();这段代码的时候编译器怎么知道我们用的是Vec呢？确实，实际上我们可以用Vec，也可以用LinkedList，那么，为了让编译器生成一个返回Vec的方法出来，我们必须在调用的时候显示写出let words: Vec&lt;&amp;str&gt; &#x3D; … ，这样编译器才能知道我们需要Vec，于是生成一个返回值为Vec的collect() 方法出来。</p><p>我们也可以把Vec&lt;&amp;str&gt;改成Vec&lt;_&gt;，因为编译器完全可以自己推导出&amp;str的，用下划线 _ 即可省去写太多字母。</p><h3 id="struct模板"><a href="#struct模板" class="headerlink" title="struct模板"></a>struct模板</h3><p>和函数模板差不多，我们在struct名称前加上模板声名就可以声明一个模板struct了，后面的字段可以定义对应的类型字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    number: T,</span><br><span class="line">    coord: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，我们也和函数模板一样（函数模板通过入参来推断T），在初始化struct的字段时，推断出各个字段的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">postion</span> = Point &#123;</span><br><span class="line">    number: <span class="number">100</span>,   <span class="comment">// 表明Point的T是i32</span></span><br><span class="line">    coord: Coord &#123; <span class="comment">// 表明Point的U是Coord</span></span><br><span class="line">        x: <span class="number">23</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">        y: <span class="number">84</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似的还有enum的模板，这在之前学习Result和Optional的时候遇到过，不多说了。</p><h3 id="方法的模板"><a href="#方法的模板" class="headerlink" title="方法的模板"></a>方法的模板</h3><p>方法的模板稍显复杂，先看一个简单的例子，例如，我们给前面的例子中Coord&lt;T&gt;添加一个方法用以计算坐标到o点的距离，这个方法是针对T为f64的特化版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Coord</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">distance_to_o</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果要写特化，只需要在impl Coord后面实例化T即可。</p><p>当然也可以不特化，但如果需要支持运算就要加上trait bond，这里用打印x和y来举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: std::fmt::Display&gt; Coord&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">show</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到相对特化版本，泛型版本需要在impl&lt;T&gt;中对T进行trait bond指定，让调用方知道，想使用这个方法，T必须实现了std::fmt::Display，因为方法实现中调用了println!宏。</p><p>总结来说，特化需要放在struct名中指定具体类型，而泛型需要放在impl中指定trait bond。</p><p>我们还可以对泛型为T的struct加上泛型为U的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>, U&gt; Coord&lt;T, U&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>&lt;P, Q: <span class="built_in">Copy</span>&gt;(&amp;<span class="keyword">self</span>, other: &amp;Coord&lt;P, Q&gt;) <span class="punctuation">-&gt;</span> Coord&lt;T, Q&gt; &#123;</span><br><span class="line">        Coord &#123; x: <span class="keyword">self</span>.x, y: other.y &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">3.14</span>,</span><br><span class="line">        y: <span class="number">2.718</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">mix</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:#?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是把两个泛型类型不一样的Coord合成第三种泛型类型不一样的过程，可以看到，impl&lt;T: Copy, U&gt;可以指定对某一类struct进行添加方法，即对struct这一层的模板声明（类似C++的tempate&lt;class T&gt;），而 mix&lt;P, Q: Copy&gt;则是对方法的参数进行某一类的指定，即对方法这一层的声明，最后在返回值的地方返回混合类型的Coord&lt;T, Q&gt;。</p><p>这里还需要注意的时候我们在一些类型后面加上了Copy trait，因为mix的入参都是引用，但返回的Coord&lt;T, Q&gt;不是，所以值必须通过拷贝来赋值而不是直接赋值。否则，如果是直接赋值，也就是返回值的T和Q类型分别是引用的话，那么引用入参可能生命周期不如返回参数长，返回值中的字段引用的数据资源可能已经被销毁了，造成悬空指针。</p><h2 id="trait编程"><a href="#trait编程" class="headerlink" title="trait编程"></a>trait编程</h2><h3 id="什么是trait"><a href="#什么是trait" class="headerlink" title="什么是trait"></a>什么是trait</h3><p>trait英文原意是特性的意思，这里有一个很好的比喻，可以快速理解计算机编程语言的trait的特性和用法。我们怎么知道某个东西是一只兔子？兔子的trait是：</p><p>1、耳朵长；</p><p>2、眼睛红；</p><p>3、跑起来像跳；</p><p>4、吃胡萝卜。</p><p>假设我们总结出来兔子的trait如上四条，那么，如果遇到满足以上四条trait的东西，我们就认为它是兔子，哪怕我把我的MacBook笔记本按照这四个trait伪装起来，那我的MacBook笔记本就是一只兔子。因为实际上，我们关心并不是到底是兔子还是笔记本，而是它是否有这些trait。</p><p>也就是说，其实我们并不关心某个东西是什么？我们只关心的是某个东西是否满足某个或者某些trait，满足了，那就行了，具体是什么，其实关系不大。</p><p>这就是我们在面向对象编程里面说的，我们要面向接口编程。这里，就是说成：我们要面向trait编程。</p><h3 id="实现trait"><a href="#实现trait" class="headerlink" title="实现trait"></a>实现trait</h3><p>了解了什么是trait，那么就知道trait是做什么的了，其实就是给各种类型定义行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    headline: <span class="type">String</span>,</span><br><span class="line">    location: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    reply: <span class="type">bool</span>,</span><br><span class="line">    retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.headline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">        username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        reply: <span class="literal">true</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用了一个简单的例子，Article和Tweet有不同的字段，同时定义了一个trait Summary，然后针对Article和Tweet分别写出了不同的summarize方法实现。这样，不管Article和Tweet字段怎么样，他们都有Summary这个trait，都可以调用这个trait下的方法。自然有人问，各自定义自己的summarize方法不就行了吗？这个例子的确如此，但假设我们有一个函数去专门处理Summary，做这个事情的人不想关心具体是什么东西，也许是Article，或者是Tweet，甚至可能是一只兔子？总之，对他来说，只要是Summary就行，想使用他的服务的人去想办法把自己变成Summary吧，也就是，只要有Summary这个trait，他的函数就能处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: &amp;<span class="keyword">dyn</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> collect_summary这个函数入参是&amp;dyn Summary，是一个引用，其次dyn是表示运行时动态（dynamic）类型，即编译时不知道Summary背后的东西是什么，需要运行时才能确定，Summary就是我们的trait。加起来表示：collect_summary函数接受一个Summary trait动态引用。</p><p>这样，编写trait和对trait进行再封装再处理的两个人可以解藕编程了，他们之间只需要约定好trait即可。</p><h3 id="dispatch机制"><a href="#dispatch机制" class="headerlink" title="dispatch机制"></a>dispatch机制</h3><p>顺带一提，这里把dyn改成impl也可以正常运行，那么dyn和impl有什么区别呢？还有，为什么dyn前面那里需要用引用 &amp; 呢？本小节讲明白。</p><p>其实这里是Rust的动态运行机制，当涉及到多态编程时，Rust有一种机制来决定到底应该用哪个具体类型来执行，这个机制叫“dispatch”。而dispatch机制分为静态和动态两种，静态dispatch，即编译时期就知道具体是哪个类型了，动态dispatch，则需要在运行时期才能知道是什么类型。</p><p>impl trait则是静态dispatch，也即，Rust编译器在编译的时候就会知道都有哪些类型会使用impl trait，并把这些impl trait代码都生成好，运行时直接调过去就行，运行时不需要判断。例如上面的例子中，我们修改collect_summary函数为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在调用的时候，直接传实现了Summary trait的对象指针进去即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">    headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">    author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">    username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    reply: <span class="literal">true</span>,</span><br><span class="line">    retweet: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(a);</span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(t);</span><br></pre></td></tr></table></figure><p>因为是静态dispatch，Rust编译器需要在编译的时候就确定到底谁调用了collect_summary，当看到collect_summary(a)和collect_summary(t)会分别生成对应的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Article) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Tweet) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这样就实现了编译器的多态，即静态dispatch。（额外提示，此处a和t会失去所有权）</p><p>而动态dispatch，即dyn trait，编译时期编译器无需关心具体是谁调用了collect_summary，它只需要记得，collect_summary接受一个实现了Summary trait的类型做为参数即可，由于编译时期无需关心collect_summary的入参具体类型，也就不知道这个入参的大小，即sizeof大小，此时若不是用引用，那么在不知道sizeof大小的情况下，是无法生成collect_summary函数的代码的（因为要确定内存栈大小）。因此，此时必须使用&amp;dyn。编译器也不会生成各种类型入参的collect_summary版本，这些事情都要放到运行时期才确定。</p><h3 id="trait-bond"><a href="#trait-bond" class="headerlink" title="trait bond"></a>trait bond</h3><p>trait bond前面已经用到，就是对模板 T 进行有所限制，只有满足特定trait的类型才能实例化。如果需要多个trait限定，就用 + 号来增加trait限定。比如，给Coord增加一个方法，只有实现了对比trait和现实trait的类型才能实例化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">ShowMax</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; ShowMax <span class="keyword">for</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;max = &#123;&#125;&quot;</span>, c.<span class="title function_ invoke__">show_max</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到，我们对实现ShowMax这个trait进行了trait bond限定，只有能做到Display（进行格式化显示）和PartialOrd（进行大小判断）的类型才能调用。trait bond有助于编译器检查类型是否满足条件。</p><h3 id="where关键字"><a href="#where关键字" class="headerlink" title="where关键字"></a>where关键字</h3><p>trait bond除了可以写在简括号里面，还可以放在函数或者struct名字后面，用where引导出trait bond，比如上面的例子中，可以用where改写成这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; ShowMax <span class="keyword">for</span> <span class="title class_">Coord</span>&lt;T&gt; </span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">PartialOrd</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章内容比较抽象，有一定的编程经验的人才能看懂，总结几个细节小点：</p><p>1、注意模板声明的位置。想使用模板必须先声明，函数模板在函数名称后面声明，struct在struct类型名称后面声明，方法模板则在impl后面声明；</p><p>2、struct模板和方法模板可以是两个不同的维度各自声明自己的模板；</p><p>3、对trait编程，实现模块间解藕；</p><p>4、区分impl trait（静态dispatch，编译时确定）和dyn trait（动态dispatch，运行时确定）两种dispatch机制，已经此时引用的含义；</p><p>5、使用trait bond保证模板能有某种trait，帮助编译器检查前置条件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要开始学习Rust比较高级的内容了。&lt;/p&gt;
&lt;p&gt;今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。&lt;/p&gt;
&lt;p&gt;那么，今天就好好看看Rust的模板编程吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的错误处理</title>
    <link href="https://www.jackhuang.cc/2023/01/16/rust-err/"/>
    <id>https://www.jackhuang.cc/2023/01/16/rust-err/</id>
    <published>2023-01-16T05:07:36.000Z</published>
    <updated>2023-02-05T02:50:44.245Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的错误处理主要有以下4点需要学习：</p><p>1、使用panic!宏；</p><p>2、使用Result&lt;T, E&gt;;</p><p>3、使用Optional&lt;T&gt;</p><p>4、使用 ? 符号简化错误处理的代码，这一点非常赞。</p><p>现在就看看我们Rust的错误处理具体细节吧。</p><span id="more"></span><h2 id="panic-宏"><a href="#panic-宏" class="headerlink" title="panic!宏"></a>panic!宏</h2><p>这个是最简单也是最暴力的错误解决处理方案，即直接中断程序运行，并且报告程序错误。如果程序无法继续往下执行，那么，尽早中断也是不错的选择，关键是，如果配合环境变量RUST_BACKTRACE&#x3D;1的话，还可以打印从panic的地方开始的调用栈，方便快速定位问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;the denominator should not be 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s * t = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">divide</span>(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行的时候加上环境变量RUST_BACKTRACE&#x3D;1，则可以在检查分母的失败时打印出调用栈：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;the</span> denominator should not be <span class="number">0</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: _rust_begin_unwind</span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">   <span class="number">2</span>: greeting::divide</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">3</span>: greeting::main</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">12</span>:<span class="number">28</span></span><br><span class="line">   <span class="number">4</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /private/tmp/rust-<span class="number">20220812</span>-<span class="number">6466</span>-<span class="number">1</span>atesch/rustc-<span class="number">1.63</span>.<span class="number">0</span>-src/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure><h2 id="使用Result-lt-T-E-gt"><a href="#使用Result-lt-T-E-gt" class="headerlink" title="使用Result&lt;T, E&gt;"></a>使用Result&lt;T, E&gt;</h2><p>大部分错误都是可以容忍的，或者说我们可以继续保持程序继续运行，同时给用户一个友好提示，所以给一个恰当的提示是大多数场景。这个时候我们一般使用Result&lt;T, E&gt;。这是一个很简单但非常有用且常用的枚举类型，其源代码为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="comment">/// Contains the success value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Ok&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Contains the error value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Err&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即Ok和Err两个枚举类型，很多标准函数都会用它来表示是否执行成功，例如，我们现在写一个程序，打开一个文件，如果该文件不存在，则创建它，否则就往文件里面写hello world：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fs::File, io::Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">open_or_create_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_handle_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> file_handle_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">            file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_file_hanle_result</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">match</span> new_file_hanle_result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">                    file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;failed to create rust_test.txt, since: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_or_create_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒写了很多，其实就是做了一个简单的逻辑，即先打开文件，存在则写入，不存在则创建，创建成功后写入，创建失败则panic。这个算是比较基本的Result&lt;T, E&gt;使用了。但显然，Rust不会让我们写这么多 match 或者 if 去做判断Result&lt;T, E&gt;结果的，下面就看看Rust是怎么把这段代码简化的。</p><h3 id="用expect代替panic-宏"><a href="#用expect代替panic-宏" class="headerlink" title="用expect代替panic!宏"></a>用expect代替panic!宏</h3><p>如果我们只是想遇到错误就直接panic，那么expect可以帮助我们少写一次 match 或则 if ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_handle</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nofile.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;cannot open the file&quot;</span>);</span><br><span class="line">file_handle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;cannot</span> open the file: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">35</span>:<span class="number">52</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可以看到，我们并不需要去判断open() 方法的返回值Result&lt;T, E&gt;，它的expect()  方法帮我们做了判断，如果是失败，那么就panic，如果是成功，则unwrap给我们句柄。</p><p>如果文件存在，那么expect直接返回句柄，那么后面的写入内容就可以顺利执行。</p><h3 id="用unwrap代替panic宏"><a href="#用unwrap代替panic宏" class="headerlink" title="用unwrap代替panic宏"></a>用unwrap代替panic宏</h3><p>除了 expect 方法，unwrap 也可以替代panic，如果我们不去处理 unwrap 的返回值，那么 Rust 会直接打印 panic，并打印出 Error 信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;nofile.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>此时运行会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;called</span> `<span class="type">Result</span>::<span class="title function_ invoke__">unwrap</span>()` on an `<span class="literal">Err</span>` value: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">20</span>:<span class="number">43</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>如果我们主动处理 Err，那么则正常运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;nofile.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = handle &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the error from reading nofile.txt: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the error from reading nofile.txt: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="用-来简化返回的错误值处理"><a href="#用-来简化返回的错误值处理" class="headerlink" title="用 ? 来简化返回的错误值处理"></a>用 ? 来简化返回的错误值处理</h2><p>Rust提供了了 ? 号来帮助我们简化这种常见的Result&lt;T, E&gt;判断。? 其实就是一段简单的逻辑，即，如果返回的是Err那么就直接返回，如果是Ok则继续往下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_write</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="title function_ invoke__">create_write</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 ? 号后，简化了我们对Result&lt;T, E&gt;的判断处理，代码更简洁了。上面的代码中，open() 方法返回了Result&lt;T, E&gt;，? 会处理成功与失败的情况，若成功，则展开Ok(T)，也即获得文件对象句柄，进而调用write_all() 方法写入数据，若失败，则提前返回。</p><p>这里需要注意的是，open_write() 和 create_write() 返回值必须和里面的代码匹配，即成功返回的是Ok(())，失败则返回的是File::open() 或File::create() 的失败返回值Err(E)，此处E是std::io::Error。</p><h2 id="返回其它类型的错误"><a href="#返回其它类型的错误" class="headerlink" title="返回其它类型的错误"></a>返回其它类型的错误</h2><p>上面可以看到，我们返回的错误Err&lt;E&gt;中，类型都是一致的，也即std::io::Error ，但如果我们不想返回这个类型的错误的话呢？这个时候会发生错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_check</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_hanle</span> = File::<span class="title function_ invoke__">open</span>(file_name)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file_hanle.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content);</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">&quot;hello world!&quot;</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">open_check</span>(<span class="string">&quot;nofile.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">18</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">18</span> |         <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">   |         --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected <span class="keyword">struct</span> `std::io::Error`, found <span class="keyword">struct</span> `<span class="type">String</span>`</span><br><span class="line">   |         |</span><br><span class="line">   |         arguments to this <span class="keyword">enum</span> <span class="title class_">variant</span> are incorrect</span><br><span class="line">   |</span><br></pre></td></tr></table></figure><p>因为函数签名上期待的错误枚举，绑定的类型是std::io::Error，但这里返回了String。解决方法是后面学到的trait和面向对象设计。后面再提。</p><h2 id="使用Optional-lt-T-gt-也是一种选择"><a href="#使用Optional-lt-T-gt-也是一种选择" class="headerlink" title="使用Optional&lt;T&gt;也是一种选择"></a>使用Optional&lt;T&gt;也是一种选择</h2><p>Optional&lt;T&gt;也可以像Result&lt;T, E&gt;那样用，如果是None那么就直接返回，否则就继续处理，比如前面的HashMap，我们get一个key，若存在，则乘以二返回，否则就返回None：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">multiple_2</span>(h: &amp;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;, key: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(h.<span class="title function_ invoke__">get</span>(key)? * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">2</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;rust&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">4</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;rose&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果通过get() 方法访问一个HashMap存在的key，那么 ? 会展开Some(&amp;i32)得到i32的对象的引用，并且和2相乘。如果不存在，则get() 方法返回None，函数提前返回，这段代码的输出是：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the result is <span class="title function_ invoke__">Some</span>(<span class="number">12</span>)</span><br><span class="line">the result is <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="什么时候panic什么时候返回错误码"><a href="#什么时候panic什么时候返回错误码" class="headerlink" title="什么时候panic什么时候返回错误码"></a>什么时候panic什么时候返回错误码</h2><p>那么什么时候panic什么时候返回错误枚举呢？个人觉得这个问题还是比较显而易见的，从后端服务器设计角度来讲，进程退出是难以维护的不够健壮的提现，好的后端服务，应该能经受得住各种输入数据而屹立不倒，如果随随便便就退出以示对错误的一种反应，则容易被恶意客户端所利用，造成拒绝服务攻击。</p><p>也有人认为，出了错就尽快退出，这样可以及时发现错误，这个愿望是很好的，在程序调试阶段我们可以这么干，的确有利于调试，但放到线上，就需要深思熟虑了。</p><p>折衷方案是，对于后端服务初始化阶段，我们可以对关键信息做panic，运行时，对损害健壮性的请求进行提前拦截并提示错误。业务流程错误则当然使用错误信息。</p><p>再进一步说，对于出错，我们其实不能仅仅只是靠panic或者返回错误信息，需要更系统的去考虑问题，比如系统的吞吐（延迟），成功量（率），失败量（率），请求量，不同水平的告警，等等各种多维度的去监控才能准确的知道一个系统的健康与否。这里只是Rust语言学习，不展开说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的错误处理主要有以下4点需要学习：&lt;/p&gt;
&lt;p&gt;1、使用panic!宏；&lt;/p&gt;
&lt;p&gt;2、使用Result&amp;lt;T, E&amp;gt;;&lt;/p&gt;
&lt;p&gt;3、使用Optional&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;p&gt;4、使用 ? 符号简化错误处理的代码，这一点非常赞。&lt;/p&gt;
&lt;p&gt;现在就看看我们Rust的错误处理具体细节吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的容器</title>
    <link href="https://www.jackhuang.cc/2023/01/12/collection/"/>
    <id>https://www.jackhuang.cc/2023/01/12/collection/</id>
    <published>2023-01-12T14:42:05.000Z</published>
    <updated>2023-02-05T02:50:19.357Z</updated>
    
    <content type="html"><![CDATA[<p>今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：</p><p>1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）</p><p>2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）</p><p>3、其它各种先决条件。</p><p>总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。</p><p>现在我们就从最常用的容器开始吧。</p><span id="more"></span><h2 id="1-数组Vec"><a href="#1-数组Vec" class="headerlink" title="1. 数组Vec"></a>1. 数组Vec</h2><p>数组Vec是最常用的容器，它非常类似C++的std::vector，底层数据结构也是一块连续的内存，内存不足时，会扩大，并把老数据拷贝到新内存上，因此，非常适合顺序访问和索引访问，非常不适合有删除和插入的场景，因为此时暗含着内存移动的低效操作。</p><h3 id="1-1-高效初始化"><a href="#1-1-高效初始化" class="headerlink" title="1.1 高效初始化"></a>1.1 高效初始化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用了最常用的初始化方法，array1是vec!宏来初始化，array2是直接用Vec::new()来初始化，可以看到我们在定义array2的时候并没有去告诉array2将会放上面类型，直到第6行push第一个String对象的时候才告诉编译器，我们要放的对象是String。Vec只能是单一对象。第6行决定了array2必须放String对象。</p><p>前面说了，Vec是会因为自身分配的内存空间不足时，增长内存的，因此会有数据移动的低效操作，array2的初始化就是这样，如果我们能事先告诉array2要存放什么类型，已经即将存放的数量，那么Vec就可以事先分配好空间，保证我们后续放入数据时不会有数据移动操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">array2.<span class="title function_ invoke__">reserve</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>上面的reserver方法就是告诉array2实现分配至少3个String对象空间，好让后续的3个push方法调用不产生数据移动操作。</p><p>如果事先知道需要分配数组的元素数量，且它们的值都是同一个，那么，更高效的方法是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = <span class="built_in">vec!</span>[<span class="number">100</span>; <span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array3 = &#123;:?&#125;&quot;</span>, array3);</span><br></pre></td></tr></table></figure><p>上面的[100; 5]就表示，分配长度为5个元素，且每个值都是100的数组，这就比前面使用reserver更高效。</p><p>还有with_capacity()方法，可以把Vec::new()和reserve()方法都合成一个，例如array2的初始化可以改成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>总之，如果我们实现就能知道有多少元素即将push进Vec里面的话，我们就尽量的把内存分配好，避免数据移动操作。</p><h3 id="1-2-顺序访问"><a href="#1-2-顺序访问" class="headerlink" title="1.2 顺序访问"></a>1.2 顺序访问</h3><p>Vec是最适合顺序访问的了，我们可以一个个枚举Vec里面的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> &amp;array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，访问array2时我们用了引用，这样访问里面的String对象时，也都变成了引用，这个规则struct也是这样。因为用了引用，后续array2还是有效的指针。</p><h3 id="1-3-索引访问"><a href="#1-3-索引访问" class="headerlink" title="1.3 索引访问"></a>1.3 索引访问</h3><p>索引访问也是我们常用的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[2] = &#123;&#125;&quot;</span>, array2[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>这当然会打印“hello jack”，但如果访问一个不存在的索引呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[6] = &#123;&#125;&quot;</span>, array2[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure><p>此时会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">6</span>&#x27;, src/main.rs:<span class="number">14</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>还需要非常注意的是，之前也提到过，Vec不允许自己的元素被转移走，即以下代码将编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">take</span> = array2[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>因为首先Rust不允许悬空指针的存在，其次如果Vec去维护中间哪一个元素处于悬空指针又实在不合常理，毕竟Vec就是Vec，即向量，向量不应该感知这些东西。因此如果有人打算通过索引访问去取走Vec的资源，那么就会被编译器报错。</p><h3 id="1-4-插入操作"><a href="#1-4-插入操作" class="headerlink" title="1.4 插入操作"></a>1.4 插入操作</h3><h4 id="1-4-1-insert-方法"><a href="#1-4-1-insert-方法" class="headerlink" title="1.4.1 insert()方法"></a>1.4.1 insert()方法</h4><p>相对于push操作，每一次的insert() 的操作就需要大量移动移动数据了，push只有超过capacity的时候才会产生数据转移，而insert每一次都要把需要插入的位置的后面元素往后挪动一个位置，空出来后给新元素放入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>如果插入操作真的需要很频繁，那么就应该用 LinkedList&lt;T&gt;。</p><h3 id="1-5-删除操作"><a href="#1-5-删除操作" class="headerlink" title="1.5 删除操作"></a>1.5 删除操作</h3><h4 id="1-5-1-pop-方法"><a href="#1-5-1-pop-方法" class="headerlink" title="1.5.1 pop()方法"></a>1.5.1 pop()方法</h4><p>如果想删去Vec的元素，推荐用的是pop()方法，但注意pop() 方法只能从Vec的最后一个元素开始删除，毕竟前面也说了，试图从中间开始插入或删除一个Vec会引起数据移动操作，这是非常低效的。</p><p>例如我们pop出最后一个元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>可以看到，pop()参数返回的是一个Option&lt;T&gt;，也就是如果array2是空的，那么就会返回None。这里返回的是Some(String)类型。pop之后，array2就只有两个元素在里面了。</p><p>但要注意，如果用for in的方式访问array2且没有使用引用的话，还是会把里面的资源转移走的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure><p>以上代码编译不通过，因为第1行for in语句中，s会逐次获得array2的资源，第4行再去访问array2的资源会编译失败。</p><h4 id="1-5-2-swap-remove-方法"><a href="#1-5-2-swap-remove-方法" class="headerlink" title="1.5.2 swap_remove () 方法"></a>1.5.2 swap_remove () 方法</h4><p>如果真的需要删掉其中某一个元素，那么可以使用swap_remove()。它的入参是一个index，即需要删掉的元素的索引。为了避免数据移动，Vec的删除策略是这样的：把最后一个元素的值和需要删掉的index交换，并把Vec的长度减1:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before swap_remove, array1 = [<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line">after swap_remove, array1 = [<span class="number">192</span>, <span class="number">3</span>, <span class="number">231</span>, -<span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>可以看到，我们打算删掉31，于是传入它的index&#x3D;1，Vec把末尾的3交换到31上，然后长度减1。同时，swap_remove还会把31返回出来，虽然这里程序没有提现。</p><h3 id="1-6-Vec内部结构探究"><a href="#1-6-Vec内部结构探究" class="headerlink" title="1.6 Vec内部结构探究"></a>1.6 Vec内部结构探究</h3><p>Vec实际上内部是封装了一个tuple结构，tuple中第一个是指针，指向T资源，第二个是长度len，第三个是容量capacity。Vec保证当容量不足时就会自动懂扩容，因此自动扩容的出现点出现在所需内存大于capacity时。把上面的array2结构画出来，会是这样：</p><p><img src="https://www.jackhuang.cc/svg/Vec.svg" alt="Vec内部"></p><p>可以看到，上图蓝色的三个元素就是Vec内部主要封装的三个熟悉，用tuple表示为 (p, 3, 6) ，即p表示指向一组连续的内存，放String数组，3则是数组的元素个数，6则表示array2的容量，表示还可以再存放6 - 3 &#x3D; 3个String对象，且保证在此之前不会触发数据移动操作。</p><p>String数组后面的灰色部分是未初始化区域，也就是6 -3 &#x3D; 3这个部分。关于未初始化区域，可以详细看这里：<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</a> 。</p><h2 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2. 字符串String"></a>2. 字符串String</h2><h3 id="2-1-字符串的连接"><a href="#2-1-字符串的连接" class="headerlink" title="2.1 字符串的连接"></a>2.1 字符串的连接</h3><p>两个字符串连接是最常见的编程场景，最显而易见的就是使用String的push_str和push两个方法，前者入参是一个字符串，后者入参是一个字符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;，&#x27;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>另外一个方法，就是直接用 + 号来实现字符串的拼接，需要注意的是，+ 号方法，使用的是self而不是&amp;self，也就是说，会有所有权转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure><p>还有需要注意的是，s这个参数是&amp;str，也就是它接受一个引用，也就是被加的字符串不会有所有权转移，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;，&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br></pre></td></tr></table></figure><p>上面的代码中，s1 + &amp;s2 + &amp;s3会使得s1丢失所有权，所幸又还给了s1。这里Rust之所以这么干，其实是避免了拷贝，其内部只是通过引用拿到s2和s3的内容，拷贝到s1的后面，避免了拷贝一块新的区域来存放s1。</p><h3 id="2-2-字符串和字节"><a href="#2-2-字符串和字节" class="headerlink" title="2.2 字符串和字节"></a>2.2 字符串和字节</h3><p>String是和Vec类似的，内部结构也是一个tuple，同样放着p指向字符串，另外两个是字符串的长度和容量。这里不展开讲太多String的功能方法，稍有编程经验的人都应该知道String会提供哪些典型的方法，具体可以参考官方文档。</p><p>和其它语言不同，需要特别注意的是，Rust的String对象是一个UTF8格式的，这就意味着一个问题，就是如果我们索引访问一个String对象，会是返回什么？</p><p>如果String内容是“hello world!”，那么[0]是否应该是h，如果是h，那么它的大小就是一个字节。</p><p>如果String内容是“你好，世界！”，那么[0]是否应该是“你”，如果是“你”，那么它的大小就是三个字节。</p><p>那么到底索引访问一个String要返回多少个字节呢？Rust觉得这是一个模糊的问题，于是拒绝编译这种代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br><span class="line">  |             ^^^^ `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br></pre></td></tr></table></figure><p>Rust 需要使用方明确知道自己在干什么，是要返回一个字符，还是要返回某个字节，所以，如果想拿到某个字符，就明确的告诉String，我要以字符方式访问你：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>chars() 方法返回一个迭代器，即我们熟悉的iterator，可以看到做为迭代器，它是有状态的，即封装了一个当前所处位置的指针，因此需要加上mut，这样后面的nth() 方法才可以得以调用，因为nth() 方法会把当前位置往前移动，这相当于修改了状态。</p><p>nth返回Option&lt;Char&gt;，调用unrawp() 方法可以拿到里面的字符。</p><p>我们当然也可以用字节访问String对象，但这样，打印出来的就不是字符形式了，而是字节数字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = s.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>输入出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">189</span></span><br><span class="line">s = <span class="string">&quot;你好，世界！&quot;</span></span><br></pre></td></tr></table></figure><p>189其实是“你”这个字符的第二个字节数。</p><h3 id="2-3-比较两个String"><a href="#2-3-比较两个String" class="headerlink" title="2.3 比较两个String"></a>2.3 比较两个String</h3><p>Rust在这方面要求就比较简单，只需要 &#x3D;&#x3D; 去比较就好了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好世界!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;你好世界!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are same!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are different!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">they are same!</span><br></pre></td></tr></table></figure><p>虽然s1是String对象，s2是原生字符串，s1是对象的指针，s2是一个引用，但Rust还是会去判断这两个字符串是否内容相等。</p><h3 id="2-4-Rust的String不简单"><a href="#2-4-Rust的String不简单" class="headerlink" title="2.4 Rust的String不简单"></a>2.4 Rust的String不简单</h3><p>Rust的String并不简单，这里只是主要提了最重要的一点，即String需要我们时刻知道我们到底是造操作字符还是字节，未来遇到String的使用，还是需要多翻阅文档，这里就不去一句句翻译文档内容了。</p><h2 id="3-哈希HashMap"><a href="#3-哈希HashMap" class="headerlink" title="3. 哈希HashMap"></a>3. 哈希HashMap</h2><p>hash也是日常中最常用的数据结构，Rust的HashMap使用了SpiHash算法，避免了哈希碰撞的攻击，详见：<a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> 。当然，其效率就有所下降。</p><p>这里主要讲的是我们常使用的方法，第一个当然是插入了。</p><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1 = &#123;:#?&#125;&quot;</span>, h1);</span><br></pre></td></tr></table></figure><p>可以看到，首先HashMap和Vec不一样，需要我们显式引入，其次，它的key和value类型可以在insert的时候指定，当然一旦指定好类型，之后都不允许更改了。</p><p>注意，由于我们没有使用引用，因此，一旦对象呗插入到HaspMap中，HashMap就有了对象的所有权，如果使用引用，那么我们就必须保证所插入的数据的生命周期大于HashMap对象的生命周期，这在后一节讲到。</p><h3 id="3-2-查找"><a href="#3-2-查找" class="headerlink" title="3.2 查找"></a>3.2 查找</h3><p>使用get方法可以获得一个Optional&lt;T&gt;，如果不存在，返回None，否则返回Somel&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这里调用了copied方法，因为返回的是Optional&lt;&amp;i32&gt;，最后调用unwrap_or() 方法，并且提供了若是None，则返回0。</p><p>这里的错误处理下一节会专门讲到。</p><p>当然除了用ge() t方法，还是使用for语句去遍历所有的HashMap数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> h1 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-更新"><a href="#3-3-更新" class="headerlink" title="3.3 更新"></a>3.3 更新</h3><p>如果我们在插入同样的key会发生什么呢？比如再插入一条key为”hello rust!”，value为80的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可以看到，原来的20被80给覆盖了，因此，插入同样的key会产生覆盖结果。</p><p>但如果我们并不想去覆盖，如果已经存在就不要去动它了，怎么办呢？此时应该调用Entry() 方法，Entry() 方法返回一个枚举，如果有值，则返回那条记录的引用，否则返回新的记录的引用，新记录的枚举中，调用它的or_insert() 方法就可以插入新值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>此时输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>20没有再被80覆盖。</p><p>如果我们要针对老值来更新新值呢？比如统计“how many word in this word ?” ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;how many word in this word ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">key</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">count</span> = h.<span class="title function_ invoke__">entry</span>(key).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">     *count += <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:#?&#125;&quot;</span>, h);</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h = &#123;</span><br><span class="line">    <span class="string">&quot;in&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;this&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;how&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;?&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;many&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;word&quot;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到由于word这个词已经存在，所以，第二次调用的时候，entry()  方法返回了老的记录的音乐，此时若调用or_insert()  方法并不会更新，并且返回value的引用，后面的*count +&#x3D; 1对word这个词进行了 + 1 统计。</p><p>以上就是我们常用的HashMap方法，当然，还是那句话，我们使用容器的时候应该多考虑开篇说的两个问题，即什么场景使用，会怎么使用，并且应该常翻阅文档，在里面看看有没有合适的方法供我们选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：&lt;/p&gt;
&lt;p&gt;1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）&lt;/p&gt;
&lt;p&gt;2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）&lt;/p&gt;
&lt;p&gt;3、其它各种先决条件。&lt;/p&gt;
&lt;p&gt;总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。&lt;/p&gt;
&lt;p&gt;现在我们就从最常用的容器开始吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的模块化管理</title>
    <link href="https://www.jackhuang.cc/2023/01/10/mod-and-crate/"/>
    <id>https://www.jackhuang.cc/2023/01/10/mod-and-crate/</id>
    <published>2023-01-10T15:18:55.000Z</published>
    <updated>2023-02-05T02:50:26.982Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。</p><span id="more"></span><h2 id="1-从最简单的包演化说起"><a href="#1-从最简单的包演化说起" class="headerlink" title="1. 从最简单的包演化说起"></a>1. 从最简单的包演化说起</h2><p>任何项目都不可能一个main文件写到底，我们总是要分成几个文件，甚至还要给文件放进不同目录，甚至会事先编译一些文件来管理项目文件。为了学习Rust的相关概念，我们从最简单的一个文件说起，慢慢把它演化成我们常见的项目管理方式，首先来个最简单的main.rs：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个main.rs文件没有任何模块化管理的概念，Person结构体直接就能用。</p><h3 id="1-1-第一个mod"><a href="#1-1-第一个mod" class="headerlink" title="1.1 第一个mod"></a>1.1 第一个mod</h3><p>现在我们把它放到一个module里面吧：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们第一个module了，这里的module很像C++的名字空间（但也不完全是），因此，想使用Person就必须加上PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜这样是编译不通过的，因为任何一个mod里面的东西（也就是module），包括struct，字段，方法，函数甚至子mod都统统是私有的，想对mod外面暴露，就必须定义为pub，因此，我们给Person等名前都加上pub，意味共有的，可以个mod的外部使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候Person以及他的字段都变成pub了，外部可以使用了。代码可以通过编译。</p><p>可见，一个mod关键字，可以声明一个module。</p><h3 id="1-2-把mod放到别的文件"><a href="#1-2-把mod放到别的文件" class="headerlink" title="1.2 把mod放到别的文件"></a>1.2 把mod放到别的文件</h3><p>以上代码我们都是在main.rs文件里面写的，显然我们应该独立出来，假设独立出来的文件名就叫PersonData.rs，那么我们不需要在文件中声明mod PersonData了（如果声明了mod PersonData，那么就是PersonData的子包也叫PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，main.rs的改动就是mod一下这个文件名，从而引入Person结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它地方并没有什么改变。</p><p>可见，一个rs文件，可以被当作一个module。</p><h3 id="1-3-把mod放到别的目录"><a href="#1-3-把mod放到别的目录" class="headerlink" title="1.3 把mod放到别的目录"></a>1.3 把mod放到别的目录</h3><p>如果文件PersonData.rs放到别的文件夹呢？假设我们把PersonData.rs移动到DataSet目录里面，那么，此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>此时，main.rs怎么找到PersonData这个模块呢？</p><p>有两种方法：</p><p>1、和main.rs同目录建一个DataSet同名的rs文件，在里面pub mod PersonData，pub表示这个DataSet包要公开PersonData这个module了。</p><p>DataSet.rs内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br></pre></td></tr></table></figure><p>此时，目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">├── DataSet.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>而main.rs中，mod DataSet（此时不需要pub mod，因为和main.rs是同一个文件，表示引入DataSet），且由于Person被放到了DataSet目录的PersonDate.rs文件中，因此需要修改一下访问它的路径了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，如果一个目录想变成module，就必须在目录同一级目录中，创建一个相同名字的rs文件，并通过它来里面的pub语句来决定公开目录中哪个module。</p><p>第二种方法，我个人认为更简便，即在目录中创建mod.rs，里面干和上面DataSet.rs同样的事情，即决定对外公开目录中哪个module。</p><p>此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>其中，mod.rs的内容和之前第一种方法的DataSet.rs内容一样。这两个方法都是等效的。</p><p>可见，目录想变成module，还可以在目录中创建mod.rs文件来达到这个目的。</p><h2 id="2-模块的路径"><a href="#2-模块的路径" class="headerlink" title="2.  模块的路径"></a>2.  模块的路径</h2><h3 id="2-1-根目录、绝对路径和相对路径"><a href="#2-1-根目录、绝对路径和相对路径" class="headerlink" title="2.1 根目录、绝对路径和相对路径"></a>2.1 根目录、绝对路径和相对路径</h3><p>前面我们演化并展示了，一个struct类型如何变成不同位置的mod，以及我们的main.rs如何引用它。那么，Rust这些模块路径是通过什么原则去寻找的呢？</p><p>回顾一下，我们新建一个Rust工程的时候使用的是cargo new命令，例如，cargo new greeting，即创建了名为greeting的工程，进入greeting目录，tree命令可以看到创建的工程结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── DataSet</span><br><span class="line">│   │   ├── PersonData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   └── main.rs</span><br></pre></td></tr></table></figure><p>其中src是自动生成的，main.rs是自动生成的，而 DateSet目录是后来添加的。</p><p>Cargo.toml则是工程描述文件，包含版本，工程名已经工程的外部依赖项。</p><p>需要编译编译的时候，在greeting目录中，执行cargo build就可以生成二进制文件。如果想生成库文件，则需要加上–lib命令选项，且不需要写main函数。</p><p>这里主要讲的是，在用cargo new生成工程的时候，src目录即为改工程的根目录。在使用mod关键字去引入工程时，会以src为起点作为根目录，去寻找引用的模块。根目录其实可以用crate来代替，例如上面对Person的访问可以写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了从根目录找，当然还会找同文件的mod模块，即本文一开始写的第一个mod，它写在main.rs文件中。</p><p>还有一个寻找路径就是相对路径，即如果在子目录，那么，也会从子目录开始寻找引用的模块。例如我们新增一个House模块在DataSet目录下，并在Hous模块中添加HoseData.rs文件，文件内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的根目录开始的tree命令输出是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── House</span><br><span class="line">│   │   ├── HouseData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>那么如果我们在DataSet模块输出House模块路径是怎么样的呢？直接以DataSet目录为起点（即相对路径）输入出House模块即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br></pre></td></tr></table></figure><p> 这样DataeSet模块就可以对外输出House模块了。当然House模块也需要对外输出它的HouseData模块，即House目录下的mod.rs文件需要：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> HouseData;</span><br></pre></td></tr></table></figure><p>因为任何模块里面的东西都是私有的，需要显示的说它是pub的才行。</p><p>此时我们在main.rs中就能直接访问House模块了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，Rust的寻找路径可以这样：</p><p>1、从根目录开始寻找；</p><p>2、从相对路径开始寻找</p><p>3、从当前兄弟模块开始寻找。</p><p>根目录即src目录，在代码中可以省略或者以crate开头。</p><h3 id="2-2-使用use"><a href="#2-2-使用use" class="headerlink" title="2.2 使用use"></a>2.2 使用use</h3><p>但如此长的名字确实不好打，Rust给我们提供了一个关键字use，我们只写一次就可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>这样，我们的h指针在初始化的时候就不需要写这么多层级了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用pub-use和as"><a href="#2-3-使用pub-use和as" class="headerlink" title="2.3 使用pub use和as"></a>2.3 使用pub use和as</h3><p>设想如果DataSet有更多更深的模块的话，我们的每次使用这些又深名字又长的模块都要写一次use，实在太麻烦，此时我们可以在DataSet里面使用pub use来直接吧HouseInfo导出去：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>用了上面第三行的pub use，HouseInfo就如同DataSet的一个struct一样被导到外面去了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> DataSet::HouseInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用，不管子模块有多深，只要使用一次pub use，后续都不需要重新use一遍长路径。</p><p>在使用use的时候还可以给导出的struct或者模块起个新名字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::HouseInfo <span class="keyword">as</span> DHI;</span><br></pre></td></tr></table></figure><p>  此时，使用HouseInfo的时候我们可以用DHI代替了。</p><h3 id="2-4-使用super"><a href="#2-4-使用super" class="headerlink" title="2.4 使用super"></a>2.4 使用super</h3><p>和crate不同，crate是表示根目录，而super则表示当前目录的上一级目录。</p><p>例如我们在House中想使用PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::super::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里用了两个super，从之前的tree看到，第一个super是PersonData.rs的父目录House，第二个super就是House的父目录DataSet，而PersonData.rs就在DataSet下。我们当然也可以用crate目录（也即根节点去引用PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::DataSet::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-pub-struct和pub-enum"><a href="#2-5-pub-struct和pub-enum" class="headerlink" title="2.5 pub struct和pub enum"></a>2.5 pub struct和pub enum</h2><p>最后要提的是，pub struct和pub enum不同点：</p><p>pub struct只是把struct导出，它的字段，方法还需要再pub来确定是否导出。而enum一旦pub了，它的字段都会变成共有的，都会被导出。</p><h2 id="3-同时引入多个模块"><a href="#3-同时引入多个模块" class="headerlink" title="3. 同时引入多个模块"></a>3. 同时引入多个模块</h2><p>如果需要引入一个模块中多个struct或者其它什么的，可以用大括号来在一行中表示，例如，我们既需要Person也需要HouseInfo，除了写两行use外，还可以这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br><span class="line"><span class="keyword">use</span> DataSet::PersonData::Person;</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::&#123;House::HouseData::HouseInfo, PersonData::Person&#125;;</span><br></pre></td></tr></table></figure><p> 甚至一个*号来表示所有的可以导出的DataSet的东西：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::*;</span><br></pre></td></tr></table></figure><p> 但星号还是谨慎使用，因为比较随意，可能不经意引起名字冲突。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>这一节从main.rs分裂出一个子模块，并把它放到一个目录中，再新建一个子模块到子子目录中，并通过使用mod（引入一个模块），pub（声明struct，方法，字段，enum为公有，或者用来导出struct，函数或者enum）来控制访问模块。</p><p>使用use来引入复杂的层级，使用pub use来导出一个复杂的层级，还可以使用as来给导出或者引入的模块或者类型定义一个新名字。</p><p>再简化总结一下：</p><p>一个crate可以有多个模块，crate的根在src目录。</p><p>使用方：用mod+use来引入模块，mod引入顶层模块，use引入模块中更复杂的层级结构。如果是引入父级目录，则不需要mod，直接use即可。</p><p>导出方：用pub导出字段，struct，方法函数等，用pub use导出层级深的目录结构。</p><p>as可以提供改名的便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
  </entry>
  
</feed>
