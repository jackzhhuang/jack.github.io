<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Huang的技术生活</title>
  
  <subtitle>一些关于技术的思考，想法和积累</subtitle>
  <link href="https://www.jackhuang.cc/atom.xml" rel="self"/>
  
  <link href="https://www.jackhuang.cc/"/>
  <updated>2023-01-31T05:36:42.424Z</updated>
  <id>https://www.jackhuang.cc/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust的RefCell容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-refcell/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-refcell/</id>
    <published>2023-01-29T13:43:59.000Z</published>
    <updated>2023-01-31T05:36:42.424Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了Box&lt;T&gt; 和 Rc&lt;T&gt; 两个指针容器，本节要讲的是 RefCell&lt;T&gt; ，和 Box&lt;T&gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&lt;T&gt; 和  Box&lt;T&gt;有什么不一样呢？</p><span id="more"></span><h2 id="RefCell-lt-T-gt-和-Box-lt-T-gt-的区别"><a href="#RefCell-lt-T-gt-和-Box-lt-T-gt-的区别" class="headerlink" title="RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别"></a>RefCell&lt;T&gt; 和 Box&lt;T&gt; 的区别</h2><p>Rust 的优点（可能也是别人认为的缺点）就是尽可能的在编译时发现问题，令有可能产生问题的代码编译失败，强迫程序员按照既定的规则写代码，从而保证高质量代码。</p><p>例如，Rust 有一条规则：引用一个资源，要么是可变且只允许一个可变引用，要么是不可变的但可以多个不可变引用，决不允许同时存在对一个资源进行可变引用和不可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会产生失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">10</span> |     <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">   |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">11</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">   |                 ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">12</span> |</span><br><span class="line"><span class="number">13</span> |     <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">   |                                    - immutable borrow later used here</span><br></pre></td></tr></table></figure><p>因为此时 b 是不可变引用，而 c 是可变引用，违反了 Rust 的编译规则。</p><p>Box&lt;T&gt; 当然也遵循这点，编译时期 Rust 也检查：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = a.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;, c = &#123;:?&#125;&quot;</span>, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第 10 行 b 从Box 那里得到了一个不可变的Person对象引用，这没问题。但 11 行又试图获得一个 可变的 Person 对象引用，这就违反了 Rust 最基本的规则。</p><p>那么 RefCell&lt;T&gt;  呢？当然也遵守，因为一个可变引用和不可变引用同时存在是很危险的，这会导致数据或者逻辑不一致。但其区别就是，RefCell&lt;T&gt; 是运行时期才检查，编译时期是可以通过的，一旦运行时被发现违反了这个规则，程序就会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    y.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Box&lt;T&gt; 和 Rc&lt;T&gt; 不一样，RefCell&lt;T&gt; 不支持解引用操作（*a），必须显式调用 borrow_mut 方法才能获得其封装的 RefMut&lt;T&gt; 对象， RefMut&lt;T&gt; 才支持 Deref trait。出于可读性，这里不直接用 “&amp;*a.borrow_mut() ” 这样的写法，而是依赖  RefMut&lt;T&gt; 的封装，假设 y 就是 &amp;T （实际上是 RefMut&lt;T&gt;，但其表现得像 &amp;T一样）。</p><p>编译上面的代码，不会像 Box&lt;T&gt; 那样出现失败，而是成功编译，但运行到 11行时，会产生 panic，因为 Rust 不允许可变引用和不可变引用同时存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = RefCell &#123; value: &lt;borrowed&gt; &#125;, y = Person &#123; age: <span class="number">100</span>, name: <span class="string">&quot;jack&quot;</span> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;already</span> mutably borrowed: BorrowError&#x27;, src/main.rs:<span class="number">19</span>:<span class="number">15</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>也可以看到，一旦 x 被可变引用了，其 value 状态变为被借用，如果两个不可变引用同时存在，那么一点问题都不会有：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码正常编译且运行无误。</p><p>由此可见，RefCell和Box 本质区别就在于，虽然只能有唯一的所有权方，但前者是运行时期检查引用规则，若有违反，则panic，后者在编译时期检查引用规则，若有违反，则编译失败。</p><p>当然方法的区别也是有的Box 两个获取 T 引用的方法是 as_ref 和as_mut，而 RefCell 的两个方法是 borrow 和 borrow_mut 。</p><h2 id="RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型"><a href="#RefCell-lt-T-gt-配合-Rc-lt-T-gt-实现多引用可变类型" class="headerlink" title="RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型"></a>RefCell&lt;T&gt; 配合 Rc&lt;T&gt; 实现多引用可变类型</h2><p>我们可以利用Rc&lt;T&gt;的 clone 方法绕过 Rust 的运行时检查，从而获得同时存在多个可变引用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age: <span class="number">99</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    y.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    z.<span class="title function_ invoke__">borrow_mut</span>().age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;, z = &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码首先用 Rc&lt;RefCell&lt;T&gt;&gt; 的方式创建了一个对象 x，它终究是Rc，因此，可以利用Rc::clone() 方法又获得一个 y 和 z，然后我们通过点操作直接调用放在 Rc 里面的 Refcell 的 borrow_mut 方法，最终达到了同时多个可变引用的目的。</p><h2 id="RefCell-lt-T-gt-导致的内存泄漏问题"><a href="#RefCell-lt-T-gt-导致的内存泄漏问题" class="headerlink" title="RefCell&lt;T&gt; 导致的内存泄漏问题"></a>RefCell&lt;T&gt; 导致的内存泄漏问题</h2><p>由于我们可以使用RefCell&lt;Rc&lt;T&gt;&gt; 创建这么一种类型：即可变且多引用的类型，那么，如果有两个节点，相互引用，那么它们的 Rc 永远无法到达0，也就无法被析构，最终造成内存泄漏：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Next</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;Node&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> Node::Next;</span><br><span class="line"><span class="keyword">use</span> Node::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(t, _) = <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the node will be drop, &#123;&#125;&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先 x 和 y 都是 Rc，然后它们内部又有指针指向另一个Rc，初始化的时候先都初始化为 Nil，然后通过RefCell&lt;T&gt; 的可变性，把它们都各指向对方，于是，main 函数结束的时候，x 的Rc减 1，但原始值为 2，因为 y 有它的引用，所以 2 - 1 &#x3D; 1，不为 0，x不析构，同理，y 也不会析构，于是内存泄漏了。</p><p>上面的 p 是用于观察正常情况下析构是否进行的。上面的代码输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the node will be drop, <span class="number">999</span></span><br></pre></td></tr></table></figure><p>x 和 y 不会被析构。</p><p>解决方案是引入 weak&lt;T&gt; 。weak&lt;T&gt; 即若引用，相对于强引用，若引用首先并不获得所有权，也就是若引用计数是不是 0 并不影响对象的析构。因此，weak&lt;T&gt; 可能持有一个无效的 T 引用，所以 weak&lt;T&gt; 获取 T 引用的时候是返回的 Option&lt;T&gt; ，如果 weak&lt;T&gt; 已经无效，则返回 None，如果 weak&lt;T&gt; 依然有效，则返回Some(T) 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n <span class="title function_ invoke__">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = t.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">None</span> = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;it is None initially&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = x.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;y);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of y is &#123;&#125; and strong count of y is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;y), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;y));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(other) = next.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;other = &#123;:?&#125;&quot;</span>, other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Next</span>(_, next) = y.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;x);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the weak count of x is &#123;&#125; and strong count of x is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">weak_count</span>(&amp;x), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Next</span>(<span class="number">999</span>, RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，首先第二三行的代码 RefCell::new(Rc::new(Nil)) 被修改为 RefCell::new(Weak::new()) ，可以看到我们直接用了weak::new() 初始化 weak&lt;T&gt; 指针，因为 weak&lt;T&gt; 并不需要主动初始化，它是 Rc 的弱引用，先有 Rc 才能有 weak&lt;T&gt;。</p><p>先略过 5 到 9 行，x 和 y 初始化结束后，我们把 x 和 y 互相指向对方，注意第 12 行没有再使用 Rc::clone，而是 Rc::downgrade，与 Rc::clone 返回 Rc 不同，Rc::downgrade 返回一个 weak&lt;T&gt; 对象（这也是获得一个可能非None的 weak&lt;T&gt; 对象的方法），赋值给了 x 的 weak&lt;T&gt;。同理，y 这边也是这样。</p><p>这样 x 和 y 都相互引用了对方，但由于是弱引用，因此，即是它们相互引用，也不妨碍最后离开 main 函数时被析构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it is <span class="literal">None</span> initially</span><br><span class="line">the weak count of y is <span class="number">1</span> and strong count of y is <span class="number">1</span></span><br><span class="line">other = <span class="title function_ invoke__">Next</span>(<span class="number">2</span>, RefCell &#123; value: (Weak) &#125;)</span><br><span class="line">the weak count of x is <span class="number">1</span> and strong count of x is <span class="number">1</span></span><br><span class="line">the node will be drop, <span class="number">999</span></span><br><span class="line">the node will be drop, <span class="number">2</span></span><br><span class="line">the node will be drop, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，最后 x 和 y 都被析构了，我们也打印了weak count 和 strong count，都是 1， 结束的时候，x 和 y 都是Rc，因此 strong count 减 1，x 和 y 析构。weak count 不管多少，都不影响 Rc 被析构。 </p><p>weak&lt;T&gt; 不拥有所有权，依靠调用 upgrade 来获取 T 引用，upgrade 返回 Option&lt;T&gt; ，若原 Rc 已经被析构，则返回 None，否则返回 Some(Rc&lt;T&gt;)。没有初始化的情况下，则直接返回None。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left"></th><th>Box&lt;T&gt;</th><th>Rc&lt;T&gt;</th><th>RefCell&lt;T&gt;</th><th>RefMut&lt;T&gt;&#x2F;Ref&lt;T&gt;</th><th>Weak&lt;T&gt;</th></tr></thead><tbody><tr><td align="left">所有权规则</td><td>只有一个所有权</td><td>依靠强引用计数实现多个所有权</td><td>只有一个所有权</td><td>只有一个所有权</td><td>依靠弱引用计数实现多个所有权，但实际并不获得所有权，依靠Option&lt;T&gt; 来判断资源是否有效</td></tr><tr><td align="left">什么时候使用</td><td>1、大资源，想减少拷贝的时候；2、实现多态；3、实现栈分配；4、实现无限大小的对象。</td><td>需要多个所有权方时。</td><td>若Box&lt;T&gt;编译时期规则（一个资源同一个时间内，要么只有一个可变引用，要么有多个不可变引用，禁止可变引用和不可变引用同时存在）检查无法满足需求，需要在运行时检查，则可以使用RefCell&lt;T&gt;。</td><td>由RefCell&lt;T&gt;的borrow_mut&#x2F;borrow方法返回，一般不直接使用。一般情况下，用户不感知这个类的存在。可以认为borrow_mut&#x2F;borrow返回的就是对应的资源引用即可。</td><td>由 Rc&lt;T&gt;的downgrade方法返回，相比Rc&lt;T&gt;的强引用，Weak&lt;T&gt;用于弱引用。</td></tr><tr><td align="left">解引用方法</td><td>实现Deref trait 和 Copy trait，即let b &#x3D; *a。</td><td>因为有引用计数规则，不能直接拿走所有权，因此不能直接解引用获取资源，即禁止let b &#x3D; *a，必须通过 Rc::clone 和self.as_ref 方法对资源进行访问。当然写成 let b &#x3D; &amp;*a（这样没有拿走所有权，不违反规则） 也可以，但可读性差。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。</td><td>同样不允许let b &#x3D; *a这样的操作。应该使用self.upgrade方法（返回Option）判断资源是否有效。</td></tr><tr><td align="left">不可变引用方法</td><td>as_ref</td><td>as_ref</td><td>borrow</td><td>直接点运算操作即可</td><td>upgrade判断返回值Option</td></tr><tr><td align="left">可变引用方法</td><td>as_mut</td><td>不支持，但可以结合 RefCell&lt;T&gt; 实现，即Rc&lt;RefCell&lt;T&gt;&gt;</td><td>borrow_mut</td><td>直接点运算操作即可</td><td>不支持，但可以结合Rc&lt;RefCell&lt;T&gt;&gt;实现。</td></tr></tbody></table><p>注意，以上所有的容器都无法在多线程的时候使用。</p><p>那么，多线程怎么办呢？下面就开始无惧并发的学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了Box&amp;lt;T&amp;gt; 和 Rc&amp;lt;T&amp;gt; 两个指针容器，本节要讲的是 RefCell&amp;lt;T&amp;gt; ，和 Box&amp;lt;T&amp;gt; 一样，都是单所有权属性，且都可以维护可变资源，那么到底 RefCell&amp;lt;T&amp;gt; 和  Box&amp;lt;T&amp;gt;有什么不一样呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="RefCell" scheme="https://www.jackhuang.cc/tags/RefCell/"/>
    
    <category term="智能指针" scheme="https://www.jackhuang.cc/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Rust的Rc容器</title>
    <link href="https://www.jackhuang.cc/2023/01/29/rust-rc/"/>
    <id>https://www.jackhuang.cc/2023/01/29/rust-rc/</id>
    <published>2023-01-29T02:14:33.000Z</published>
    <updated>2023-01-31T05:37:03.589Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了 Box&lt;T&gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&lt;T&gt;了。</p><span id="more"></span><h2 id="使用Rc-lt-T-gt-实现多个不可变资源共享"><a href="#使用Rc-lt-T-gt-实现多个不可变资源共享" class="headerlink" title="使用Rc&lt;T&gt; 实现多个不可变资源共享"></a>使用Rc&lt;T&gt; 实现多个不可变资源共享</h2><p>之前的Box&lt;T&gt;实现了一个如同以下的链表：</p><p><img src="https://www.jackhuang.cc/svg/conforbox.svg" alt="Box\&lt;T\&gt;实现无限链表"></p><p>其代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果串入另一个链表如下，Box&lt;T&gt;就不能实现了，因为Box&lt;T&gt;是只能有一个所有权方的：</p><p><img src="https://www.jackhuang.cc/svg/conforrc.svg" alt="两个链表串起来"></p><p>写成代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   Compiling greeting v0.<span class="number">1.0</span> (/Users/jack/Documents/code/rust/vsrust/greeting)</span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `common_list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> |     <span class="keyword">let</span> <span class="variable">common_list</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">   |         ----------- <span class="keyword">move</span> occurs because `common_list` has <span class="keyword">type</span> `<span class="type">Box</span>&lt;List&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, common_list);</span><br><span class="line">   |                    ----------- value moved here</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, common_list);</span><br><span class="line">   |                      ^^^^^^^^^^^ value used here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>可见，common_list在第12行的时候就给了 a 链表，b 链表想用是用不了了。此时就需要Rc&lt;T&gt;，它和Box&lt;T&gt;不同之处就是它实现了多个不可变对象的共享资源（Box&lt;T&gt;可变不可变资源都可以，但只能有一个所有权方）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::Con;</span><br><span class="line"><span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">common_list</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Con</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">new</span>(Nil))))); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Con</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Con</span>(<span class="number">101</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;common_list));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以正常编译并运行。</p><p>注意，Rc&lt;T&gt; 对象之间在赋值的时候需要使用 Rc::clone 方法，如果直接使用赋值，还是会走到Rust的默认行为：所有权转移。</p><h2 id="顺带一提：clone和copy方法"><a href="#顺带一提：clone和copy方法" class="headerlink" title="顺带一提：clone和copy方法"></a>顺带一提：clone和copy方法</h2><p>顺带提一下 clone 和 copy 方法。clone 和 copy 都是带有复制的意思，但 copy 则比较暴力，是资源的安位拷贝，而 clone 则是和具体是类型实现相关，比如上面的 Rc::clone 实现的是浅拷贝，并且引用计数加 1。而String 的 clone 则是字符串拷贝：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        b = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        std::mem::<span class="title function_ invoke__">drop</span>(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，a 虽然超出作用域，甚至调用了drop，但 b 依然能正常打印，因为 String的 clone 是深拷贝。</p><h2 id="打印计数"><a href="#打印计数" class="headerlink" title="打印计数"></a>打印计数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，每次赋值或者走出作用域后都打印一次Rc的内部计数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line">count = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可见，每次clone，引用计数加 1，对象被销毁，则计数减 1，为 0 时，资源被析构。</p><p>为什么这里用的是 Rc::strong_count 呢？为什么不是调用 Rc::count，因为还有一个 Rc::weak_count 与 Rc::strong_count 对应。这里就引出了一个问题：资源的相互引用。这在引入RefCell&lt;T&gt;  的时候将可能会发生，留待下节讲。</p><h2 id="Rc-lt-T-gt-的方法"><a href="#Rc-lt-T-gt-的方法" class="headerlink" title="Rc&lt;T&gt; 的方法"></a>Rc&lt;T&gt; 的方法</h2><h3 id="解引用"><a href="#解引用" class="headerlink" title="*解引用"></a>*解引用</h3><p>和Box不一样，Box 我们可以通过解引用的方式获得 T 的所有权，但如果我们对Rc进行解引用，那么会编译错误，因为这样越过 Rc 的计数法则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只能得到 Rc&lt;T&gt;  的引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;*x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>修改成 &amp;*x 后 y 将是 Person 的对象引用，一切正常。</p><p>这种方式也是安全的，因为编译器在编译的时候就会检查无误，不会出现悬挂指针。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>调用 &amp;*x 可读性实在是比较差，调用 as_ref 则清晰很多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age:<span class="number">99</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>和 &amp;*x 等效。</p><h3 id="没有-as-mut"><a href="#没有-as-mut" class="headerlink" title="没有 as_mut"></a>没有 as_mut</h3><p>Rc&lt;T&gt; 不会提供可变 T 引用方法，因为它是针对不可变 T 来设计的。</p><h2 id="什么时候使用-Rc-lt-T-gt"><a href="#什么时候使用-Rc-lt-T-gt" class="headerlink" title="什么时候使用 Rc&lt;T&gt;"></a>什么时候使用 Rc&lt;T&gt;</h2><p>如果 Box这种只能有一方所有权的容器无法满足需求，且不涉及可变资源，那么就可以使用 Rc&lt;T&gt; 了。简单来说可以按以下步骤来确定是否可以使用Rc&lt;T&gt;：</p><p>1、能用 Box&lt;T&gt; 那就用；</p><p>2、若不能用  Box&lt;T&gt;，比如需要多个所有权方，且不涉及可变资源，那么使用 Rc&lt;T&gt;。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Rc&lt;T&gt; 和 Box&lt;T&gt; 一样，都实现了Deref 和 Drop 这两个 trait，即解引用（*a  操作）和 自动析构；</p><p>2、Rc&lt;T&gt; 通过引用计数维护不可变资源是否应该释放，当引用计数为 0 的时候资源将被释放；</p><p>3、应该通过 Rc::clone 来赋值，因为不同的类型 clone 有不同的实现，而如果不用 clone 方法则会发生所有权转移；</p><p>4、和Box&lt;T&gt; 一样，Rc&lt;T&gt; 也是一个单线程容器，不允许多线程使用；</p><p>5、使用as_ref 提高可读性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了 Box&amp;lt;T&amp;gt; ，和一般的变量一样，它只能有一个所有权方，如果需要有多个所有权，即实现类似（不完全一样，因为Rust只要你不说，都是不可变的）python那样的所有权复制，就需要Rc&amp;lt;T&amp;gt;了。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="Smart Pointer" scheme="https://www.jackhuang.cc/tags/Smart-Pointer/"/>
    
    <category term="智能指针" scheme="https://www.jackhuang.cc/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Rust的box容器</title>
    <link href="https://www.jackhuang.cc/2023/01/28/rust-box/"/>
    <id>https://www.jackhuang.cc/2023/01/28/rust-box/</id>
    <published>2023-01-28T00:22:51.000Z</published>
    <updated>2023-01-31T05:44:54.158Z</updated>
    
    <content type="html"><![CDATA[<p>Box&lt;T&gt;就是模仿Rust的指针行为：</p><p>1、可以解引用访问，即*a操作；</p><p>2、超出生命范围区域会主动释放资源。</p><p>Rust还提供了Rc&lt;T&gt;，RefCell&lt;T&gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&lt;T&gt;。</p> <span id="more"></span><h2 id="为什么需要-Box-lt-T-gt"><a href="#为什么需要-Box-lt-T-gt" class="headerlink" title="为什么需要 Box&lt;T&gt;"></a>为什么需要 Box&lt;T&gt;</h2><p>Rust最大的优点定（当然可能也是一把双刃剑）就是编译的时候确定实体大小。但总有需要运行时才知道的时候，例如多态（往后会讲），或者例如本例这种struct&#x2F;enum类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 List 枚举的Con 类型绑定了一个 i32 和 另一个 List，因此它的大小在编译的时候无论如何都是未知的。编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> | <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  | ^^^^^^^^^ recursive <span class="keyword">type</span> <span class="title class_">has</span> infinite size</span><br><span class="line"><span class="number">3</span> |     <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, List),</span><br><span class="line">  |              ---- recursive without indirection</span><br></pre></td></tr></table></figure><p>这是因为编译的时候编译器就需要给它一个大小定义。这时就可以使用Box&lt;T&gt;来做到确定的大小。当然Box&lt;T&gt;不是未卜先知，而是编译器看到Box&lt;T&gt;就知道它是一个固定大小的struct，因为Box&lt;T&gt;封装了T的原始指针，它的大小是已知的。我们修改List定义，并sizeof打印它的大小：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Con</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof i32 = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">i32</span>&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;List&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;List&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;f64&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">f64</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof Box&lt;i16&gt; = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">Box</span>&lt;<span class="type">i16</span>&gt;&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sizeof list = &#123;&#125;&quot;</span>, std::mem::size_of::&lt;List&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sizeof <span class="type">i32</span> = <span class="number">4</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;List&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">f64</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof <span class="type">Box</span>&lt;<span class="type">i16</span>&gt; = <span class="number">8</span></span><br><span class="line">sizeof list = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这里可以看到，不管 Box&lt;T&gt; 的 T 是什么，其大小都是 8，因为  Box&lt;T&gt;其实就是一个封装了 unsafe 原始指针，不管 T 是什么，其大小都是 *mut T，即 8个字节（指针大小）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: *<span class="keyword">mut</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust的标准库大多数都是使用unsafe机制实现的，也就是unsafe代码实现了一套safe库。在其中用sta::alloc库实现了 unsafe 内存分配和释放。</p><p>因此，当我们无法在编译时期就能确定一个 T 的具体大小时（比如 T 是一个 trait，我们不知道 trait 背后的具体对象是什么的时候），就需要Box&lt;T&gt;。另外，Box&lt;T&gt;还可以让对象生命周期延长到其范围之外，即Box&lt;T&gt;封装了一个栈对象。</p><h2 id="实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait"><a href="#实现一个自己的-Box-lt-T-gt-——-理解-Deref-和-Drop-trait" class="headerlink" title="实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait"></a>实现一个自己的 Box&lt;T&gt; —— 理解 Deref 和 Drop trait</h2><h3 id="定义-MyBox-lt-T-gt"><a href="#定义-MyBox-lt-T-gt" class="headerlink" title="定义 MyBox&lt;T&gt;"></a>定义 MyBox&lt;T&gt;</h3><p>MyBox&lt;T&gt;是一个空struct，但它绑定了一个 T 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure><p>new的时候返回MyBox&lt;T&gt;对象即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deref-方法"><a href="#deref-方法" class="headerlink" title="deref 方法"></a>deref 方法</h3><p>为了让MyBox&lt;T&gt;能做到解引用（*），我们必须实现 Deref trait，其中就是要实现deref方法，它就是返回一个 &amp;T：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a 是一个 Box&lt;T&gt; 的话，那么调用 *a 就相当于在调用 *(a.deref())。即获得 T 对象。</p><h3 id="drop-方法"><a href="#drop-方法" class="headerlink" title="drop 方法"></a>drop 方法</h3><p>接着就是Drop trait，即在超出作用域的时候会调用，类似析构函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;nothing to do but println it to see it was called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察分配和析构"><a href="#观察分配和析构" class="headerlink" title="观察分配和析构"></a>观察分配和析构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 a 将会 act like a dynamic pointer，即支持 *a 运算（相当于调用了 a.deref() ），当作用域走出 main 函数后，a会自动销毁，此时a.drop() 被调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">what the a is: <span class="number">100</span></span><br><span class="line">nothing to <span class="keyword">do</span> but println it to see it was called</span><br></pre></td></tr></table></figure><h3 id="主动析构"><a href="#主动析构" class="headerlink" title="主动析构"></a>主动析构</h3><p>有些时候我们想主动析构一个box对象，比如主动释放连接之类的，但如果我们主动的调用drop是会编译失败的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会发现编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">23</span>:<span class="number">7</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> |     a.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">   |     --^^^^--</span><br><span class="line">   |     | |</span><br><span class="line">   |     | explicit destructor calls not allowed</span><br><span class="line">   |     help: consider using `drop` function: `<span class="title function_ invoke__">drop</span>(a)`</span><br></pre></td></tr></table></figure><p>这里也给出了提示，使用std::mem::drop 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;what the a is: &#123;&#125;&quot;</span>, *a);</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以主动析构 Box了。</p><h2 id="Box-lt-T-gt-的方法"><a href="#Box-lt-T-gt-的方法" class="headerlink" title="Box&lt;T&gt; 的方法"></a>Box&lt;T&gt; 的方法</h2><p>Box&lt;T&gt; 提供了一些方法供我们访问被封装的对象，但注意这种方式打破了 Box&lt;T&gt;的封装，不过好在 Box&lt;T&gt; 是编译时就能检查所有权和引用规则，所以一般不会出问题（要出也是编译时期就被检查出来），相对这个来讲，RefCell 就比较危险了。</p><h3 id="使用-解引用"><a href="#使用-解引用" class="headerlink" title="使用*解引用"></a>使用*解引用</h3><p>解引用操作会使 Box&lt;T&gt; 返回被封装的对象，这会造成 Box&lt;T&gt;  失去对 T 对象的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">     age:<span class="number">99</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>上面的第 4 行代码会使得 x 失去对 Person对象的所有权，编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">16</span>:<span class="number">36</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = *x;</span><br><span class="line">   |                 -- value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">   |                                    ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>当然其实 改为 let mut y &#x3D; x; 也会使 x:  Box&lt;T&gt;  失去所有权。</p><h3 id="as-ref"><a href="#as-ref" class="headerlink" title="as_ref"></a>as_ref</h3><p>使用as_ref 方法则获得 Box&lt;T&gt; 的 T 引用。除非函数参数必须传入引用，否则一般情况下也不需要使用这个方法，好在不管怎么样，编译器都会帮助我们检查悬空指针的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_age</span>(p: &amp;Person) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">print_age</span>(x.<span class="title function_ invoke__">as_ref</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h3 id="as-mut"><a href="#as-mut" class="headerlink" title="as_mut"></a>as_mut</h3><p>相比as_ref，as_mut 则返回一个可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change_age</span>(p: &amp;<span class="keyword">mut</span> Person) &#123;</span><br><span class="line">    p.age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of p is &#123;&#125;&quot;</span>, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">        age:<span class="number">99</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">change_age</span>(x.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the age of x is &#123;&#125;&quot;</span>, x.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，因为是返回的引用，不像解引用那样，x 不会失去所有权。</p><h2 id="什么时候需要使用-Box-lt-T-gt"><a href="#什么时候需要使用-Box-lt-T-gt" class="headerlink" title="什么时候需要使用 Box&lt;T&gt;"></a>什么时候需要使用 Box&lt;T&gt;</h2><p>总结看来，Box&lt;T&gt; 是一个其实是对 unsafe 指针的封装，那么什么时候会使用Box&lt;T&gt; 呢？一般以下几种情况可以使用：</p><p>1、当 T 是一个大 size 类型时，可以减少拷贝；</p><p>2、需要实现堆的内存特性，即如果资源超出作用域依然不想析构，此时可以用 Box&lt;T&gt; 传递出去；例如在函数中分配内存，在函数外使用，如果不使用 Box&lt;T&gt;，那么代码看起来像这样： </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="keyword">dyn</span> SelfIntroduce &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        SchoolType::school_teacher =&gt; Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 和 Teacher 两个对象都会在函数结束的时候被析构调，外面的使用方将会变成悬挂指针。但如果改成Box&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">school_maker</span>(t: SchoolType) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> SelfIntroduce&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        SchoolType::school_student =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Student &#123;</span><br><span class="line">            name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">            no: <span class="number">47</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        SchoolType::school_teacher =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Teacher &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bill&quot;</span>),</span><br><span class="line">        id: <span class="number">99265247</span>,</span><br><span class="line">        &#125;),   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当函数返回的时候，内部的 Box&lt;T&gt; 将指针所有权全传递给外面使用方，指针所指资源依然存在不会被析构。</p><p>3、正如上面的例子，Student 和 Teacher 都实现了 SelfIntroduce trait，因此可以使用 Box&lt;T&gt; 来实现多态；</p><p>4、也正如最开始的例子，如果是一个无限大的 struct&#x2F;enum，那么也可以用 Box&lt;T&gt;，因为 Box&lt;T&gt; 是对指针的封装，大小总是固定的，可以在编译时确定。</p><h2 id="Box-lt-T-gt-要留意的地方"><a href="#Box-lt-T-gt-要留意的地方" class="headerlink" title="Box&lt;T&gt; 要留意的地方"></a>Box&lt;T&gt; 要留意的地方</h2><p>1、Box&lt;T&gt; 只能有一个所有权方；</p><p>2、Box&lt;T&gt; 只能单线程使用；</p><p>3、Box&lt;T&gt; 的三个方法（解引用，as_ref 和 as_mut）可以让我们方法 T 对象，解引用可能会失去所有权，而引用不会，编译器会检查，防止悬空指针出现。</p><p>那么如果需要多个所有权就需要后面讲的 Rc&lt;T&gt; 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Box&amp;lt;T&amp;gt;就是模仿Rust的指针行为：&lt;/p&gt;
&lt;p&gt;1、可以解引用访问，即*a操作；&lt;/p&gt;
&lt;p&gt;2、超出生命范围区域会主动释放资源。&lt;/p&gt;
&lt;p&gt;Rust还提供了Rc&amp;lt;T&amp;gt;，RefCell&amp;lt;T&amp;gt;等专门为各种场景使用的容器类，内容太多太细节，打算都当作单独的一节来讲，这一节就专注于box&amp;lt;T&amp;gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="Box&lt;T&gt;" scheme="https://www.jackhuang.cc/tags/Box-T/"/>
    
    <category term="智能指针" scheme="https://www.jackhuang.cc/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Rust的工作空间（workspace）</title>
    <link href="https://www.jackhuang.cc/2023/01/26/rust-workspace/"/>
    <id>https://www.jackhuang.cc/2023/01/26/rust-workspace/</id>
    <published>2023-01-26T09:27:20.000Z</published>
    <updated>2023-01-27T02:29:48.490Z</updated>
    
    <content type="html"><![CDATA[<p>前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。</p><span id="more"></span><h2 id="为什么需要workspace"><a href="#为什么需要workspace" class="headerlink" title="为什么需要workspace"></a>为什么需要workspace</h2><p>正如前面所说，项目中，个人既要能做到对自己的代码进行单元测试，也要能和别人的代码进行集成测试，因此，项目必须能同时满足独立构建和协同构建。Rust 的workspace正是这个概念。它可以创建独立的 library 工程，也可以同时对几个 library 工程进行依赖构建，也即独立工作时可以非常独立，需要协作时又能迅速集成，期间不需要太多复杂的操作，仅仅只是从工程子目录切换到工程workspace目录，简单而有效。</p><h2 id="如何构建workspace"><a href="#如何构建workspace" class="headerlink" title="如何构建workspace"></a>如何构建workspace</h2><p>我们以 <a href="https://github.com/jackzhhuang/rscount">https://github.com/jackzhhuang/rscount</a> 为例，说说workspace的结构是怎么样子的。</p><p>首先，切换到 workspace_example 分支，因为master分支还在开发中，可能目录结构等等都会变化，为了说明 workspace 结构，我新拉了一个示例分支用来讲 workspace 的结构。</p><p>拉取分支后，可以看到，其目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rscount</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── rsconfig</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── config.rs</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── rscount_main</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── rsfile</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src</span><br><span class="line">        ├── lib.rs</span><br><span class="line">        ├── rs_code_dir.rs</span><br><span class="line">        └── rs_code_file.rs</span><br></pre></td></tr></table></figure><p>首先 rscount 就是我们的workspace根目录，这个目录是用mkdir命令创建的，cd进入rscount就可以开始workspace的创建了。</p><p>需要说的是，rscount&#x2F;Cargo.toml 是 workspace 的结构说明，里面主要展示 workspace 都有哪些子工程，该文件内容是手动写入的，每创建一个子工程就需要手动写入一次工程名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;rscount_main&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsfile&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rsconfig&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，一共有三个子工程，名字分别是：rscount_main，rsfile和rsconfig。这些子工程都是用 cargo new 命令来创建的。对于 rscount_main 这种执行文件工程，直接在rscount目录下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new rscount_main</span><br></pre></td></tr></table></figure><p>即可。</p><p>而对于rsfile和rsconfig，因为是 library 工程，需要加上 –lib参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new rsfile --lib</span><br><span class="line">cargo new rsconfig --lib</span><br></pre></td></tr></table></figure><p>创建好这些工程后，就可以写代码编译了，当然可以一起编译，即在rscount下cargo build，也可以分别在各个子工程下分别编译。这里还需要注意的是，rscount_main依赖了rsfile和rsconfig两个工程，因此需要在其rscount_main&#x2F;Cargo.toml中告诉编译器这个依赖关系：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="设置编译选项-编译release版本"><a href="#设置编译选项-编译release版本" class="headerlink" title="设置编译选项-编译release版本"></a>设置编译选项-编译release版本</h2><p>编译的时候，cargo build加上 –release参数即可编译release版本，我们还可以指定release版本的参数，比如最常见的优化级别，debug版本优化级别我们设置为0，release版本优化级别设置为3:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>还有很多编译选项可以甚至，具体可以参考官方文档。</p><h2 id="使用crates-io"><a href="#使用crates-io" class="headerlink" title="使用crates.io"></a>使用crates.io</h2><p>除了自己写 library，还可以求助crates.io，上面有很多其他人编写的 libray库，例如我们需要mysql客户端库，但我们不想自己写一个，肯定有人已经写好了，于是我们上crates.io搜索mysql： <img src="https://www.jackhuang.cc/images/WX20230127-101853@2x.png" alt="使用create.io搜索第三方库"></p><p>​将mysql这个库写入dependencies中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rsfile = &#123; path = <span class="string">&quot;../rsfile&quot;</span>&#125;</span><br><span class="line">rsconfig = &#123; path = <span class="string">&quot;../rsconfig&quot;</span>&#125;</span><br><span class="line">mysql = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>然后编译，可以看到cargo可以自动下载库并建立依赖，直接使用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面的例子，都是通过cargo new命令来创建的单一工程，但实际开发中，每一个模块都是由多个单独的领域组合起来构建的，因此这里引入workspace概念。有了workspace概念，一个项目才可以方便的划分成不同的领域，每一个领域能做到单元测试，单独构建，而整个workspace又能做集成测试，集成构建。这样，单人工作和团队协作才能有机结合起来。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="workspace" scheme="https://www.jackhuang.cc/tags/workspace/"/>
    
  </entry>
  
  <entry>
    <title>闭包和迭代器</title>
    <link href="https://www.jackhuang.cc/2023/01/25/closure-and-iter/"/>
    <id>https://www.jackhuang.cc/2023/01/25/closure-and-iter/</id>
    <published>2023-01-25T06:44:32.000Z</published>
    <updated>2023-01-25T15:15:05.657Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。</p><span id="more"></span><h2 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h2><p>闭包，即closure，简单说即：</p><p>1、匿名函数；</p><p>2、可以当作value赋值，灵活调用；</p><p>3、闭包的入参和出参除了定义闭包的时候可以指定，还可以由编译器推断（这样更简洁）。</p><p>以下是最简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>(), </span><br><span class="line">                              <span class="string">&quot;hello rust!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                              <span class="string">&quot;hello jack!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),];</span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;print in closure: &#123;&#125;&quot;</span>, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的闭包即“|x| println!(“print in closure: {}”, x)”，这是一个匿名函数，入参为x，编译器会推理为String，根据代码的实现，没有返回参数，只是简单的打印了String的值。</p><p>关于闭包这里不在对其定义阐述更多基本的内容，只需要知道，Rust的闭包入参和出参都是可以依靠编译器推断的就行，关键是Rust的闭包相对于其它语言需要留意的地方。</p><h3 id="是move还是引用？"><a href="#是move还是引用？" class="headerlink" title="是move还是引用？"></a>是move还是引用？</h3><p>闭包最大的特点就是可以capture上下文变量，那么，这个capture在Rust中是move还是引用呢？答案是：引用。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面的例子中，show这个闭包不接受任何参数，但capture了上面的list，show被调用后，list所有权没有被show拿走，依然还在，第7行正常打印list。</p><p>那么，如果闭包就是像move走所有权呢？需要在闭包的前面加上move：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>此时编译出错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `list`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">51</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">4</span>  |     <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">   |         ---- <span class="keyword">move</span> occurs because `list` has <span class="keyword">type</span> `<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">show</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">   |                ------- value moved into closure here</span><br><span class="line"><span class="number">6</span>  |         <span class="built_in">println!</span>(<span class="string">&quot;list in side the colosure: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                     ---- variable moved due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> |     <span class="built_in">println!</span>(<span class="string">&quot;list after calling the show: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">   |                                                   ^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>因为list的所有权被show拿走了，最后的print对list的访问将会报错。</p><h3 id="mut闭包"><a href="#mut闭包" class="headerlink" title="mut闭包"></a>mut闭包</h3><p>默认情况下，和Rust基本特性一样，闭包对上下文的capture都是immutable的，如果需要在闭包中更改变量，除了被capture的上下文需要是mut的以外，闭包也需要声明为mut：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">more</span> = || &#123;</span><br><span class="line">    list.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">more</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>上面这个例子中，list和more都需要mut才能编译通过。</p><h3 id="FnOnce，-FnMut和Fn"><a href="#FnOnce，-FnMut和Fn" class="headerlink" title="FnOnce， FnMut和Fn"></a>FnOnce， FnMut和Fn</h3><p>闭包结合Rust的所有权特性，会对闭包的调用有所限制。闭包的trait有三个：FnOnce，FnMut和Fn。</p><p>FnOnce，顾名思义，表示因为有所有权转移，该闭包只能被调用一次。</p><p>FnMut，Mut即表示改变的意思，意思是该闭包会修改上下文变量，但不会产生所有权转移。</p><p>Fn则比较佛性，即不修改上下文变量名，也不产生所有权转移。</p><p>看下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">70</span>,</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = Rectangle &#123;</span><br><span class="line">        height:<span class="number">100</span>,</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[r1, r2, r3];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;return once&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">operation</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the list is &#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本意是调用一次sort_by_key方法就会push一次字符串，但编译不通过的是，sort_by_key的入参中，闭包需要是FnMut，可上面的代码中，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|r| &#123;</span><br><span class="line">        operation.<span class="title function_ invoke__">push</span>(s);</span><br><span class="line">        r.width</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只能被调用一次，因为第二次s已经没所有权了，即此时闭包的trait是FnOnce属性的，打开sort_by_key方法的代码可以发现的确是需要FnMut的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(no_global_oom_handling))]</span></span><br><span class="line">  <span class="meta">#[rustc_allow_incoherent_impl]</span></span><br><span class="line">  <span class="meta">#[stable(feature = <span class="string">&quot;slice_sort_by_key&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">  <span class="meta">#[inline]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort_by_key</span>&lt;K, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> f: F)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">      F: <span class="title function_ invoke__">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> K,</span><br><span class="line">      K: <span class="built_in">Ord</span>,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="title function_ invoke__">merge_sort</span>(<span class="keyword">self</span>, |a, b| <span class="title function_ invoke__">f</span>(a).<span class="title function_ invoke__">lt</span>(&amp;<span class="title function_ invoke__">f</span>(b)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>闭包是迭代器最常用的工具，而迭代器又是批处理集合最常用的方法，下面我们就看看Rust的迭代器是怎么用的吧。</p><h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>迭代器是Rust处理集合最最最常用的方法，可以说没有之一。如果依然使用for语句去处理集合，一来不够Rust，二来效率不如迭代器快，因为迭代器是零成本抽象实现。</p><p>关于零成本抽象有很多介绍，但很多人不太理解，这里尝试用最简单的人话说：即只仅仅实现需要的代码，无需额外的代码（成本）。</p><p>再简单一步说，即人类目前设计出最抽象的代码，以至于你不可能再写出更抽象的了（如果可以，请提交PR），因为已经是最抽象的代码，已经没有简化优化的空间，因此效率是最高的。</p><p>迭代器就是高度零成本抽象的代码，我们应该尽可能使用迭代器去处理集合，而不是写for语句。</p><p>Rust中迭代器是一个trait，基本定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of the elements being iterated over.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>其主要的方法是next，每次调用next迭代器都会返回当前元素Some(T)，并且跳到下一个元素，直到所有元素被完全枚举，此时返回None。如果自己定义一个集合也想有迭代器trait，那么也需要去实现这个next方法。</p><p>从上面看出，迭代器是有状态的，即它会记录目前在集合中的位置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><p>那么，当手里拿着一个集合时，如果需要逐个处理，我们应该首先把它变成迭代器，Rust的集合有三个不同的迭代器变化方法，分别对应三个用途，即：iter，into_iter和iter_mut。</p><h3 id="iter，into-iter和iter-mut"><a href="#iter，into-iter和iter-mut" class="headerlink" title="iter，into_iter和iter_mut"></a>iter，into_iter和iter_mut</h3><p>iter是把集合转成引用迭代器，即访问集合元素时以引用的方式访问，不会有所有权转移。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">     <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line"> ];</span><br><span class="line"></span><br><span class="line"> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面第7行 x 其实是&amp;String，因此第9行访问 v 时，v 依然时有效的集合。顺便所一下，for_each会拉起对集合的处理流程，即对每一个元素都以参数的方式传入 for_each 中的闭包，即上面的 x。</p><p>如果改成into_iter方法，那么 x 就会变成 String，导致 v 中元素对 String 所有权丢失（都跑 x 去了）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> |     v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line">   |       ----------- `v` moved due to this method call</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> |     <span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">   |                              ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>而 iter_mut 即上面的 x 为可变引用（&amp;mut String），注意此时集合本身也必须是可变的才行。这里不多举例了。</p><p>稍微总结一下：</p><p>iter方法：转为引用访问的迭代器，因此没有所有权转移；</p><p>into_iter方法：转为所有权转移的迭代器，因此集合会丧失对所有元素的所有权；</p><p>iter_mut：转为可变引用访问的迭代器，因此也没有所有权转移，且还可以修改元素。</p><h3 id="map和collect"><a href="#map和collect" class="headerlink" title="map和collect"></a>map和collect</h3><p>前面演示了迭代器的 for_each 方法，它只是遍历一遍元素，实际上我们不仅可以遍历一遍元素，还可以把这些被处理的元素以新的集合返回出来，例如map和collect组合，我们先用map：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面的例子中 map 的 x 就是&amp;mut String，我们对 x 进行追加一个 “!”  操作，它作为返回值返回给新的迭代器，但这里并没有把新的迭代器写出来，编译执行以上代码，发现 v 并没有变化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all v = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello rust&quot;</span>, <span class="string">&quot;hello jack&quot;</span>]</span><br></pre></td></tr></table></figure><p> 这是怎么回事呢？因为和 for_each 不同，map 是个偷懒的函数，如果没有新的迭代器去装返回值，那么它就不会被触发，另外，新的迭代器类型是靠返回值类型来推断出来的，我们可以用其它迭代器来装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust&quot;</span>),</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list</span>: LinkedList&lt;_&gt; = v.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>); </span><br><span class="line">    x.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">&#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;all list = &#123;:?&#125;&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>这里用了 LinkedList&lt;_&gt; 来装。调用迭代器的collect方法会迫使迭代器去产生新的迭代器进而产生新的集合。</p><p>为什么这里 LinkedList&lt;_&gt; 省略了模板类型呢？用了下划线 _ 来代替，因为编译器可以推理出下划线 _ 即 String，我们可以省略不写太多字母。</p><p>此外，我们的map中的闭包返回了 x.clone()，即&amp;mut String的 clone，这是因为如果返回 x，即 LinkedList&lt;_&gt;为LinkedList&lt;&amp;mut String&gt;，最后两句print宏会产生歧义，即 v 是immutable引用，而v是mutable引用，Rust不允许对同一个对象即有mut又有immut引用。</p><p>总之，我们可以用迭代器产生新的迭代器，其产生映射可以用 map 函数来生成新的集合元素，map返回新的迭代器。</p><p>而用迭代器的 collect方法把迭代器重新变回为集合，集合类型可以用返回值推导出来。这是最常用的方法了。</p><p>除了map，还有不少其它引射方法，比如filter，其输入的闭包若返回true则进入到新的迭代器中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evens</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evens = &#123;:?&#125;&quot;</span>, evens);</span><br></pre></td></tr></table></figure><p>输出为偶数集合：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;闭包和迭代器很多语言都有，Rust也不例外，并且，数量掌握闭包和迭代器是写出一手好代码的必要因素。今天就把这两个概念拿出来说说。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="Closure" scheme="https://www.jackhuang.cc/tags/Closure/"/>
    
    <category term="Iterator" scheme="https://www.jackhuang.cc/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>Rust的测试框架</title>
    <link href="https://www.jackhuang.cc/2023/01/21/rust-test/"/>
    <id>https://www.jackhuang.cc/2023/01/21/rust-test/</id>
    <published>2023-01-21T01:16:18.000Z</published>
    <updated>2023-01-22T11:09:10.165Z</updated>
    
    <content type="html"><![CDATA[<p>测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。</p><span id="more"></span><h2 id="生成测试框架"><a href="#生成测试框架" class="headerlink" title="生成测试框架"></a>生成测试框架</h2><p>在生成 library 库的时候，Rust一定会生成一个简单的测试模板，例如，我们建立一个名叫jacktest的库：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new jacktest --lib</span><br></pre></td></tr></table></figure><p>此时就会在src目录下生成lib.rs文件，里面就是一个简单的测试模板，简单的对 2+2 进行测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里先注意到的是之前我们用过的一个语法 #[]，即表明增加某个属性（attribute），比如之前用的 #[derive(Debug)] 就是指这是一个派生（derive）属性，具体属性为Debug，即这个struct可以用于Debug，比如格式化打印观察里面的数据。</p><p>这里 #[test] 则表示it_works是一个 testing 函数，会被命令cargo test调起。执行cargo test后，会打印出it_works被执行的测试信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们就可以自己添加自己想要测试的内容了。这里不去讨论太多assert宏的使用，这个在官方文档花了大量篇幅介绍，这里不去一一介绍那些assert宏。关于assert宏的要说的有两点：</p><h3 id="assert宏的应用"><a href="#assert宏的应用" class="headerlink" title="assert宏的应用"></a>assert宏的应用</h3><p>第一，我们应该尽量选择合适的assert去体现测试原意，比如计算两个值是否相等，使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b);</span><br></pre></td></tr></table></figure><p>就比使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(a == b);</span><br></pre></td></tr></table></figure><p>要好。因为assert_eq出来的信息比assert出来的信息更能反映测试目的。</p><p>第二，assert后面可以打印一些format信息帮助我们在看测试结果的时候能看到更多有用的信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>测试框架遇到panic会直接报错，但和平常的panic处理方法不同，测试框架里面的panic不会停止测试流程，只是单个测试会中断而已，例如我们在上一个测试代码中增加一个测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_will_panic</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;something goes wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试框架还是会执行其它的测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line"><span class="keyword">in</span> partial_cmp of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">240</span></span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_will_panic&#x27; panicked at <span class="symbol">&#x27;something</span> goes wrong!&#x27;, src/lib.rs:<span class="number">41</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line">test tests::equal ... ok</span><br><span class="line">test tests::it_will_panic ... FAILED</span><br></pre></td></tr></table></figure><p>这是因为测试框架是用多线程来拉起测试用例的，某一个用例panic只会影响某一个线程，不会使整个测试框架进程都退出。</p><p>panic也可以format我们输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;the value is &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><h3 id="should-panic"><a href="#should-panic" class="headerlink" title="should_panic"></a>should_panic</h3><p>有些时候panic就是我们所期望的，特别是我们需要测试一些失败用例的情况下，比如设计一个类，关联一个 1 到 100 的数字，如果输入不在这个范围内则panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果输入200到new方法中，则理应在13行panic，这是我们期待的，但如果直接执行测试，那结果是不通过的，这时就需要should_panic宏来告诉测试框架，这个是我们期待的panic，可以认为通过。那么怎么告诉呢，其原理是检查panic宏打印的log是否包含should_panic中指定的字符串，如果包含，则认为如预期panic，测试用例通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，#[should_panic(expected &#x3D; “less than or equal to 100”)] 就是指定期待panic的地方，其中expect所等于的字符串，就是子串，只要逻辑代码中panic信息包含这个子串，那么认为测试通过而不是报失败。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::greater_than_100 - should panic ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests jacktest</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><p>如果我们交换Guess函数中 if - else 语句的panic，此时panic信息自然就不是期待的那样了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">        value</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行测试，走入if value &gt; 100分支中，但提示信息和should_panic不一样，那么会被判定为不期待的panic，测试失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">note: panic did not contain expected string</span><br><span class="line">      panic message: `<span class="string">&quot;Guess value must be greater than or equal to 1, got 200.&quot;</span>`,</span><br><span class="line"> expected substring: `<span class="string">&quot;less than or equal to 100&quot;</span>`</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::greater_than_100</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">0</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h2 id="控制测试框架"><a href="#控制测试框架" class="headerlink" title="控制测试框架"></a>控制测试框架</h2><h3 id="测试框架的参数"><a href="#测试框架的参数" class="headerlink" title="测试框架的参数"></a>测试框架的参数</h3><p>测试框架参数分成两种，一种用于过滤测试代码用例（比如执行或者不执行某些测试用例），一种是用来控制测试框架行为的（比如用例的执行方式，怎么打印信息等）。</p><p>两种参数用 – 隔离。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test 测试用例过滤参数 -- 控制测试框架行为参数</span><br></pre></td></tr></table></figure><h3 id="控制测试用例行为"><a href="#控制测试用例行为" class="headerlink" title="控制测试用例行为"></a>控制测试用例行为</h3><h4 id="控制测试线程数量"><a href="#控制测试线程数量" class="headerlink" title="控制测试线程数量"></a>控制测试线程数量</h4><p>之前也提到过，测试框架使用的是多线程拉起各个测试用例的，也就是测试用例是并行运行的，一般情况下不会有什么问题，但如果比如两个用例同时写一个文件那么久会出现不可预知的后果，这时就需要我们告诉测试框架，使用单线程去执行用例，这个是控制测试框架行为的，所以放在 – 的右边：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --test_threads=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就不会有并发运行测试了。</p><h4 id="在测试流程中打印print信息"><a href="#在测试流程中打印print信息" class="headerlink" title="在测试流程中打印print信息"></a>在测试流程中打印print信息</h4><p>假设我们现在有一个矩形面积类：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要测试哪个矩形的面积哪个面积大，那么我们必须先实现PartialEq（需要实现eq方法）和PartialOrd（需要实现partial_cmp方法）这两个trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialEq</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eq</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in eq of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() == other.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialOrd</span> <span class="keyword">for</span> <span class="title class_">RectangcleArea</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">partial_cmp</span>(&amp;<span class="keyword">self</span>, other: &amp;RectangcleArea) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;std::cmp::Ordering&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in partial_cmp of RectangcleArea, &#123;&#125;&#x27;s area = &#123;&#125; and &#123;&#125;&#x27;s area = &#123;&#125;&quot;</span>, </span><br><span class="line">                 <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>(), other.name, other.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() &gt; other.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Greater);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(std::cmp::Ordering::Less);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但我们在进行测试的时候，发现println!并没有打印出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            width: <span class="number">10</span>,</span><br><span class="line">            name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">            height: <span class="number">120</span>,</span><br><span class="line">            width: <span class="number">2</span>,</span><br><span class="line">            name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是因为cargo test不会打印出标准输入输出，为了打印print信息，控制测试框架行为，需要这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --nocapture</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output</span><br></pre></td></tr></table></figure><p>这样，我们在代码中print出来的数据就能看到了。</p><h3 id="过滤测试用例"><a href="#过滤测试用例" class="headerlink" title="过滤测试用例"></a>过滤测试用例</h3><h4 id="运行指定用例"><a href="#运行指定用例" class="headerlink" title="运行指定用例"></a>运行指定用例</h4><p>在默认情况下，如果只是运行cargo test那么所有被标记为 #[test] 属性的用例都会被执行，但偶尔我们只想运行其中某个用例，此时就可以直接用名字来指定某个用例，例如增加一个这么个用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eq</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">10</span>,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b, <span class="string">&quot;\nthe a.area = &#123;&#125;, b.area = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不想执行large测试用例，只想执行eq测试用例，那么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test eq -t- --show-output</span><br></pre></td></tr></table></figure><p>因为是过滤，所以eq写在 – 的左边。表示执行以eq为开头的用例。这样large用例就不会被拉起。</p><p>如果想运行多个，那么用前缀匹配即可，例如增加一个eq_fail：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"> <span class="meta">#[should_panic(expected = <span class="string">&quot;not equal!&quot;</span>)]</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">eq_fail</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">10</span>,</span><br><span class="line">         name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">         height: <span class="number">100</span>,</span><br><span class="line">         width: <span class="number">20</span>,</span><br><span class="line">         name: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> a.<span class="title function_ invoke__">area</span>() != b.<span class="title function_ invoke__">area</span>() &#123;</span><br><span class="line">         <span class="built_in">panic!</span>(<span class="string">&quot;the area of a&#123;&#125; and b&#123;&#125; are not equal!&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样运行之前的命令，此时eq开头的测试用例都会被拉起：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::eq ... ok</span><br><span class="line">test tests::eq_fail - should panic ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- tests::eq stdout ----</span><br><span class="line"><span class="keyword">in</span> eq of RectangcleArea, jack<span class="symbol">&#x27;s</span> area = <span class="number">1000</span> and rose<span class="symbol">&#x27;s</span> area = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">---- tests::eq_fail stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::eq_fail&#x27; panicked at <span class="symbol">&#x27;the</span> area of a1000 and b2000 are not equal!&#x27;, src/lib.rs:<span class="number">54</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    tests::eq</span><br><span class="line">    tests::eq_fail</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">2</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">1</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h4 id="忽略某些用例"><a href="#忽略某些用例" class="headerlink" title="忽略某些用例"></a>忽略某些用例</h4><p>有些用例很特殊，比如可能某个版本会出错，此时我们需要暂时忽略这些用例，那么可以用ignore属性忽略掉，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore = <span class="string">&quot;no testing anymore&quot;</span>]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">large</span>() &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>此时即使使用cargo test也不会拉起large用例了。</p><h4 id="运行所有用例（包括已忽略的）"><a href="#运行所有用例（包括已忽略的）" class="headerlink" title="运行所有用例（包括已忽略的）"></a>运行所有用例（包括已忽略的）</h4><p>如果想运行所有用例即使是被 igore 的呢？那么一种方法当然是删掉 ignore 属性，一种是使用控制测试框架行为的参数，把被 ignored 的用例 include 进来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --include-ignored</span><br></pre></td></tr></table></figure><p>当然，如果只想运行被 ignored 的用例，那么就指定使用 ignored 用例即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output --ignored</span><br></pre></td></tr></table></figure><h2 id="测试用例结构"><a href="#测试用例结构" class="headerlink" title="测试用例结构"></a>测试用例结构</h2><h3 id="测试代码与二进制文件"><a href="#测试代码与二进制文件" class="headerlink" title="测试代码与二进制文件"></a>测试代码与二进制文件</h3><p>当某个mod被声明test的时候，编译二进制文件讲不会包含测试代码，测试代码和生产用的代码是被分别编译成不同的产物的，这样即节省了编译时间，也减少了测试代码对生产代码的影响：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">cfg</span>(test)]</span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p>可以看到我们一直以来都是在测试非pub的函数，那么方法一样，我们测试的所有函数和方法都不是mod test里面的，也没有声明为pub，但实际我们一直在测试，所以Rust是允许 test 越过访问权限来测试的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::*;</span><br></pre></td></tr></table></figure><p>Test 框架中use supper也说明它引入了所有其它mod，无需担心是否有pub属性。</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>前面说的都是单元测试，所谓单元测试，即对某一个模块的某一个函数或者方法进行测试，而集成测试，则是对某一个模块所导出的接口进行测试，这个模块可能依赖多个其它模块。和单元测试不同，单元测试是和生产代码（放在src目录下）放在一起的，只是都集中放在mod tests里面，并标记 cfg(test)] ，集成测试则是放在和生产代码目录src同级目录下，名叫tests，这些名字都是固定的。cargo会根据目录名而知道，tests下放的每一个文件都是一个testing crate（Rust的基础模块单元）。集成测试不需要再把测试代码放进mod tests里面，只要保证在tests目录下即可。</p><p>例如我们把之前的RectangleArea的测试代码移动到tests目录下，最后目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rectangle</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── rectangle_area.rs</span><br><span class="line">└── tests</span><br><span class="line">    └── test_rectangle_area.rs</span><br></pre></td></tr></table></figure><p>其中lib.rs导出rectangle_area：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> rectangle_area;</span><br></pre></td></tr></table></figure><p> 而内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rectangle::rectangle_area::RectangcleArea;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_area_eq_large</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = RectangcleArea &#123;</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(a &gt; b, <span class="string">&quot;a.area() = &#123;&#125; is not larger than b.area() = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">area</span>(), b.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，测试框架因为被移出src目录，需要使用use把rectangle目录引入，而且，由于不再是单元测试，如果是私有的字段或者方法，将需要声明为pub，否则tests是无法使用的。</p><p>运行cargo build将会编译库文件，运行cargo test将会执行tests目录下的测试模块，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test --test test_rectangle_area -- --nocapture</span><br></pre></td></tr></table></figure><p>即运行 test_rectangle_area.rs的测试用例，且打印print信息。如果不指定test_rectangle_area，那么tests中所有的测试用例都会被拉起执行，而且如果其中某一个失败，会中断所有的测试流程。</p><p>这里似乎不能像python test那样指定到某个函数进行测试，而且对于执行文件（main.rs）是不能使用测试框架的，因为Rust官方认为，执行文件的逻辑应该是很少的，大部分逻辑应该都在库文件中，执行文件只需要简单的运行起来就能测试了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试（testing）是软件开发关键一环，重中之重，任何好的代码都离不开一个严格的测试，Rust也不例外。测试可以找出bug，可以证明某种情况下的正确性。本节介绍怎么在Rust测试框架下写测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
    <category term="Test" scheme="https://www.jackhuang.cc/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Rust的生命周期（lifetime）</title>
    <link href="https://www.jackhuang.cc/2023/01/19/rust-lifetime/"/>
    <id>https://www.jackhuang.cc/2023/01/19/rust-lifetime/</id>
    <published>2023-01-19T08:19:54.000Z</published>
    <updated>2023-01-20T10:34:52.934Z</updated>
    
    <content type="html"><![CDATA[<p>生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。</p><span id="more"></span><h2 id="生命周期是什么"><a href="#生命周期是什么" class="headerlink" title="生命周期是什么"></a>生命周期是什么</h2><p>生命周期（lifetime）是annotation，即一个标记。仅此而已。不管我们怎么做，生命周期就是一个标记，它没有改变任何东西，尤其不会改变对象的生命周期，尽管我们把它叫做生命周期。所以，遇到生命周期时，记住，它只是一个标记，相当于给编译器看的注释，用于给它提示对象的生命周期的。</p><h2 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h2><p>为什么我们要关注生命周期呢，看看下面这个例子，找出一句话的第一个单词：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(&amp;[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> words.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个find_first_word函数入参是一个引用，出参也是一个引用，这么做完全没问题，因为如果出参引用的是入参，那么出参的生命周期和入参一样，如果出参是内部new出来的，那么如果出现悬空指针，那么编译器是可以知道的，所以此时不需要生命周期标记。但如果有两个参数就不一样了，比如返回最长的那个字符串引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，find_longest函数可能返回s1也可能返回s2，那么其返回值的生命周期到底是s1还是s2呢？这个是要靠运行时才能知道的，由于不知道到底返回哪个，编译器自然也无法知道返回值的生命周期，那么无法编译使用这个函数的地方的代码，因为Rust必须在编译时就精确知道各个变量的生命周期，这样才能避免悬空指针，比如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    longest_string = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><p>显然，现在函数find_longest会返回s1，那么longest_string将会引用s1，但s1在离开大括号后就没有了，于是第 8 行的print代码显然在打印一个悬空指针。</p><p>如果没有生命周期标记，Rust编译器无法知道第 5 行longest_string拿到的返回值生命周期到底有多长，也就很难（实际上是可以发现的，可能未来会优化）发现悬空指针问题。</p><p>我们加上生命周期后如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和模板很像，首先在函数名的简括号里面生命一个生命周期，以 ‘ 开头，这个是生命周期语法的要求，后面的 a 则是一般约定俗成的写法，一般使用小写字母，短的单词表示某个某个生命周期，唯一比较特殊的是 ‘static 这个生命周期，这个放后面讲。</p><p>声明完生命周期后，后面引用的时候在&amp;符号后面加上这个’a就表示这个引用的生命周期是’a，那么上面的代码中，s1和s2以及返回值这三个引用的生命周期都是’a，即表示，他们这三个变量中，最小的生命周期必须覆盖其它两个变量的使用范围。</p><p>前一个例子中，s1的生命周期是最小的，它只能活在大括号内，而s2和longest_string在可以存活在大括号外面，所以，s1的生命周期最小，它必须覆盖完s2和longest_string的使用范围。但很明显，出了大括号后，我们访问了longest_string，此时s1已经被销毁，不满足上述要求，因此编译器报错。修复它当然很简单，延长s1的生命周期范围即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;nootherword&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hi, the first word of this line is &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">longest_string</span> = <span class="title function_ invoke__">find_longest</span>(&amp;s1, &amp;s2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, longest_string);</span><br></pre></td></tr></table></figure><h2 id="struct的生命周期"><a href="#struct的生命周期" class="headerlink" title="struct的生命周期"></a>struct的生命周期</h2><p>和函数一样，struct也有生命周期问题，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: &amp;<span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，name这个字段是个引用，那么为了避免有悬空指针出现，Person的对象的生命周期小于等于name引用的对象的生命周期，否则，如果Person的对象还存在，但name所引用的对象已经销毁，那么就会出现悬空指针了。于是为了说明这一点，我们加上生命周期标记，让编译器也让使用方知道，我们必须保证Person的对象生命周期小于等于name所引用的对象的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和函数类似，在Person后的尖括号内声明生命周期’a，name的引用符号&amp;后加上’a，这样就表示Person的对象和这个name字段引用的对象它们的生命周期必须保证Person对象能在name引用对象之前销毁。</p><p>那么，如果我们给这个Person加上方法，是否也需要跟着都加上生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是需要的，即使不管是入参还是返回值，都没有去碰name这个引用，返回值也不是引用，为什么需要加上’a声明呢？</p><p>因为Rust其实是把生命周期和泛型看成差不多一样的对待，大家也看到了，生命周期的声明和模板的声明一样，都在一个地方，他们都是在标记带有某个类型或者声明周期的struct，也就是说，既然我们声明了struct Person&lt;’a&gt;，那么Person&lt;‘a&gt;就是一个叫做“生命周期为’a的struct，struct名叫Person”的类型，那么，给这个类型添加方法，也需要带上’a，简单说也就是Person&lt;‘a&gt;是一个整体，就好像模板Person&lt;T&gt;一样。</p><p>那么返回name这个引用呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.age </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">    <span class="keyword">self</span>.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，依然顺利通过编译，但get_name如果改成可能某种情况下会返回pre或者self.name：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>, pre: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;pre = &#123;&#125;&quot;</span>, pre);</span><br><span class="line">     <span class="keyword">if</span> pre == <span class="string">&quot;hello&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> pre;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会报类似前面的错误了。这是为什么呢？这里就需要Rust的声明周期检查三个规则来解释了。</p><h2 id="生命周期的三个规则"><a href="#生命周期的三个规则" class="headerlink" title="生命周期的三个规则"></a>生命周期的三个规则</h2><p>Rust发现在函数（方法也类似）签名（即入参和出参）或者struct中发现有引用时，会使用这三个规则来检查我们是否需要增加生命周期，如果都通过，那么就不需要，如果有失败，则提示需要增加生命周期。</p><h3 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h3><p>编译器给函数的输入参数都加上自己的生命周期。</p><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器先自己尝试这个给它们都加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即s1和s2都有自己的生命周期 ‘a 和 ‘b。这一步一般不会有什么错误。</p><h3 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h3><p>编译器给函数的输出参数加上自己的生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译器发现 ‘c 会出现问题，因为 ‘c这个生命周期 ‘a 和 ‘b 相关，那么，’c 应该选 ‘a 还是 ‘b 呢？似乎都不确定，这就需要写这段代码的人告诉编译起怎么选择。</p><p>因此编译器报错，提示我们请准确告诉它用哪一个生命周期。我们把s1和s2都写成同一个生命周期，这样就相当于告诉编译器，s1和s2在这个函数中有相同的生命周期，返回参数也可以用这个生命周期，问题得以解决：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt;= s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以修改这个函数加深理解，忘记这个函数是做什么的，假如这个函数就是只返回s2，那么，哪怕我们把s1和s2都声明称不同的声明周期也没问题，因为编译起看到代码，发现函数只返回s2，所以返回值使用s2的即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写是没有问题的，因为返回值就只能是s2，那么返回参数的生命周期当然和s2是一样的。如果返回参数用的s1的生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译起报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">find_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |                 --  -- lifetime `<span class="symbol">&#x27;b</span>` defined here</span><br><span class="line">   |                 |</span><br><span class="line">   |                 lifetime `<span class="symbol">&#x27;a</span>` defined here</span><br><span class="line"><span class="number">23</span> |     <span class="keyword">return</span> s2;</span><br><span class="line">   |            ^^ function was supposed to <span class="keyword">return</span> data with lifetime `<span class="symbol">&#x27;a</span>` but it is returning data with lifetime `<span class="symbol">&#x27;b</span>`</span><br></pre></td></tr></table></figure><p>因为它们的生命周期不匹配。可见，生命周期是引用的一部分，这点类似于Class&lt;T&gt;不能赋值给Class&lt;F&gt; 一样，它们虽然名字都叫Class，但就是不一样的类型。</p><p>如果只有一个引用参数的话呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，编译起尝试给入参加上生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现返回值只能是s的生命周期，所以推理出返回值的生命周期为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_plain</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译器不会发生之前那种歧义的地方，编译通过，我们不需要手工加上生命周期。</p><p>总之，规则二就是编译器主动自己给每一个引用入参加上生命周期的过程，只要它能推理出确定的返回值生命周期，编译就能顺利通过。经验上来讲，如果入参只有一个引用，编译器一般都能推理出返回参数的生命周期，但如果是多于一个引用参数，那么就需要我们给编译器提示了。</p><h3 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h3><p>这个规则是和方法相关的，如果是一个方法，那么除了规则二的应用，还会加上规则三，即，如果引用返回值的生命周期和引用self相关，那么它的生命周期就使用引用self的生命周期。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照规则二announce方法会出现错误，但规则三却可以弥补规则二的问题。即因为引用返回值的生命周期和引用self相关，所以他们的返回值是一样的，即确定的。但如果我们改成返回参数s，这个时候就需要我们加入生命周期标记了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static生命周期"><a href="#static生命周期" class="headerlink" title="static生命周期"></a>static生命周期</h2><p>之前讲的生命周期都是叫a，b或者c，可以说是起了一个短且小写的名字，一般是随意起的，约定俗成是短且小写即可，但有一个特殊的生命周期标记是保留的，即static，表示引用一个从程序执行开始到结束都存在的数据，实际上，static表示这个对象是已经被固化在二进制文件里面了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> =  <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>上面的代码中，”hello world!”这个字符串就是被编译器写入二进制可执行文件的常量区域中，它永远不会被销毁，一致都存在，这个时候就可以用static生命周期标记这种变量。</p><p>一般来说，如果在没有引入常量区的情况下编译器提示使用static引用，多少都说明在设计上可能出现了问题，此时不应该直接用static引用解决编译问题，而是看看哪里引用设计不合理。</p><h2 id="生命周期优化"><a href="#生命周期优化" class="headerlink" title="生命周期优化"></a>生命周期优化</h2><p>诚然在Rust文档中有提到过是否可以优化这些生命周期标记，但目前还是不可或缺，未来版本拭目以待吧。</p><h2 id="生命周期和模板混用"><a href="#生命周期和模板混用" class="headerlink" title="生命周期和模板混用"></a>生命周期和模板混用</h2><p>正如前所说，生命周期非常类似模板，它们可以混在一起用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    age: F </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T, F&gt; Person&lt;<span class="symbol">&#x27;a</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;it will announce: &#123;&#125;&quot;</span>, s);</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: &amp;name,</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">announce</span>(<span class="string">&quot;my name is &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的限制是生命周期的声明必须放在模板之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生命周期是帮助Rust编译器（其实也是帮助程序员）确定引用返回值的生命周期，或者保证struct结构的引用字段中不会出现悬空指针问题。但需要注意的是，生命周期并不改变变量的生命，他只是一种标记，表示某个引用的生命周期相对其它引用的生命周期关系，即生命周期是仅仅只是标记，且有相对性，单个生命周期标记是没有意义的。</p><p>我们可以用前面介绍的三个推理规则来判断如何帮助编译器确认生命周期。</p><p>生命周期和模板非常类似，它们都是类型属性之一，如果因为帮助编译起确定生命周期而进行了生命周期声明，那么它就是类型的一部分，外后增加方法的时候不能省略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;生命周期，即lifetime是Rust最独有的一个特性，早期并没有这个特性，但后来为了辅助Rust的编译器检查生命周期是否合法，也为了调用方方便确认函数或者方法对生命周期的要求就加上去了，也许在未来，这个特性会被优化掉，谁知道呢。做为学习者，我们还是要把这些细节知识补充一下的。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust的模版和trait编程</title>
    <link href="https://www.jackhuang.cc/2023/01/17/rust-template/"/>
    <id>https://www.jackhuang.cc/2023/01/17/rust-template/</id>
    <published>2023-01-17T05:13:33.000Z</published>
    <updated>2023-01-19T12:48:04.013Z</updated>
    
    <content type="html"><![CDATA[<p>要开始学习Rust比较高级的内容了。</p><p>今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。</p><p>那么，今天就好好看看Rust的模板编程吧。</p><span id="more"></span><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>假设我们需要做查处整型和字符型数组中，最大的那个元素，那么需要两个函数分别处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_int</span>(array: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_char</span>(array: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，两个函数都差不多，更抽象的写法是使用模板，即不管什么类型，都执行加法运算：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">            largest = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find_largest_template&lt;T&gt;的T表示T是一个种类型的模板，即模板声明， array: &amp;[T]则表示array是一种类型的slice引用，返回值这是一种类型的引用。具体类型在编译确定的代码时会确定。目前为止没错。</p><p>但在第4行，会报一个错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line"><span class="number">26</span> |         <span class="keyword">if</span> largest &lt; i &#123;</span><br><span class="line">   |            ------- ^ - &amp;T</span><br><span class="line">   |            |</span><br><span class="line">   |            &amp;T</span><br><span class="line">   |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T`</span><br><span class="line">   |</span><br><span class="line"><span class="number">23</span> | <span class="keyword">fn</span> <span class="title function_">find_largest_template</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">   |                           ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `greeting` due to previous error</span><br></pre></td></tr></table></figure><p>意思是，需要确保调用者知道，这个模板T类型需要实现std::cmp::PartialOrd这个trait（partial order），即这个模板类型需要能做&lt;，&gt;，&lt;&#x3D;和&gt;&#x3D;的运算。这个用法相当于函数对调用方的要求，限制。也就是trait bond，即想调用这个函数，调用方必须保证模板类型能满足指定的trait。我们按照编译器的指示，加上对应的trait bond后，编译器检查无误，可以通过编译并正常运行了：</p><p>这个例子我们可以看出三点：</p><p>1、通过函数入参来推断模板类型；</p><p>2、返回值也可以用于模版；</p><p>3、函数设计方可以对模板进行trait bond设计，保证使用方知道这个trait需要满足什么特性（trait）。</p><h3 id="返回值模板"><a href="#返回值模板" class="headerlink" title="返回值模板"></a>返回值模板</h3><p>不但函数的输入参数可以推断类型，返回值也可以用于推断类型。比如我们需要split一个字符串，把split的结果放到一个数组中，代码可以这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(&amp;[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> words.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里split()   方法返回一个iterator，并调用其collect() 方法返回一个集合，看源码知：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect</span>&lt;B: FromIterator&lt;<span class="keyword">Self</span>::Item&gt;&gt;(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> B</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    FromIterator::<span class="title function_ invoke__">from_iter</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其返回的是一个模板B，那么在编译s.split(&amp;[‘ ‘, ‘,’, ‘.’]).collect();这段代码的时候编译器怎么知道我们用的是Vec呢？确实，实际上我们可以用Vec，也可以用LinkedList，那么，为了让编译器生成一个返回Vec的方法出来，我们必须在调用的时候显示写出let words: Vec&lt;&amp;str&gt; &#x3D; … ，这样编译器才能知道我们需要Vec，于是生成一个返回值为Vec的collect() 方法出来。</p><p>我们也可以把Vec&lt;&amp;str&gt;改成Vec&lt;_&gt;，因为编译器完全可以自己推导出&amp;str的，用下划线 _ 即可省去写太多字母。</p><h3 id="struct模板"><a href="#struct模板" class="headerlink" title="struct模板"></a>struct模板</h3><p>和函数模板差不多，我们在struct名称前加上模板声名就可以声明一个模板struct了，后面的字段可以定义对应的类型字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    number: T,</span><br><span class="line">    coord: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，我们也和函数模板一样（函数模板通过入参来推断T），在初始化struct的字段时，推断出各个字段的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">postion</span> = Point &#123;</span><br><span class="line">    number: <span class="number">100</span>,   <span class="comment">// 表明Point的T是i32</span></span><br><span class="line">    coord: Coord &#123; <span class="comment">// 表明Point的U是Coord</span></span><br><span class="line">        x: <span class="number">23</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">        y: <span class="number">84</span>,     <span class="comment">// 表明Coord的T是i32</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似的还有enum的模板，这在之前学习Result和Optional的时候遇到过，不多说了。</p><h3 id="方法的模板"><a href="#方法的模板" class="headerlink" title="方法的模板"></a>方法的模板</h3><p>方法的模板稍显复杂，先看一个简单的例子，例如，我们给前面的例子中Coord&lt;T&gt;添加一个方法用以计算坐标到o点的距离，这个方法是针对T为f64的特化版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Coord</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">distance_to_o</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果要写特化，只需要在impl Coord后面实例化T即可。</p><p>当然也可以不特化，但如果需要支持运算就要加上trait bond，这里用打印x和y来举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: std::fmt::Display&gt; Coord&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">show</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到相对特化版本，泛型版本需要在impl&lt;T&gt;中对T进行trait bond指定，让调用方知道，想使用这个方法，T必须实现了std::fmt::Display，因为方法实现中调用了println!宏。</p><p>总结来说，特化需要放在struct名中指定具体类型，而泛型需要放在impl中指定trait bond。</p><p>我们还可以对泛型为T的struct加上泛型为U的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>, U&gt; Coord&lt;T, U&gt; &#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>&lt;P, Q: <span class="built_in">Copy</span>&gt;(&amp;<span class="keyword">self</span>, other: &amp;Coord&lt;P, Q&gt;) <span class="punctuation">-&gt;</span> Coord&lt;T, Q&gt; &#123;</span><br><span class="line">        Coord &#123; x: <span class="keyword">self</span>.x, y: other.y &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">3.14</span>,</span><br><span class="line">        y: <span class="number">2.718</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">mix</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:#?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是把两个泛型类型不一样的Coord合成第三种泛型类型不一样的过程，可以看到，impl&lt;T: Copy, U&gt;可以指定对某一类struct进行添加方法，即对struct这一层的模板声明（类似C++的tempate&lt;class T&gt;），而 mix&lt;P, Q: Copy&gt;则是对方法的参数进行某一类的指定，即对方法这一层的声明，最后在返回值的地方返回混合类型的Coord&lt;T, Q&gt;。</p><p>这里还需要注意的时候我们在一些类型后面加上了Copy trait，因为mix的入参都是引用，但返回的Coord&lt;T, Q&gt;不是，所以值必须通过拷贝来赋值而不是直接赋值。否则，如果是直接赋值，也就是返回值的T和Q类型分别是引用的话，那么引用入参可能生命周期不如返回参数长，返回值中的字段引用的数据资源可能已经被销毁了，造成悬空指针。</p><h2 id="trait编程"><a href="#trait编程" class="headerlink" title="trait编程"></a>trait编程</h2><h3 id="什么是trait"><a href="#什么是trait" class="headerlink" title="什么是trait"></a>什么是trait</h3><p>trait英文原意是特性的意思，这里有一个很好的比喻，可以快速理解计算机编程语言的trait的特性和用法。我们怎么知道某个东西是一只兔子？兔子的trait是：</p><p>1、耳朵长；</p><p>2、眼睛红；</p><p>3、跑起来像跳；</p><p>4、吃胡萝卜。</p><p>假设我们总结出来兔子的trait如上四条，那么，如果遇到满足以上四条trait的东西，我们就认为它是兔子，哪怕我把我的MacBook笔记本按照这四个trait伪装起来，那我的MacBook笔记本就是一只兔子。因为实际上，我们关心并不是到底是兔子还是笔记本，而是它是否有这些trait。</p><p>也就是说，其实我们并不关心某个东西是什么？我们只关心的是某个东西是否满足某个或者某些trait，满足了，那就行了，具体是什么，其实关系不大。</p><p>这就是我们在面向对象编程里面说的，我们要面向接口编程。这里，就是说成：我们要面向trait编程。</p><h3 id="实现trait"><a href="#实现trait" class="headerlink" title="实现trait"></a>实现trait</h3><p>了解了什么是trait，那么就知道trait是做什么的了，其实就是给各种类型定义行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    headline: <span class="type">String</span>,</span><br><span class="line">    location: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    reply: <span class="type">bool</span>,</span><br><span class="line">    retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.headline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;writen by &#123;&#125;, summary: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">        username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        reply: <span class="literal">true</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用了一个简单的例子，Article和Tweet有不同的字段，同时定义了一个trait Summary，然后针对Article和Tweet分别写出了不同的summarize方法实现。这样，不管Article和Tweet字段怎么样，他们都有Summary这个trait，都可以调用这个trait下的方法。自然有人问，各自定义自己的summarize方法不就行了吗？这个例子的确如此，但假设我们有一个函数去专门处理Summary，做这个事情的人不想关心具体是什么东西，也许是Article，或者是Tweet，甚至可能是一只兔子？总之，对他来说，只要是Summary就行，想使用他的服务的人去想办法把自己变成Summary吧，也就是，只要有Summary这个trait，他的函数就能处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: &amp;<span class="keyword">dyn</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> collect_summary这个函数入参是&amp;dyn Summary，是一个引用，其次dyn是表示运行时动态（dynamic）类型，即编译时不知道Summary背后的东西是什么，需要运行时才能确定，Summary就是我们的trait。加起来表示：collect_summary函数接受一个Summary trait动态引用。</p><p>这样，编写trait和对trait进行再封装再处理的两个人可以解藕编程了，他们之间只需要约定好trait即可。</p><h3 id="dispatch机制"><a href="#dispatch机制" class="headerlink" title="dispatch机制"></a>dispatch机制</h3><p>顺带一提，这里把dyn改成impl也可以正常运行，那么dyn和impl有什么区别呢？还有，为什么dyn前面那里需要用引用 &amp; 呢？本小节讲明白。</p><p>其实这里是Rust的动态运行机制，当涉及到多态编程时，Rust有一种机制来决定到底应该用哪个具体类型来执行，这个机制叫“dispatch”。而dispatch机制分为静态和动态两种，静态dispatch，即编译时期就知道具体是哪个类型了，动态dispatch，则需要在运行时期才能知道是什么类型。</p><p>impl trait则是静态dispatch，也即，Rust编译器在编译的时候就会知道都有哪些类型会使用impl trait，并把这些impl trait代码都生成好，运行时直接调过去就行，运行时不需要判断。例如上面的例子中，我们修改collect_summary函数为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在调用的时候，直接传实现了Summary trait的对象指针进去即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Article &#123;</span><br><span class="line">    headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a story about rust&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;this is will be a long long story you&#x27;ve never head before&quot;</span>),</span><br><span class="line">    author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>),</span><br><span class="line">    location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cn&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = Tweet &#123;</span><br><span class="line">    username: <span class="string">&quot;rose&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    content: <span class="string">&quot;coding makes my day&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    reply: <span class="literal">true</span>,</span><br><span class="line">    retweet: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(a);</span><br><span class="line"><span class="title function_ invoke__">collect_summary</span>(t);</span><br></pre></td></tr></table></figure><p>因为是静态dispatch，Rust编译器需要在编译的时候就确定到底谁调用了collect_summary，当看到collect_summary(a)和collect_summary(t)会分别生成对应的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Article) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_summary</span>(s: Tweet) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这样就实现了编译器的多态，即静态dispatch。（额外提示，此处a和t会失去所有权）</p><p>而动态dispatch，即dyn trait，编译时期编译器无需关心具体是谁调用了collect_summary，它只需要记得，collect_summary接受一个实现了Summary trait的类型做为参数即可，由于编译时期无需关心collect_summary的入参具体类型，也就不知道这个入参的大小，即sizeof大小，此时若不是用引用，那么在不知道sizeof大小的情况下，是无法生成collect_summary函数的代码的（因为要确定内存栈大小）。因此，此时必须使用&amp;dyn。编译器也不会生成各种类型入参的collect_summary版本，这些事情都要放到运行时期才确定。</p><h3 id="trait-bond"><a href="#trait-bond" class="headerlink" title="trait bond"></a>trait bond</h3><p>trait bond前面已经用到，就是对模板 T 进行有所限制，只有满足特定trait的类型才能实例化。如果需要多个trait限定，就用 + 号来增加trait限定。比如，给Coord增加一个方法，只有实现了对比trait和现实trait的类型才能实例化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">ShowMax</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; ShowMax <span class="keyword">for</span> <span class="title class_">Coord</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Coord &#123;</span><br><span class="line">        x: <span class="number">30</span>,</span><br><span class="line">        y: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;max = &#123;&#125;&quot;</span>, c.<span class="title function_ invoke__">show_max</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到，我们对实现ShowMax这个trait进行了trait bond限定，只有能做到Display（进行格式化显示）和PartialOrd（进行大小判断）的类型才能调用。trait bond有助于编译器检查类型是否满足条件。</p><h3 id="where关键字"><a href="#where关键字" class="headerlink" title="where关键字"></a>where关键字</h3><p>trait bond除了可以写在简括号里面，还可以放在函数或者struct名字后面，用where引导出trait bond，比如上面的例子中，可以用where改写成这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; ShowMax <span class="keyword">for</span> <span class="title class_">Coord</span>&lt;T&gt; </span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">PartialOrd</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_max</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章内容比较抽象，有一定的编程经验的人才能看懂，总结几个细节小点：</p><p>1、注意模板声明的位置。想使用模板必须先声明，函数模板在函数名称后面声明，struct在struct类型名称后面声明，方法模板则在impl后面声明；</p><p>2、struct模板和方法模板可以是两个不同的维度各自声明自己的模板；</p><p>3、对trait编程，实现模块间解藕；</p><p>4、区分impl trait（静态dispatch，编译时确定）和dyn trait（动态dispatch，运行时确定）两种dispatch机制，已经此时引用的含义；</p><p>5、使用trait bond保证模板能有某种trait，帮助编译器检查前置条件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要开始学习Rust比较高级的内容了。&lt;/p&gt;
&lt;p&gt;今天要讲的是Rust的模板编程。模板编程实际上并不少见，不论C++还是Java，只要使用容器，基本都离不开模板。Rust的模板和C++很相似，都是编译时根据模板代码生成实际的（concrete）代码然后再编译成二进制。&lt;/p&gt;
&lt;p&gt;那么，今天就好好看看Rust的模板编程吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust的错误处理</title>
    <link href="https://www.jackhuang.cc/2023/01/16/rust-err/"/>
    <id>https://www.jackhuang.cc/2023/01/16/rust-err/</id>
    <published>2023-01-16T05:07:36.000Z</published>
    <updated>2023-02-01T03:41:47.805Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的错误处理主要有以下4点需要学习：</p><p>1、使用panic!宏；</p><p>2、使用Result&lt;T, E&gt;;</p><p>3、使用Optional&lt;T&gt;</p><p>4、使用 ? 符号简化错误处理的代码，这一点非常赞。</p><p>现在就看看我们Rust的错误处理具体细节吧。</p><span id="more"></span><h2 id="panic-宏"><a href="#panic-宏" class="headerlink" title="panic!宏"></a>panic!宏</h2><p>这个是最简单也是最暴力的错误解决处理方案，即直接中断程序运行，并且报告程序错误。如果程序无法继续往下执行，那么，尽早中断也是不错的选择，关键是，如果配合环境变量RUST_BACKTRACE&#x3D;1的话，还可以打印从panic的地方开始的调用栈，方便快速定位问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;the denominator should not be 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s * t = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">divide</span>(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行的时候加上环境变量RUST_BACKTRACE&#x3D;1，则可以在检查分母的失败时打印出调用栈：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;the</span> denominator should not be <span class="number">0</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: _rust_begin_unwind</span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">   <span class="number">2</span>: greeting::divide</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">3</span>: greeting::main</span><br><span class="line">             at /Users/jack/Documents/code/rust/vsrust/greeting/src/main.rs:<span class="number">12</span>:<span class="number">28</span></span><br><span class="line">   <span class="number">4</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /private/tmp/rust-<span class="number">20220812</span>-<span class="number">6466</span>-<span class="number">1</span>atesch/rustc-<span class="number">1.63</span>.<span class="number">0</span>-src/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure><h2 id="使用Result-lt-T-E-gt"><a href="#使用Result-lt-T-E-gt" class="headerlink" title="使用Result&lt;T, E&gt;"></a>使用Result&lt;T, E&gt;</h2><p>大部分错误都是可以容忍的，或者说我们可以继续保持程序继续运行，同时给用户一个友好提示，所以给一个恰当的提示是大多数场景。这个时候我们一般使用Result&lt;T, E&gt;。这是一个很简单但非常有用且常用的枚举类型，其源代码为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="comment">/// Contains the success value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Ok&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Contains the error value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Err&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即Ok和Err两个枚举类型，很多标准函数都会用它来表示是否执行成功，例如，我们现在写一个程序，打开一个文件，如果该文件不存在，则创建它，否则就往文件里面写hello world：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fs::File, io::Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">open_or_create_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_handle_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> file_handle_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">            file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_file_hanle_result</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">match</span> new_file_hanle_result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> file_hanle) =&gt; &#123;</span><br><span class="line">                    file_hanle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;failed to create rust_test.txt, since: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_or_create_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒写了很多，其实就是做了一个简单的逻辑，即先打开文件，存在则写入，不存在则创建，创建成功后写入，创建失败则panic。这个算是比较基本的Result&lt;T, E&gt;使用了。但显然，Rust不会让我们写这么多 match 或者 if 去做判断Result&lt;T, E&gt;结果的，下面就看看Rust是怎么把这段代码简化的。</p><h3 id="用expect代替panic-宏"><a href="#用expect代替panic-宏" class="headerlink" title="用expect代替panic!宏"></a>用expect代替panic!宏</h3><p>如果我们只是想遇到错误就直接panic，那么expect可以帮助我们少写一次 match 或则 if ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_handle</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nofile.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;cannot open the file&quot;</span>);</span><br><span class="line">file_handle.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;cannot</span> open the file: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">35</span>:<span class="number">52</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>可以看到，我们并不需要去判断open() 方法的返回值Result&lt;T, E&gt;，它的expect()  方法帮我们做了判断，如果是失败，那么就panic，如果是成功，则unwrap给我们句柄。</p><p>如果文件存在，那么expect直接返回句柄，那么后面的写入内容就可以顺利执行。</p><h3 id="用unwrap代替panic宏"><a href="#用unwrap代替panic宏" class="headerlink" title="用unwrap代替panic宏"></a>用unwrap代替panic宏</h3><p>除了 expect 方法，unwrap 也可以替代panic，如果我们不去处理 unwrap 的返回值，那么 Rust 会直接打印 panic，并打印出 Error 信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;nofile.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>此时运行会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;called</span> `<span class="type">Result</span>::<span class="title function_ invoke__">unwrap</span>()` on an `<span class="literal">Err</span>` value: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">20</span>:<span class="number">43</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>如果我们主动处理 Err，那么则正常运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;nofile.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = handle &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the error from reading nofile.txt: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the error from reading nofile.txt: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="用-来简化返回的错误值处理"><a href="#用-来简化返回的错误值处理" class="headerlink" title="用 ? 来简化返回的错误值处理"></a>用 ? 来简化返回的错误值处理</h2><p>Rust提供了了 ? 号来帮助我们简化这种常见的Result&lt;T, E&gt;判断。? 其实就是一段简单的逻辑，即，如果返回的是Err那么就直接返回，如果是Ok则继续往下执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_write</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;rust_test.txt&quot;</span>)?.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">open_write</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error_message) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something wrong: &#123;&#125;&quot;</span>, error_message.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="title function_ invoke__">create_write</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 ? 号后，简化了我们对Result&lt;T, E&gt;的判断处理，代码更简洁了。上面的代码中，open() 方法返回了Result&lt;T, E&gt;，? 会处理成功与失败的情况，若成功，则展开Ok(T)，也即获得文件对象句柄，进而调用write_all() 方法写入数据，若失败，则提前返回。</p><p>这里需要注意的是，open_write() 和 create_write() 返回值必须和里面的代码匹配，即成功返回的是Ok(())，失败则返回的是File::open() 或File::create() 的失败返回值Err(E)，此处E是std::io::Error。</p><h2 id="返回其它类型的错误"><a href="#返回其它类型的错误" class="headerlink" title="返回其它类型的错误"></a>返回其它类型的错误</h2><p>上面可以看到，我们返回的错误Err&lt;E&gt;中，类型都是一致的，也即std::io::Error ，但如果我们不想返回这个类型的错误的话呢？这个时候会发生错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_check</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_hanle</span> = File::<span class="title function_ invoke__">open</span>(file_name)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file_hanle.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content);</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">&quot;hello world!&quot;</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">open_check</span>(<span class="string">&quot;nofile.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">18</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">18</span> |         <span class="title function_ invoke__">Err</span>(<span class="string">&quot;the content is not hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">   |         --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected <span class="keyword">struct</span> `std::io::Error`, found <span class="keyword">struct</span> `<span class="type">String</span>`</span><br><span class="line">   |         |</span><br><span class="line">   |         arguments to this <span class="keyword">enum</span> <span class="title class_">variant</span> are incorrect</span><br><span class="line">   |</span><br></pre></td></tr></table></figure><p>因为函数签名上期待的错误枚举，绑定的类型是std::io::Error，但这里返回了String。解决方法是后面学到的trait和面向对象设计。后面再提。</p><h2 id="使用Optional-lt-T-gt-也是一种选择"><a href="#使用Optional-lt-T-gt-也是一种选择" class="headerlink" title="使用Optional&lt;T&gt;也是一种选择"></a>使用Optional&lt;T&gt;也是一种选择</h2><p>Optional&lt;T&gt;也可以像Result&lt;T, E&gt;那样用，如果是None那么就直接返回，否则就继续处理，比如前面的HashMap，我们get一个key，若存在，则乘以二返回，否则就返回None：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">multiple_2</span>(h: &amp;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;, key: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(h.<span class="title function_ invoke__">get</span>(key)? * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">2</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;rust&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">4</span>);</span><br><span class="line">    h.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">multiple_2</span>(&amp;h, <span class="string">&quot;rose&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果通过get() 方法访问一个HashMap存在的key，那么 ? 会展开Some(&amp;i32)得到i32的对象的引用，并且和2相乘。如果不存在，则get() 方法返回None，函数提前返回，这段代码的输出是：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the result is <span class="title function_ invoke__">Some</span>(<span class="number">12</span>)</span><br><span class="line">the result is <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="什么时候panic什么时候返回错误码"><a href="#什么时候panic什么时候返回错误码" class="headerlink" title="什么时候panic什么时候返回错误码"></a>什么时候panic什么时候返回错误码</h2><p>那么什么时候panic什么时候返回错误枚举呢？个人觉得这个问题还是比较显而易见的，从后端服务器设计角度来讲，进程退出是难以维护的不够健壮的提现，好的后端服务，应该能经受得住各种输入数据而屹立不倒，如果随随便便就退出以示对错误的一种反应，则容易被恶意客户端所利用，造成拒绝服务攻击。</p><p>也有人认为，出了错就尽快退出，这样可以及时发现错误，这个愿望是很好的，在程序调试阶段我们可以这么干，的确有利于调试，但放到线上，就需要深思熟虑了。</p><p>折衷方案是，对于后端服务初始化阶段，我们可以对关键信息做panic，运行时，对损害健壮性的请求进行提前拦截并提示错误。业务流程错误则当然使用错误信息。</p><p>再进一步说，对于出错，我们其实不能仅仅只是靠panic或者返回错误信息，需要更系统的去考虑问题，比如系统的吞吐（延迟），成功量（率），失败量（率），请求量，不同水平的告警，等等各种多维度的去监控才能准确的知道一个系统的健康与否。这里只是Rust语言学习，不展开说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的错误处理主要有以下4点需要学习：&lt;/p&gt;
&lt;p&gt;1、使用panic!宏；&lt;/p&gt;
&lt;p&gt;2、使用Result&amp;lt;T, E&amp;gt;;&lt;/p&gt;
&lt;p&gt;3、使用Optional&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;p&gt;4、使用 ? 符号简化错误处理的代码，这一点非常赞。&lt;/p&gt;
&lt;p&gt;现在就看看我们Rust的错误处理具体细节吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust的容器</title>
    <link href="https://www.jackhuang.cc/2023/01/12/collection/"/>
    <id>https://www.jackhuang.cc/2023/01/12/collection/</id>
    <published>2023-01-12T14:42:05.000Z</published>
    <updated>2023-01-19T07:31:04.770Z</updated>
    
    <content type="html"><![CDATA[<p>今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：</p><p>1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）</p><p>2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）</p><p>3、其它各种先决条件。</p><p>总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。</p><p>现在我们就从最常用的容器开始吧。</p><span id="more"></span><h2 id="1-数组Vec"><a href="#1-数组Vec" class="headerlink" title="1. 数组Vec"></a>1. 数组Vec</h2><p>数组Vec是最常用的容器，它非常类似C++的std::vector，底层数据结构也是一块连续的内存，内存不足时，会扩大，并把老数据拷贝到新内存上，因此，非常适合顺序访问和索引访问，非常不适合有删除和插入的场景，因为此时暗含着内存移动的低效操作。</p><h3 id="1-1-高效初始化"><a href="#1-1-高效初始化" class="headerlink" title="1.1 高效初始化"></a>1.1 高效初始化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用了最常用的初始化方法，array1是vec!宏来初始化，array2是直接用Vec::new()来初始化，可以看到我们在定义array2的时候并没有去告诉array2将会放上面类型，直到第6行push第一个String对象的时候才告诉编译器，我们要放的对象是String。Vec只能是单一对象。第6行决定了array2必须放String对象。</p><p>前面说了，Vec是会因为自身分配的内存空间不足时，增长内存的，因此会有数据移动的低效操作，array2的初始化就是这样，如果我们能事先告诉array2要存放什么类型，已经即将存放的数量，那么Vec就可以事先分配好空间，保证我们后续放入数据时不会有数据移动操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">array2.<span class="title function_ invoke__">reserve</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>上面的reserver方法就是告诉array2实现分配至少3个String对象空间，好让后续的3个push方法调用不产生数据移动操作。</p><p>如果事先知道需要分配数组的元素数量，且它们的值都是同一个，那么，更高效的方法是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = <span class="built_in">vec!</span>[<span class="number">100</span>; <span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array3 = &#123;:?&#125;&quot;</span>, array3);</span><br></pre></td></tr></table></figure><p>上面的[100; 5]就表示，分配长度为5个元素，且每个值都是100的数组，这就比前面使用reserver更高效。</p><p>还有with_capacity()方法，可以把Vec::new()和reserve()方法都合成一个，例如array2的初始化可以改成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array2</span> : <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">3</span>);</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">array2.<span class="title function_ invoke__">push</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>总之，如果我们实现就能知道有多少元素即将push进Vec里面的话，我们就尽量的把内存分配好，避免数据移动操作。</p><h3 id="1-2-顺序访问"><a href="#1-2-顺序访问" class="headerlink" title="1.2 顺序访问"></a>1.2 顺序访问</h3><p>Vec是最适合顺序访问的了，我们可以一个个枚举Vec里面的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> &amp;array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，访问array2时我们用了引用，这样访问里面的String对象时，也都变成了引用，这个规则struct也是这样。因为用了引用，后续array2还是有效的指针。</p><h3 id="1-3-索引访问"><a href="#1-3-索引访问" class="headerlink" title="1.3 索引访问"></a>1.3 索引访问</h3><p>索引访问也是我们常用的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[2] = &#123;&#125;&quot;</span>, array2[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>这当然会打印“hello jack”，但如果访问一个不存在的索引呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;array[6] = &#123;&#125;&quot;</span>, array2[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure><p>此时会panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">6</span>&#x27;, src/main.rs:<span class="number">14</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>还需要非常注意的是，之前也提到过，Vec不允许自己的元素被转移走，即以下代码将编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">take</span> = array2[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>因为首先Rust不允许悬空指针的存在，其次如果Vec去维护中间哪一个元素处于悬空指针又实在不合常理，毕竟Vec就是Vec，即向量，向量不应该感知这些东西。因此如果有人打算通过索引访问去取走Vec的资源，那么就会被编译器报错。</p><h3 id="1-4-插入操作"><a href="#1-4-插入操作" class="headerlink" title="1.4 插入操作"></a>1.4 插入操作</h3><h4 id="1-4-1-insert-方法"><a href="#1-4-1-insert-方法" class="headerlink" title="1.4.1 insert()方法"></a>1.4.1 insert()方法</h4><p>相对于push操作，每一次的insert() 的操作就需要大量移动移动数据了，push只有超过capacity的时候才会产生数据转移，而insert每一次都要把需要插入的位置的后面元素往后挪动一个位置，空出来后给新元素放入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after insert, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>如果插入操作真的需要很频繁，那么就应该用 LinkedList&lt;T&gt;。</p><h3 id="1-5-删除操作"><a href="#1-5-删除操作" class="headerlink" title="1.5 删除操作"></a>1.5 删除操作</h3><h4 id="1-5-1-pop-方法"><a href="#1-5-1-pop-方法" class="headerlink" title="1.5.1 pop()方法"></a>1.5.1 pop()方法</h4><p>如果想删去Vec的元素，推荐用的是pop()方法，但注意pop() 方法只能从Vec的最后一个元素开始删除，毕竟前面也说了，试图从中间开始插入或删除一个Vec会引起数据移动操作，这是非常低效的。</p><p>例如我们pop出最后一个元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>可以看到，pop()参数返回的是一个Option&lt;T&gt;，也就是如果array2是空的，那么就会返回None。这里返回的是Some(String)类型。pop之后，array2就只有两个元素在里面了。</p><p>但要注意，如果用for in的方式访问array2且没有使用引用的话，还是会把里面的资源转移走的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> array2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(array2.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;hello jack&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure><p>以上代码编译不通过，因为第1行for in语句中，s会逐次获得array2的资源，第4行再去访问array2的资源会编译失败。</p><h4 id="1-5-2-swap-remove-方法"><a href="#1-5-2-swap-remove-方法" class="headerlink" title="1.5.2 swap_remove () 方法"></a>1.5.2 swap_remove () 方法</h4><p>如果真的需要删掉其中某一个元素，那么可以使用swap_remove()。它的入参是一个index，即需要删掉的元素的索引。为了避免数据移动，Vec的删除策略是这样的：把最后一个元素的值和需要删掉的index交换，并把Vec的长度减1:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array1</span> = <span class="built_in">vec!</span>[<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;before swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;after swap_remove, array1 = &#123;:?&#125;&quot;</span>, array1);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before swap_remove, array1 = [<span class="number">192</span>, <span class="number">31</span>, <span class="number">231</span>, -<span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line">after swap_remove, array1 = [<span class="number">192</span>, <span class="number">3</span>, <span class="number">231</span>, -<span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>可以看到，我们打算删掉31，于是传入它的index&#x3D;1，Vec把末尾的3交换到31上，然后长度减1。同时，swap_remove还会把31返回出来，虽然这里程序没有提现。</p><h3 id="1-6-Vec内部结构探究"><a href="#1-6-Vec内部结构探究" class="headerlink" title="1.6 Vec内部结构探究"></a>1.6 Vec内部结构探究</h3><p>Vec实际上内部是封装了一个tuple结构，tuple中第一个是指针，指向T资源，第二个是长度len，第三个是容量capacity。Vec保证当容量不足时就会自动懂扩容，因此自动扩容的出现点出现在所需内存大于capacity时。把上面的array2结构画出来，会是这样：</p><p><img src="https://www.jackhuang.cc/svg/Vec.svg" alt="Vec内部"></p><p>可以看到，上图蓝色的三个元素就是Vec内部主要封装的三个熟悉，用tuple表示为 (p, 3, 6) ，即p表示指向一组连续的内存，放String数组，3则是数组的元素个数，6则表示array2的容量，表示还可以再存放6 - 3 &#x3D; 3个String对象，且保证在此之前不会触发数据移动操作。</p><p>String数组后面的灰色部分是未初始化区域，也就是6 -3 &#x3D; 3这个部分。关于未初始化区域，可以详细看这里：<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</a> 。</p><h2 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2. 字符串String"></a>2. 字符串String</h2><h3 id="2-1-字符串的连接"><a href="#2-1-字符串的连接" class="headerlink" title="2.1 字符串的连接"></a>2.1 字符串的连接</h3><p>两个字符串连接是最常见的编程场景，最显而易见的就是使用String的push_str和push两个方法，前者入参是一个字符串，后者入参是一个字符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;，&#x27;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>另外一个方法，就是直接用 + 号来实现字符串的拼接，需要注意的是，+ 号方法，使用的是self而不是&amp;self，也就是说，会有所有权转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure><p>还有需要注意的是，s这个参数是&amp;str，也就是它接受一个引用，也就是被加的字符串不会有所有权转移，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;，&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br></pre></td></tr></table></figure><p>上面的代码中，s1 + &amp;s2 + &amp;s3会使得s1丢失所有权，所幸又还给了s1。这里Rust之所以这么干，其实是避免了拷贝，其内部只是通过引用拿到s2和s3的内容，拷贝到s1的后面，避免了拷贝一块新的区域来存放s1。</p><h3 id="2-2-字符串和字节"><a href="#2-2-字符串和字节" class="headerlink" title="2.2 字符串和字节"></a>2.2 字符串和字节</h3><p>String是和Vec类似的，内部结构也是一个tuple，同样放着p指向字符串，另外两个是字符串的长度和容量。这里不展开讲太多String的功能方法，稍有编程经验的人都应该知道String会提供哪些典型的方法，具体可以参考官方文档。</p><p>和其它语言不同，需要特别注意的是，Rust的String对象是一个UTF8格式的，这就意味着一个问题，就是如果我们索引访问一个String对象，会是返回什么？</p><p>如果String内容是“hello world!”，那么[0]是否应该是h，如果是h，那么它的大小就是一个字节。</p><p>如果String内容是“你好，世界！”，那么[0]是否应该是“你”，如果是“你”，那么它的大小就是三个字节。</p><p>那么到底索引访问一个String要返回多少个字节呢？Rust觉得这是一个模糊的问题，于是拒绝编译这种代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">1</span>];</span><br><span class="line">  |             ^^^^ `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br></pre></td></tr></table></figure><p>Rust 需要使用方明确知道自己在干什么，是要返回一个字符，还是要返回某个字节，所以，如果想拿到某个字符，就明确的告诉String，我要以字符方式访问你：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>chars() 方法返回一个迭代器，即我们熟悉的iterator，可以看到做为迭代器，它是有状态的，即封装了一个当前所处位置的指针，因此需要加上mut，这样后面的nth() 方法才可以得以调用，因为nth() 方法会把当前位置往前移动，这相当于修改了状态。</p><p>nth返回Option&lt;Char&gt;，调用unrawp() 方法可以拿到里面的字符。</p><p>我们当然也可以用字节访问String对象，但这样，打印出来的就不是字符形式了，而是字节数字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = s.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>输入出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">189</span></span><br><span class="line">s = <span class="string">&quot;你好，世界！&quot;</span></span><br></pre></td></tr></table></figure><p>189其实是“你”这个字符的第二个字节数。</p><h3 id="2-3-比较两个String"><a href="#2-3-比较两个String" class="headerlink" title="2.3 比较两个String"></a>2.3 比较两个String</h3><p>Rust在这方面要求就比较简单，只需要 &#x3D;&#x3D; 去比较就好了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好世界!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;你好世界!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are same!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;they are different!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">they are same!</span><br></pre></td></tr></table></figure><p>虽然s1是String对象，s2是原生字符串，s1是对象的指针，s2是一个引用，但Rust还是会去判断这两个字符串是否内容相等。</p><h3 id="2-4-Rust的String不简单"><a href="#2-4-Rust的String不简单" class="headerlink" title="2.4 Rust的String不简单"></a>2.4 Rust的String不简单</h3><p>Rust的String并不简单，这里只是主要提了最重要的一点，即String需要我们时刻知道我们到底是造操作字符还是字节，未来遇到String的使用，还是需要多翻阅文档，这里就不去一句句翻译文档内容了。</p><h2 id="3-哈希HashMap"><a href="#3-哈希HashMap" class="headerlink" title="3. 哈希HashMap"></a>3. 哈希HashMap</h2><p>hash也是日常中最常用的数据结构，Rust的HashMap使用了SpiHash算法，避免了哈希碰撞的攻击，详见：<a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> 。当然，其效率就有所下降。</p><p>这里主要讲的是我们常使用的方法，第一个当然是插入了。</p><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1 = &#123;:#?&#125;&quot;</span>, h1);</span><br></pre></td></tr></table></figure><p>可以看到，首先HashMap和Vec不一样，需要我们显式引入，其次，它的key和value类型可以在insert的时候指定，当然一旦指定好类型，之后都不允许更改了。</p><p>注意，由于我们没有使用引用，因此，一旦对象呗插入到HaspMap中，HashMap就有了对象的所有权，如果使用引用，那么我们就必须保证所插入的数据的生命周期大于HashMap对象的生命周期，这在后一节讲到。</p><h3 id="3-2-查找"><a href="#3-2-查找" class="headerlink" title="3.2 查找"></a>3.2 查找</h3><p>使用get方法可以获得一个Optional&lt;T&gt;，如果不存在，返回None，否则返回Somel&lt;T&gt;：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这里调用了copied方法，因为返回的是Optional&lt;&amp;i32&gt;，最后调用unwrap_or() 方法，并且提供了若是None，则返回0。</p><p>这里的错误处理下一节会专门讲到。</p><p>当然除了用ge() t方法，还是使用for语句去遍历所有的HashMap数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> h1 &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-更新"><a href="#3-3-更新" class="headerlink" title="3.3 更新"></a>3.3 更新</h3><p>如果我们在插入同样的key会发生什么呢？比如再插入一条key为”hello rust!”，value为80的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p> 输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可以看到，原来的20被80给覆盖了，因此，插入同样的key会产生覆盖结果。</p><p>但如果我们并不想去覆盖，如果已经存在就不要去动它了，怎么办呢？此时应该调用Entry() 方法，Entry() 方法返回一个枚举，如果有值，则返回那条记录的引用，否则返回新的记录的引用，新记录的枚举中，调用它的or_insert() 方法就可以插入新值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>), <span class="number">10</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>), <span class="number">20</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello jack!&quot;</span>), <span class="number">30</span>);</span><br><span class="line">h1.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;h1[\&quot;hello rust!\&quot;] = &#123;&#125;&quot;</span>, h1.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello rust!&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>此时输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1[<span class="string">&quot;hello rust!&quot;</span>] = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>20没有再被80覆盖。</p><p>如果我们要针对老值来更新新值呢？比如统计“how many word in this word ?” ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;how many word in this word ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> <span class="variable">key</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">count</span> = h.<span class="title function_ invoke__">entry</span>(key).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">     *count += <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:#?&#125;&quot;</span>, h);</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h = &#123;</span><br><span class="line">    <span class="string">&quot;in&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;this&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;how&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;?&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;many&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;word&quot;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到由于word这个词已经存在，所以，第二次调用的时候，entry()  方法返回了老的记录的音乐，此时若调用or_insert()  方法并不会更新，并且返回value的引用，后面的*count +&#x3D; 1对word这个词进行了 + 1 统计。</p><p>以上就是我们常用的HashMap方法，当然，还是那句话，我们使用容器的时候应该多考虑开篇说的两个问题，即什么场景使用，会怎么使用，并且应该常翻阅文档，在里面看看有没有合适的方法供我们选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天熟悉一下Rust的常见容器和其用法。当然本节介绍的容器只是Rust众多数据结构中的一角，只能算是起个头，未来使用容器时，都应该多翻翻文档，并且每次都应该想想：&lt;/p&gt;
&lt;p&gt;1、用来做什么？（是数组还是字符串，是需要哈希还是需要有序）&lt;/p&gt;
&lt;p&gt;2、对数据访问有什么特别的要求？（顺序访问还是随机访问，要经常插入删除还是多是遍历）&lt;/p&gt;
&lt;p&gt;3、其它各种先决条件。&lt;/p&gt;
&lt;p&gt;总之，选择容器一定要看上下文的需求，选择最合适的容器去解决问题。同时，多看文档，多翻文档。&lt;/p&gt;
&lt;p&gt;现在我们就从最常用的容器开始吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust的模块化管理</title>
    <link href="https://www.jackhuang.cc/2023/01/10/mod-and-crate/"/>
    <id>https://www.jackhuang.cc/2023/01/10/mod-and-crate/</id>
    <published>2023-01-10T15:18:55.000Z</published>
    <updated>2023-01-19T07:32:21.480Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。</p><span id="more"></span><h2 id="1-从最简单的包演化说起"><a href="#1-从最简单的包演化说起" class="headerlink" title="1. 从最简单的包演化说起"></a>1. 从最简单的包演化说起</h2><p>任何项目都不可能一个main文件写到底，我们总是要分成几个文件，甚至还要给文件放进不同目录，甚至会事先编译一些文件来管理项目文件。为了学习Rust的相关概念，我们从最简单的一个文件说起，慢慢把它演化成我们常见的项目管理方式，首先来个最简单的main.rs：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个main.rs文件没有任何模块化管理的概念，Person结构体直接就能用。</p><h3 id="1-1-第一个mod"><a href="#1-1-第一个mod" class="headerlink" title="1.1 第一个mod"></a>1.1 第一个mod</h3><p>现在我们把它放到一个module里面吧：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们第一个module了，这里的module很像C++的名字空间（但也不完全是），因此，想使用Person就必须加上PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜这样是编译不通过的，因为任何一个mod里面的东西（也就是module），包括struct，字段，方法，函数甚至子mod都统统是私有的，想对mod外面暴露，就必须定义为pub，因此，我们给Person等名前都加上pub，意味共有的，可以个mod的外部使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候Person以及他的字段都变成pub了，外部可以使用了。代码可以通过编译。</p><p>可见，一个mod关键字，可以声明一个module。</p><h3 id="1-2-把mod放到别的文件"><a href="#1-2-把mod放到别的文件" class="headerlink" title="1.2 把mod放到别的文件"></a>1.2 把mod放到别的文件</h3><p>以上代码我们都是在main.rs文件里面写的，显然我们应该独立出来，假设独立出来的文件名就叫PersonData.rs，那么我们不需要在文件中声明mod PersonData了（如果声明了mod PersonData，那么就是PersonData的子包也叫PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，main.rs的改动就是mod一下这个文件名，从而引入Person结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> PersonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它地方并没有什么改变。</p><p>可见，一个rs文件，可以被当作一个module。</p><h3 id="1-3-把mod放到别的目录"><a href="#1-3-把mod放到别的目录" class="headerlink" title="1.3 把mod放到别的目录"></a>1.3 把mod放到别的目录</h3><p>如果文件PersonData.rs放到别的文件夹呢？假设我们把PersonData.rs移动到DataSet目录里面，那么，此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>此时，main.rs怎么找到PersonData这个模块呢？</p><p>有两种方法：</p><p>1、和main.rs同目录建一个DataSet同名的rs文件，在里面pub mod PersonData，pub表示这个DataSet包要公开PersonData这个module了。</p><p>DataSet.rs内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br></pre></td></tr></table></figure><p>此时，目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   └── PersonData.rs</span><br><span class="line">├── DataSet.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>而main.rs中，mod DataSet（此时不需要pub mod，因为和main.rs是同一个文件，表示引入DataSet），且由于Person被放到了DataSet目录的PersonDate.rs文件中，因此需要修改一下访问它的路径了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，如果一个目录想变成module，就必须在目录同一级目录中，创建一个相同名字的rs文件，并通过它来里面的pub语句来决定公开目录中哪个module。</p><p>第二种方法，我个人认为更简便，即在目录中创建mod.rs，里面干和上面DataSet.rs同样的事情，即决定对外公开目录中哪个module。</p><p>此时目录结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>其中，mod.rs的内容和之前第一种方法的DataSet.rs内容一样。这两个方法都是等效的。</p><p>可见，目录想变成module，还可以在目录中创建mod.rs文件来达到这个目的。</p><h2 id="2-模块的路径"><a href="#2-模块的路径" class="headerlink" title="2.  模块的路径"></a>2.  模块的路径</h2><h3 id="2-1-根目录、绝对路径和相对路径"><a href="#2-1-根目录、绝对路径和相对路径" class="headerlink" title="2.1 根目录、绝对路径和相对路径"></a>2.1 根目录、绝对路径和相对路径</h3><p>前面我们演化并展示了，一个struct类型如何变成不同位置的mod，以及我们的main.rs如何引用它。那么，Rust这些模块路径是通过什么原则去寻找的呢？</p><p>回顾一下，我们新建一个Rust工程的时候使用的是cargo new命令，例如，cargo new greeting，即创建了名为greeting的工程，进入greeting目录，tree命令可以看到创建的工程结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── DataSet</span><br><span class="line">│   │   ├── PersonData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   └── main.rs</span><br></pre></td></tr></table></figure><p>其中src是自动生成的，main.rs是自动生成的，而 DateSet目录是后来添加的。</p><p>Cargo.toml则是工程描述文件，包含版本，工程名已经工程的外部依赖项。</p><p>需要编译编译的时候，在greeting目录中，执行cargo build就可以生成二进制文件。如果想生成库文件，则需要加上–lib命令选项，且不需要写main函数。</p><p>这里主要讲的是，在用cargo new生成工程的时候，src目录即为改工程的根目录。在使用mod关键字去引入工程时，会以src为起点作为根目录，去寻找引用的模块。根目录其实可以用crate来代替，例如上面对Person的访问可以写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了从根目录找，当然还会找同文件的mod模块，即本文一开始写的第一个mod，它写在main.rs文件中。</p><p>还有一个寻找路径就是相对路径，即如果在子目录，那么，也会从子目录开始寻找引用的模块。例如我们新增一个House模块在DataSet目录下，并在Hous模块中添加HoseData.rs文件，文件内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的根目录开始的tree命令输出是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataSet</span><br><span class="line">│   ├── House</span><br><span class="line">│   │   ├── HouseData.rs</span><br><span class="line">│   │   └── <span class="keyword">mod</span>.rs</span><br><span class="line">│   ├── PersonData.rs</span><br><span class="line">│   └── <span class="keyword">mod</span>.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure><p>那么如果我们在DataSet模块输出House模块路径是怎么样的呢？直接以DataSet目录为起点（即相对路径）输入出House模块即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br></pre></td></tr></table></figure><p> 这样DataeSet模块就可以对外输出House模块了。当然House模块也需要对外输出它的HouseData模块，即House目录下的mod.rs文件需要：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> HouseData;</span><br></pre></td></tr></table></figure><p>因为任何模块里面的东西都是私有的，需要显示的说它是pub的才行。</p><p>此时我们在main.rs中就能直接访问House模块了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = crate::DataSet::House::HouseData::HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，Rust的寻找路径可以这样：</p><p>1、从根目录开始寻找；</p><p>2、从相对路径开始寻找</p><p>3、从当前兄弟模块开始寻找。</p><p>根目录即src目录，在代码中可以省略或者以crate开头。</p><h3 id="2-2-使用use"><a href="#2-2-使用use" class="headerlink" title="2.2 使用use"></a>2.2 使用use</h3><p>但如此长的名字确实不好打，Rust给我们提供了一个关键字use，我们只写一次就可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>这样，我们的h指针在初始化的时候就不需要写这么多层级了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">    no: <span class="number">8000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用pub-use和as"><a href="#2-3-使用pub-use和as" class="headerlink" title="2.3 使用pub use和as"></a>2.3 使用pub use和as</h3><p>设想如果DataSet有更多更深的模块的话，我们的每次使用这些又深名字又长的模块都要写一次use，实在太麻烦，此时我们可以在DataSet里面使用pub use来直接吧HouseInfo导出去：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> PersonData;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> House;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> House::HouseData::HouseInfo;</span><br></pre></td></tr></table></figure><p>用了上面第三行的pub use，HouseInfo就如同DataSet的一个struct一样被导到外面去了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> DataSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> DataSet::HouseInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = crate::DataSet::PersonData::Person &#123;</span><br><span class="line">        name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = HouseInfo &#123;</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;shenzhen&quot;</span>),</span><br><span class="line">        no: <span class="number">8000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p = &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;:?&#125;&quot;</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用，不管子模块有多深，只要使用一次pub use，后续都不需要重新use一遍长路径。</p><p>在使用use的时候还可以给导出的struct或者模块起个新名字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::HouseInfo <span class="keyword">as</span> DHI;</span><br></pre></td></tr></table></figure><p>  此时，使用HouseInfo的时候我们可以用DHI代替了。</p><h3 id="2-4-使用super"><a href="#2-4-使用super" class="headerlink" title="2.4 使用super"></a>2.4 使用super</h3><p>和crate不同，crate是表示根目录，而super则表示当前目录的上一级目录。</p><p>例如我们在House中想使用PersonData：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::super::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里用了两个super，从之前的tree看到，第一个super是PersonData.rs的父目录House，第二个super就是House的父目录DataSet，而PersonData.rs就在DataSet下。我们当然也可以用crate目录（也即根节点去引用PersonData）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::DataSet::PersonData::Person; </span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HouseInfo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> address: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> no: <span class="type">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> someone: Person,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-pub-struct和pub-enum"><a href="#2-5-pub-struct和pub-enum" class="headerlink" title="2.5 pub struct和pub enum"></a>2.5 pub struct和pub enum</h2><p>最后要提的是，pub struct和pub enum不同点：</p><p>pub struct只是把struct导出，它的字段，方法还需要再pub来确定是否导出。而enum一旦pub了，它的字段都会变成共有的，都会被导出。</p><h2 id="3-同时引入多个模块"><a href="#3-同时引入多个模块" class="headerlink" title="3. 同时引入多个模块"></a>3. 同时引入多个模块</h2><p>如果需要引入一个模块中多个struct或者其它什么的，可以用大括号来在一行中表示，例如，我们既需要Person也需要HouseInfo，除了写两行use外，还可以这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::House::HouseData::HouseInfo;</span><br><span class="line"><span class="keyword">use</span> DataSet::PersonData::Person;</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::&#123;House::HouseData::HouseInfo, PersonData::Person&#125;;</span><br></pre></td></tr></table></figure><p> 甚至一个*号来表示所有的可以导出的DataSet的东西：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DataSet::*;</span><br></pre></td></tr></table></figure><p> 但星号还是谨慎使用，因为比较随意，可能不经意引起名字冲突。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>这一节从main.rs分裂出一个子模块，并把它放到一个目录中，再新建一个子模块到子子目录中，并通过使用mod（引入一个模块），pub（声明struct，方法，字段，enum为公有，或者用来导出struct，函数或者enum）来控制访问模块。</p><p>使用use来引入复杂的层级，使用pub use来导出一个复杂的层级，还可以使用as来给导出或者引入的模块或者类型定义一个新名字。</p><p>再简化总结一下：</p><p>一个crate可以有多个模块，crate的根在src目录。</p><p>使用方：用mod+use来引入模块，mod引入顶层模块，use引入模块中更复杂的层级结构。如果是引入父级目录，则不需要mod，直接use即可。</p><p>导出方：用pub导出字段，struct，方法函数等，用pub use导出层级深的目录结构。</p><p>as可以提供改名的便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何语言都离不开一个基本概念——包，Rust当然也不例外。按照官方文档教程说法，Rust最基本的包叫crate，它包含了一个或若干个library文件（库文件）或者binary文件（执行文件）。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust中的enum和match</title>
    <link href="https://www.jackhuang.cc/2023/01/08/enum-and-match/"/>
    <id>https://www.jackhuang.cc/2023/01/08/enum-and-match/</id>
    <published>2023-01-08T11:25:24.000Z</published>
    <updated>2023-01-19T07:32:12.647Z</updated>
    
    <content type="html"><![CDATA[<p>今天就来熟悉一下Rust的enum和match语法吧。</p><span id="more"></span><h2 id="1-定义一个enum"><a href="#1-定义一个enum" class="headerlink" title="1. 定义一个enum"></a>1. 定义一个enum</h2><p>枚举类型从来不缺席任何一个稍微高级的语言。Rust也不例外，定义一个枚举只需要enum关键字即可，比如我们定义IP地址类型，其有两种格式，V4和V6版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddressType</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果有一个地质结构体，就可以用它来标识一个地址是哪一个类型的，使用方法也和其他语言差不多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddressType</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    address_type: IpAddressType,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress &#123;</span><br><span class="line">        address_type: IpAddressType::V4,</span><br><span class="line">        address: <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ip = &#123;:#?&#125;&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ennum此时的用法和C++差不多一样，几乎没有特殊之处，下面，就说一下Rust的enum类型带来的更多特性。</p><h3 id="1-1-给enum绑定值"><a href="#1-1-给enum绑定值" class="headerlink" title="1.1 给enum绑定值"></a>1.1 给enum绑定值</h3><p>上面的例子，IpAddressType定义了V4和V6两个类型，要使用它们去标识一个IP需要和String类型一起使用，即IpAddressType标识String的内容是V4还是V6，enum实际上还可以和一个类型绑定，使得其不但有类型属性，还有值属性，比如上面的例子，可以简化为这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ip = &#123;:#?&#125;&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的输出为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip = <span class="title function_ invoke__">V4</span>(</span><br><span class="line">    <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，enum的类型还可以和其它类型绑定在一起，形成“类型+值”的关系，简化了代码。</p><p>enum绑定可以很灵活，可以绑定任何类型，只要你想绑定，就能绑定，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">RAW_V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">String</span>), <span class="comment">// 绑定多个值</span></span><br><span class="line">    <span class="title function_ invoke__">VPerson</span>(Person) <span class="comment">// 绑定自定义struct</span></span><br><span class="line">    Point&#123;x: <span class="type">i32</span>, y: <span class="type">i32</span>&#125;,  <span class="comment">// 绑定一个匿名struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样使用这个enum：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">raw_ip</span> = IpAddress::<span class="title function_ invoke__">RAW_V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;this is a home address&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">person_type</span> = IpAddress::<span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), age: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point</span> = IpAddress::Point &#123; x: <span class="number">100</span>, y: <span class="number">120</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;raw_ip = &#123;:?&#125;&quot;</span>, raw_ip);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;person_type = &#123;:?&#125;&quot;</span>, person_type);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;point = &#123;:?&#125;&quot;</span>, point);</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raw_ip = <span class="title function_ invoke__">RAW_V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;this is a home address&quot;</span>)</span><br><span class="line">person_type = <span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="string">&quot;jack&quot;</span>, age: <span class="number">100</span> &#125;)</span><br><span class="line">point = Point &#123; x: <span class="number">100</span>, y: <span class="number">120</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-给enum加上成员方法"><a href="#1-2-给enum加上成员方法" class="headerlink" title="1.2 给enum加上成员方法"></a>1.2 给enum加上成员方法</h3><p>enum甚至可以加上成员方法，比如我们给IpAddress添加一个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">do_something</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this is an enum!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦拥有了一个IpAddress的枚举值，即可调用这个do_something方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">VPerson</span>(Person &#123; name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">100</span> &#125;);</span><br><span class="line">ip.<span class="title function_ invoke__">do_something</span>();</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is an enum!</span><br></pre></td></tr></table></figure><h3 id="1-3-enum和struct的区别"><a href="#1-3-enum和struct的区别" class="headerlink" title="1.3 enum和struct的区别"></a>1.3 enum和struct的区别</h3><p>看上去enum和struct大部分是一样的，它们可以定义字段，定义方法，但也有细微的不同，首先当然是一个是用struct关键字定义，一个是用enum定义。</p><p>其次，如果我们把上面的例子改成用struct实现，那么每一个枚举类型都是一个struct，那么这些struct它们都不属于一个类型下的定义，即每个类型都是独立的，而枚举类型则是打包了很多个类型，此时若把struct当作enum来用，if let判断或者match判断是错误的，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddressV4</span> &#123;</span><br><span class="line">    name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddressV6</span> &#123;</span><br><span class="line">    age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddressV6&#123;</span><br><span class="line">        age: <span class="number">100</span></span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">match</span> ip &#123;</span><br><span class="line">        IpAddressV4 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v4&quot;</span>),</span><br><span class="line">        IpAddressV6 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码虽然可以编译，但打印出来的却是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is v4</span><br></pre></td></tr></table></figure><p>很明显，不符合预期。 这是因为match发现它们都是struct这个类型，于是走进了V4这个分支中。用enum就可以顺利表达我们的意思：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">u32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = IpAddress::<span class="title function_ invoke__">V6</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">match</span> ip &#123;</span><br><span class="line">        IpAddress::<span class="title function_ invoke__">V4</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v4&quot;</span>),</span><br><span class="line">        IpAddress::<span class="title function_ invoke__">V6</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;it is v6&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is v6</span><br></pre></td></tr></table></figure><p>打印正常，因为enum能正确给V4和V6不同的类型，所以，如果需要用match或者if let的话，还是使用enum吧。</p><h2 id="2-match控制流"><a href="#2-match控制流" class="headerlink" title="2. match控制流"></a>2. match控制流</h2><p>上面的代码用到了match语法，match其实就是C++中的switch，关键是：match强制检查所有enum类型，否则报错，也就是必须要么枚举所有的类型，或者使用下划线 _  来指定匹配之前的类型都失败则执行默认行为。比如之前的match判断就枚举了V4和V6的所有枚举，但如果遇到整型，由于不可能枚举所有整形，就需要默认分支，也即下划线来保证所有的分支都有考虑到：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_24_or_30</span>(i: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> i &#123;</span><br><span class="line">        <span class="number">24</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one day has 24 hours&quot;</span>),</span><br><span class="line">        <span class="number">30</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;some monthes have 30 days&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no decriptions, it is &#123;&#125;&quot;</span>, i),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，每一个rust分支都是以逗号“,”结尾。我们也可以加上大括号，写一些语句：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_24_or_30</span>(i: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> i &#123;</span><br><span class="line">        <span class="number">24</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one day has 24 hours&quot;</span>),</span><br><span class="line">        <span class="number">30</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;some monthes have 30 days&quot;</span>),</span><br><span class="line">        <span class="number">365</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">                name: <span class="string">&quot;jack&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                age: <span class="number">100</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;a year commonly has 365 days, the person is: &#123;:?&#125;&quot;</span>, p);</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no decriptions, it is &#123;&#125;&quot;</span>, i),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-一个常用的enum：Optional-lt-T-gt"><a href="#3-一个常用的enum：Optional-lt-T-gt" class="headerlink" title="3. 一个常用的enum：Optional&lt;T&gt;"></a>3. 一个常用的enum：Optional&lt;T&gt;</h2><p>可以讲讲Optional&lt;T&gt;了。它实际上是一个enum，其源代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// No value.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;None&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="comment">/// Some value of type `T`.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="string">&quot;Some&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有两个成员类型，一个是None，顾名思义，即空类型，一个是Some，绑定一个范型T，所以，如果一个变量是Optional&lt;T&gt;的，那么意味着，要么是None类型，要么是Some类型。例如我们写一个函数，入参是Optional&lt;T&gt;，那么里面就要判断两个类型，一个是Some &lt;T&gt;，另一个是None：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddress</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">what_kind</span>(k: &amp;<span class="type">Option</span>&lt;IpAddress&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> k &#123;</span><br><span class="line">       <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> x &#123;</span><br><span class="line">                IpAddress::<span class="title function_ invoke__">V4</span>(a, b, c, d) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the v4 ip is &#123;&#125;:&#123;&#125;:&#123;&#125;:&#123;&#125;&quot;</span>, a, b, c, d), </span><br><span class="line">                IpAddress::<span class="title function_ invoke__">V6</span>(a) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the v6 ip is &#123;:?&#125;&quot;</span>, a), </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip1</span> = <span class="title function_ invoke__">Some</span>(IpAddress::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip2</span> = <span class="title function_ invoke__">Some</span>(IpAddress::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::::1&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip3</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip1);</span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip2);</span><br><span class="line">    <span class="title function_ invoke__">what_kind</span>(&amp;ip3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以看出，遇到Optional&lt;T&gt;枚举时，必须考虑None和Some两种情况（不然编译报错，虽然可以用下划线来表示默认行为），而要想拿到和Some绑定的T，则必须用match（或者if let，下面会讲），简单总结来说，Optional&lt;T&gt;分为两层处理：</p><p>1、处理None和Some；</p><p>2、若不为None处理Some取出T。</p><p>那么，有人会问，为什么要有Optional&lt;T&gt;这个东西呢？因为Rust所有实体都不能为invalid状态，因此不存在“空”这样的概念，要么有值，要么不能访问，产生编译错误，但现实是有这个概念的，很多语言也有这个概念，Rust在语言机制层面禁止了这个状态的存在，可为了和现实或者和其它语言相对应表达意思的话怎么办呢？于是就需要Optional&lt;T&gt;来做这个工作。</p><p>最后要提一下的是，如果match某个枚举类型啥也不想干，怎么表达呢？因为match必须强制对所有的枚举类型都考虑一遍，所以，遇到啥也不想干的分支，需要一个特殊的写法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ip1 &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> x &#123;</span><br><span class="line">            IpAddress::<span class="title function_ invoke__">V4</span>(a, b, c, d) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>),</span><br><span class="line">            _ =&gt; (),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println!(&quot;x = &#123;:?&#125;&quot;, x);</span></span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码第9行，&#x3D;&gt; ()就是表示，这个分支啥也不干。</p><h2 id="4-if-let用法"><a href="#4-if-let用法" class="headerlink" title="4. if let用法"></a>4. if let用法</h2><p>上面讲了match处理Optional&lt;T&gt;的方法，如果你只是对某个枚举类型感兴趣但其它都做默认处理的话，就可以使用if let用法。这样可以比较自然的写出对枚举类型的处理，其实也可以少打一些代码。</p><p>if let其实就是match的特殊版本，即只处理某一个枚举，其它要么忽视，要么else去做默认处理，例如上面的例子可以改写成这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">what_kind</span>(k: &amp;<span class="type">Option</span>&lt;IpAddress&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = k &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the v4 ip is &#123;&#125;:&#123;&#125;:&#123;&#125;:&#123;&#125;&quot;</span>, a, b, c, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V6</span>(a) = x &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the v6 ip is &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-使用match和if-let的注意事项"><a href="#5-使用match和if-let的注意事项" class="headerlink" title="5. 使用match和if let的注意事项"></a>5. 使用match和if let的注意事项</h2><p>match和if let的使用算是讲完了，但有一个不起眼的事情需要提一下，就是match和if let是会发生资源转移的，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = ip1 &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br></pre></td></tr></table></figure><p>上面第一行代码if let Some(x) &#x3D; ip1，会发生资源转移，即ip1的字段会转移到x上，也即partial moves（详见：<a href="https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html">https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html</a> ）因此，第7行的println!会访问一个已经包含悬空指针的ip1，这不合法，编译器拒绝编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `ip1`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">71</span>:<span class="number">28</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">65</span> |     <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = ip1 &#123;</span><br><span class="line">   |                 - value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">71</span> |     <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br><span class="line">   |                            ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `IpAddress`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this field <span class="keyword">in</span> the pattern to avoid moving `ip1.<span class="number">0</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">65</span> |     <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> x) = ip1 &#123;</span><br><span class="line">   |                 +++</span><br></pre></td></tr></table></figure><p>编译起给出的建议是用引用ref x，当然，我觉得用&amp;ip1也可以。</p><p>还需要注意到一个点是，x并没有发生资源转移，因为x的资源都是u8，他们是primitive类型的，直接使用拷贝，这在前面讲过。</p><p>换成match呢：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ip1 &#123;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">IpAddress</span>::<span class="title function_ invoke__">V4</span>(a, b, c, d) = x &#123;</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">      &#125;,</span><br><span class="line">      _ =&gt; (),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br></pre></td></tr></table></figure><p>依然编译不通过的，资源转移发生在上面的第2行：Some(x) &#x3D;&gt;，此时ip1资源转给了x，ip1又包含悬空指针了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `ip1`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">74</span>:<span class="number">28</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">66</span> |         <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">   |              - value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">74</span> |     <span class="built_in">println!</span>(<span class="string">&quot;ip1 = &#123;:?&#125;&quot;</span>, ip1);</span><br><span class="line">   |                            ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `IpAddress`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this field <span class="keyword">in</span> the pattern to avoid moving `ip1.<span class="number">0</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">66</span> |         <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> x) =&gt; &#123;</span><br></pre></td></tr></table></figure><p> 总结来说，使用match或者if let一定要小心，如果不想发生资源转移，那么就用引用来代替，编译器给出了不错的建议。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天就来熟悉一下Rust的enum和match语法吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust的struct类型</title>
    <link href="https://www.jackhuang.cc/2023/01/07/RustStruct/"/>
    <id>https://www.jackhuang.cc/2023/01/07/RustStruct/</id>
    <published>2023-01-07T09:19:26.000Z</published>
    <updated>2023-01-19T07:32:47.105Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的struct定义和C++的类似，甚至提供了简化初始化的方法，定义成员方法也更灵活，刚刚登上第一个陡坡（所有权），这一节缓缓，因为struct算是Rust中难度不高的内容。</p><span id="more"></span><h2 id="1-struct的定义"><a href="#1-struct的定义" class="headerlink" title="1. struct的定义"></a>1. struct的定义</h2><p>和很多语言一样，定义一个struct就是用struct关键字加上名字，然后罗列出字段来，比如最简单的定义一个人：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>, </span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就定义好了一个人，接下来就是初始化了。</p><h2 id="2-struct的初始化方法"><a href="#2-struct的初始化方法" class="headerlink" title="2. struct的初始化方法"></a>2. struct的初始化方法</h2><h3 id="2-1-直接初始化"><a href="#2-1-直接初始化" class="headerlink" title="2.1 直接初始化"></a>2.1 直接初始化</h3><p>Rust有三种办法初始化一个struct，最简单的莫过于直接赋值，很像json，即key-value形式赋值即可（另外其实提示一下，初始化这些字段并无顺序要求）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jackzhhuang@gmail.com&quot;</span>),</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>试着打印one，会发现错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, one);</span><br></pre></td></tr></table></figure><p>错误信息为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Person` doesn<span class="symbol">&#x27;t</span> implement `std::fmt::Display`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">34</span>:<span class="number">26</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">34</span> |     <span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, one);</span><br><span class="line">   |                          ^^^ `Person` cannot be formatted with the default formatter</span><br><span class="line">   |</span><br><span class="line">   = help: the <span class="keyword">trait</span> `std::fmt::Display` is not implemented <span class="keyword">for</span> `Person`</span><br><span class="line">   = note: <span class="keyword">in</span> format strings you may be able to <span class="keyword">use</span> `&#123;:?&#125;` (or &#123;:#?&#125; <span class="keyword">for</span> <span class="title class_">pretty</span>-print) instead</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br></pre></td></tr></table></figure><p>这里根据提示，会知道，Rust并不是说不知道one里面有什么东西，而是它不知道怎么格式化输出这个对象，好在我们有Debug trait，它可以告诉Rust怎么格式化输出结构，所以，Person的定义加上Debug trait即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>, </span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    address: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust提供了很多trait，struct结构derive了某个trait就有了某个特性，比如这里derive了Debug trait，就可以让rust知道怎么格式化输出这个结构体，更多trait后面会讲到，官方教学文档也给所有的trait介绍，详见：<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">https://doc.rust-lang.org/book/appendix-03-derivable-traits.html</a>  ，这里不展开说。</p><p>另外，由于是自定义的类型，需要在格式化的时候告诉Rust，因此print宏中，{}需要修改为{:?}（简洁打印，所有字段都在一行打印出来）或者{:#?}（美观打印，会换行且对齐）。</p><p>此时，可以正常打印one了，以下是美观打印出来的输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;jackzhhuang@gmail.com&quot;</span>,</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-用函数初始化"><a href="#2-2-用函数初始化" class="headerlink" title="2.2 用函数初始化"></a>2.2 用函数初始化</h3><p>我们当然可以写一个函数然后传入一些字段值，然后在函数中初始化一个对象，最后返回出去。但Rust还提供了一个更简略的语法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_a_person</span>(name: <span class="type">String</span>, age: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Person &#123;</span><br><span class="line">    Person &#123; name, </span><br><span class="line">             age, </span><br><span class="line">             address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(), </span><br><span class="line">             email: <span class="string">&quot;jackzhhuang@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，name和age直接就放在大括号中了，并不需要写出name: name或者age: age这样的代码。</p><h3 id="2-3-用别的对象初始化"><a href="#2-3-用别的对象初始化" class="headerlink" title="2.3 用别的对象初始化"></a>2.3 用别的对象初始化</h3><p>如果已经有了一个对象，我们还想初始化另一个对象，只是有些字段和现有的对象字段不同，除了用前面的方法初始化以外，还有什么办法吗？Rust提供了struct update语法：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jackzhhuang@gmail.com&quot;</span>),</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="variable">another</span> = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Bob&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    ..one</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;another = &#123;:#?&#125;&quot;</span>, another);</span><br></pre></td></tr></table></figure><p>以上会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">another = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>,</span><br><span class="line">    age: <span class="number">100</span>,</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，age和address都和one一样有同样的值。</p><p>但此时注意，one的address变成了悬空指针，此时不能再访问，如果后面加上访问代码，会直接编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.name = &#123;&#125;&quot;</span>, one.name);    <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.email = &#123;&#125;&quot;</span>, one.email);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.age = &#123;&#125;&quot;</span>, one.age);      <span class="comment">// 没问题，因为primitive类型是copy</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;one.address = &#123;&#125;&quot;</span>, one.address);   <span class="comment">// 编译错误，因为address已经被转移到another了</span></span><br></pre></td></tr></table></figure><p>编译结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">44</span> |       <span class="keyword">let</span> <span class="variable">another</span> = Person &#123;</span><br><span class="line">   |  ___________________-</span><br><span class="line"><span class="number">45</span> | |         name: <span class="string">&quot;Bob&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line"><span class="number">46</span> | |         email: <span class="string">&quot;jackhuangvvv@gmail.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line"><span class="number">47</span> | |         ..one</span><br><span class="line"><span class="number">48</span> | |     &#125;;</span><br><span class="line">   | |_____- value moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">55</span> |       <span class="built_in">println!</span>(<span class="string">&quot;one.address = &#123;&#125;&quot;</span>, one.address);</span><br><span class="line">   |                                    ^^^^^^^^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>即这么干，one会把它的字段资源转移到another，由于name和email我们赋的是新值，而age是u32，为primitive，赋值是copy形式，只有address字段我们即没有给新值，且其赋值会采取资源转移形式，因此one的address变成悬空指针了，不能访问。</p><h2 id="3-特殊的struct"><a href="#3-特殊的struct" class="headerlink" title="3. 特殊的struct"></a>3. 特殊的struct</h2><p>和C++一样，可以定义一个什么都没有的struct：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nothing</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no</span> = Nothing;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;n = &#123;:?&#125;&quot;</span>, no)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个用在trait比较多，类似于定义一个interface，后续会学习到。</p><h2 id="4-给struct加上方法"><a href="#4-给struct加上方法" class="headerlink" title="4. 给struct加上方法"></a>4. 给struct加上方法</h2><p>在没有成员方法之前，我们计算一个长方形的面积时这么写的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">80</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, <span class="title function_ invoke__">area</span>(r.width, r.height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用面向对象的方法去思考，面积是长方形的一个属性，长方形自己才知道如何计算自己的面积，因此，应该是长方形这个类返回面积才对，把area这个函数变成Rectangle的方法，只需要impl关键字，并且把area移到Rectangle里面去，并且，第一个参数是&amp;self：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，打印时只需要简单的点area调用即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, r.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure><p>这里需要注意的一个地方是，self这个参数，我们用了引用，其实是省略写法，写完整是self: &amp;Self，那么如果不使用引用可以吗？当然可以，只是这么干，会触发Rust的资源转移机制，调用方的对象会变悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = r.<span class="title function_ invoke__">area</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, s);</span><br></pre></td></tr></table></figure><p>因为self不是引用，上面的代码第7行r会变成悬空指针，那么第8行的打印r会编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> |     <span class="keyword">let</span> <span class="variable">s</span> = r.<span class="title function_ invoke__">area</span>();</span><br><span class="line">   |               ------ `r` moved due to this method call</span><br><span class="line"><span class="number">21</span> |     <span class="built_in">println!</span>(<span class="string">&quot;the area of the rectangle = &#123;:?&#125; is &#123;&#125;&quot;</span>, r, s);</span><br><span class="line">   |                                                        ^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">note: this function takes ownership of the receiver `<span class="keyword">self</span>`, which moves `r`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">9</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">9</span>  |     <span class="keyword">fn</span> <span class="title function_">area</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">   |             ^^^^</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br></pre></td></tr></table></figure><p>根据提示可以知道，因为self不是引用，所以对象资源被转移走了，r就丢了对象，导致悬空指针。这种把self定义为非引用的用法在Option&lt;T&gt;中比较常用，下一节会讲到。</p><h2 id="5-静态方法"><a href="#5-静态方法" class="headerlink" title="5. 静态方法"></a>5. 静态方法</h2><p>正如之前用的String::from那样，struct可以定义静态成员方法，也就是不需要对象指针就可以访问的方法，只需要在方法上不加入self参数即可，比如下面这个计算一个数的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;square of &#123;&#125; is &#123;&#125;&quot;</span>, n, Rectangle::<span class="title function_ invoke__">square</span>(n));</span><br></pre></td></tr></table></figure><p>可以正常打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square of <span class="number">3</span> is <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="6-定义多个成员方法"><a href="#6-定义多个成员方法" class="headerlink" title="6. 定义多个成员方法"></a>6. 定义多个成员方法</h2><p>定义多个成员方法时，可以都写在同一个impl块中也可以分开写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以下是等价的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        n * n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分开写在不同的impl块的好处是扩展Rectangle类的时候不需要去修改之前的老代码，相比OOP中的写一个子类去扩展要更方便更灵活。</p><h2 id="7-遗留问题"><a href="#7-遗留问题" class="headerlink" title="7. 遗留问题"></a>7. 遗留问题</h2><p>这一节相对来说是比较简单的，实际上遗留了一些比较难的问题，这些需要后面学习到lifetime的时候解决：</p><p>1、目前为止我们都是用的类来做成员字段，如果用引用做成员字段呢？</p><p>2、如果struct对象已引用的方式传参，那么会发生什么？</p><p>3、如何解决用其它对象初始化新对象时，其它对象字段指针变成悬空指针的问题？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的struct定义和C++的类似，甚至提供了简化初始化的方法，定义成员方法也更灵活，刚刚登上第一个陡坡（所有权），这一节缓缓，因为struct算是Rust中难度	不高的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++右值引用场景分析</title>
    <link href="https://www.jackhuang.cc/2023/01/05/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://www.jackhuang.cc/2023/01/05/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</id>
    <published>2023-01-05T04:42:57.000Z</published>
    <updated>2023-01-19T07:32:00.811Z</updated>
    
    <content type="html"><![CDATA[<p>今天就向右值引用的使用场景进行开炮。</p><p>首先，几句话快速复习左值右值：</p><span id="more"></span><p>左值：有一个生命范围的值。左值有名称。</p><p>右值：不像左值在某个范围都能存在，而右值生命始于某一行也终于那一行的值，除非有右值引用接住它的资源，否则过了那一行就要变成invalid的值。std::move可以把左值转为右值，进而执行资源转移语义。右值无名称，但右值的引用可以有名称。</p><p>我们先写一个基本类，好跟踪调试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="type">char</span>* s_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in common constructor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in left value reference!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in right value reference!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">        other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] s_;</span><br><span class="line">        s_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">strlen</span>(other);</span><br><span class="line">        s_ = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(s_, other, len);</span><br><span class="line">        s_[len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whatis</span>;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyString&amp; s) &#123;</span><br><span class="line">    out &lt;&lt; s.<span class="built_in">what</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-右值引用作为函数参数"><a href="#1-右值引用作为函数参数" class="headerlink" title="1. 右值引用作为函数参数"></a>1. 右值引用作为函数参数</h2><h3 id="1-1-具体类"><a href="#1-1-具体类" class="headerlink" title="1.1 具体类"></a>1.1 具体类</h3><p>假设我们现在要打印一个MyString对象，如果函数使用的是一个具体的右值引用（即MyString&amp;&amp;）参数，那么，它就是右值引用，即只接受右值：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(MyString&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若打算传一个左值，那就会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>此时会报：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No matching function <span class="keyword">for</span> call to <span class="string">&#x27;print_my_string&#x27;</span></span><br></pre></td></tr></table></figure><p>因为print_my_string需要的就是一个右值，必须给它一个右值，比如一个函数返回的临时变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">make_my_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* something)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyString</span>(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_my_string</span>(<span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为make_my_string返回了一个局部变量，且make_my_string返回的是一个对象，因此这里相当于返回一个临时变量MyString，因为是临时的，没人接手它的资源就要被销毁了，所以是名副其实的右值，此时满足print_my_string的入参条件，编译没问题，运行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>可以看到，并没有调用太多的构造函数，尤其是没有去调用右值引用的拷贝构造函数，这当然是优化的结果（return value optimization）。尽管如此，依赖右值引用入参的print_my_string还是被调用了，符合预期。</p><p>总之，当函数的入参是一个具体的右值引用参数时，那么它就是一个右值引用参数，不能是其它类型值。可是，一旦把具体的右值引用参数改成模板类型，就发生巨大的改变。</p><h3 id="1-2-模板"><a href="#1-2-模板" class="headerlink" title="1.2 模板"></a>1.2 模板</h3><p>将print_my_string修改成模板函数后，变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(T&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果传入一个MyString对象：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>会发现打印的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>也就是实际在print_my_string函数中，s是一个左值引用。但如果使用print_my_string返回一个右值，那么就变成了右值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print_my_string</span>(<span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>也就是说，T&amp;&amp;会根据入参的类型，来去定参数s的类型，甚至能变出const引用出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString <span class="type">const</span>&amp;</span><br><span class="line">s = hello world!</span><br></pre></td></tr></table></figure><p>实际上，T&amp;&amp;和右值引用并不是一回事，T&amp;&amp;是一种万能引用，可以根据调用方的参数类型变成对应的引用类型。</p><h2 id="2-变量的右值引用"><a href="#2-变量的右值引用" class="headerlink" title="2. 变量的右值引用"></a>2. 变量的右值引用</h2><h3 id="2-1-变量为右值引用"><a href="#2-1-变量为右值引用" class="headerlink" title="2.1 变量为右值引用"></a>2.1 变量为右值引用</h3><p>变量定义为右值引用的情况，那么当然只能是右值引用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">MyString&amp;&amp; t = <span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>这个特性似乎没什么可说的。那么换成auto&amp;&amp;呢？</p><h3 id="2-2-auto-amp-amp"><a href="#2-2-auto-amp-amp" class="headerlink" title="2.2 auto&amp;&amp;"></a>2.2 auto&amp;&amp;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = <span class="built_in">make_my_string</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>运行代码发现还是右值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>这应该也很好理解，因为make_my_string就是返回一个右值。如果给auto&amp;&amp;一个左值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = s;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>此时和前面的万能引用一样，变成了左值引用，以下是运行结果：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>也和前面说的一样，如果加上const，t也会变成带const的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; t = s;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(t)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in common constructor!</span><br><span class="line">MyString <span class="type">const</span>&amp;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>可以加auto&amp;&amp;和T&amp;&amp;一样，都是万能引用，随着使用方的类型变化成对应的引用类型。</p><h2 id="3-万能引用加上const后的-amp-amp"><a href="#3-万能引用加上const后的-amp-amp" class="headerlink" title="3. 万能引用加上const后的&amp;&amp;"></a>3. 万能引用加上const后的&amp;&amp;</h2><p>上面说了T&amp;&amp;和auto&amp;&amp;是万能引用，那么const T&amp;&amp;和const auto&amp;&amp;呢？print_my_string 改成了加行const的T&amp;&amp;入参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_my_string</span><span class="params">(<span class="type">const</span> T&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(s)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时下面的代码会变成const左值引用吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(s);</span><br></pre></td></tr></table></figure><p>实际上是会编译失败，在xcode上提示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No matching function <span class="keyword">for</span> call to <span class="string">&#x27;print_my_string&#x27;</span></span><br></pre></td></tr></table></figure><p>因为这个时候const T&amp;&amp;变成是模板类型为T的右值引用，不是万能引用了，强制std::move一下实现右值语义就能通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_my_string</span>(std::<span class="built_in">move</span>(s));</span><br></pre></td></tr></table></figure><p>同理，auto&amp;&amp;加上const后，即const auto&amp;&amp;就不再是万能引用，而是右值引用，必须是右值才能给它赋值。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>对于实际类的右值引用就是右值引用。</p><p>但参数值T&amp;&amp;和右值引用无关，是万能引用，其参数类型由调用方决定，调用方传的什么类型，就是什么类型的引用，即可以是右值引用也可以是左值引用，甚至可以推导出const属性。</p><p>同理，作为一个变量，auto&amp;&amp;也是万能引用，其由赋值方来决定其是什么类型的引用，也即可以是右值引用也可以是左值引用，同样也可以推导出const属性。</p><p>但需要注意的是，const T&amp;&amp;和const auto&amp;&amp;却不是万能const引用，而是右值const引用，即它们只接受右值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天就向右值引用的使用场景进行开炮。&lt;/p&gt;
&lt;p&gt;首先，几句话快速复习左值右值：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Rust所有权</title>
    <link href="https://www.jackhuang.cc/2023/01/02/Rust%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>https://www.jackhuang.cc/2023/01/02/Rust%E6%89%80%E6%9C%89%E6%9D%83/</id>
    <published>2023-01-02T08:17:40.000Z</published>
    <updated>2023-01-19T07:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rust的所有权应该是Rust语言最难理解的一个，是初学者学习Rust遇到的第一个也是最大的陡坡。很多语言几乎不需要去花时间学习资源管理（Java，Go，Python等，C++当然是除外的），所以那些语言很流行，很受欢迎，因为只需要学习一下语法，关键字就能投入到项目中去了，但Rust学习单单是所有权（相当于资源管理）这一块内容，就可以成功劝退绝大部分程序员。</p><p>这是Rust的劣势，决定了Rust流行不起来，也是Rust的优势，决定了Rust效率和正确率上都远优于其它语言（甚至包括C语言）。今天写个总结，把Rust所有权内容说一说。</p><span id="more"></span><h2 id="1-简单的生命周期"><a href="#1-简单的生命周期" class="headerlink" title="1. 简单的生命周期"></a>1. 简单的生命周期</h2><p>从最简单的说起，let表示绑定某个指针到某个对象上，当离开作用域时，对象被销毁，指针进而变为invalid：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面的代码，离开main函数，就变成invalid了，String对象也销毁了。</p><p>上面的代码相当于这样：</p><p><img src="https://www.jackhuang.cc/svg/rust_%E6%89%80%E6%9C%89%E6%9D%83.svg" alt="绑定关系"></p><p>这里简单说一下，s可以理解为一个指针，String即为对象，其成员p指向真正的字符串类型，后面的10位字符串的长度，16为String对象的容量（capacity） 。</p><h2 id="2-从最简单的所有权关系说起"><a href="#2-从最简单的所有权关系说起" class="headerlink" title="2. 从最简单的所有权关系说起"></a>2. 从最简单的所有权关系说起</h2><h3 id="2-1-赋值"><a href="#2-1-赋值" class="headerlink" title="2.1 赋值"></a>2.1 赋值</h3><p>其实Rust难，就难在下面这个简单代码里面，很多人是无法接受Rust这种规定，但其实Rust这么干也是用心良苦。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>以上代码是不能通过编译的，报错如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">17</span>:<span class="number">24</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `s` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line">   |             - value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="number">17</span> |     <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">   |                        ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><p>因为s赋值给t后，s将会变成invalid，也就是悬空指针，这个时候不能对s进行任何访问操作，其对象关系图如下：</p><p><img src="https://www.jackhuang.cc/svg/rust%E8%B5%8B%E5%80%BC.svg" alt="赋值"></p><p>也即，s将失去String对象，t取而代之，只有去掉对s的访问才可以通过编译，Rust不允许访问没有资源的指针。</p><h3 id="2-2-参数传递"><a href="#2-2-参数传递" class="headerlink" title="2.2 参数传递"></a>2.2 参数传递</h3><p>同理，返回值也一样，比如我们有一个函数，返回一个String对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_upper_string</span> (t: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t.<span class="title function_ invoke__">to_uppercase</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_upper_string</span>(s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，上面的代码第10行诗没有办法通过编译的，因为print_upper_string函数的参数t已经获得了s的String对象资源，s变成了悬空指针，cargo build会提示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `s`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">16</span>:<span class="number">24</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `s` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">15</span> |     <span class="title function_ invoke__">print_upper_string</span>(s);</span><br><span class="line">   |                        - value moved here</span><br><span class="line"><span class="number">16</span> |     <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">   |                        ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><h2 id="3-使用借用"><a href="#3-使用借用" class="headerlink" title="3. 使用借用"></a>3. 使用借用</h2><p>解决以上的问题有三个办法，一个是借用，一个是clone，还有一个是使用引用计数。这里先讲借用。</p><p>所谓借用，其实就是C++的引用，也就是被赋值的指针是引用，而不是拥有资源，此时不发生资源转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = &amp;s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>例如上面的代码，t获得&amp;s，即t只是借用s资源，并不拥有它，因此可以通过编译，运行良好。都会打印hello rust!：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = hello rust! </span><br><span class="line">s = hello rust! </span><br></pre></td></tr></table></figure><p>如果去打印t的值和s的地址，会发现它们是相等的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;:p&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;:p&#125;&quot;</span>, &amp;s);</span><br></pre></td></tr></table></figure><p>此时会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0x7ffeefbff2f8</span></span><br><span class="line">s = <span class="number">0x7ffeefbff2f8</span></span><br></pre></td></tr></table></figure><p>所以t其实对s的一个引用：</p><p><img src="https://www.jackhuang.cc/svg/rust%E5%BC%95%E7%94%A8.svg" alt="引用"></p><p>因此，打印t和s所指向的字符串内容时，访问t也可以用解引用来访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, *t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>以上两句代码同样也是打印hello rust!。而且，你会发现*t的地址正是s的地址。</p><h2 id="4-使用克隆"><a href="#4-使用克隆" class="headerlink" title="4. 使用克隆"></a>4. 使用克隆</h2><p>另一个可以用于赋值的方法，就是克隆函数clone：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust! &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;, t = &#123;:p&#125;&quot;</span>, t, &amp;t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;, s = &#123;:p&#125;&quot;</span>, s, &amp;s);</span><br></pre></td></tr></table></figure><p>这时，s和t就是两个完全不同的指针了，它们只是值相同而已：</p><p><img src="https://www.jackhuang.cc/svg/rust_clone.svg" alt="克隆"></p><h2 id="5-数组的特殊情况"><a href="#5-数组的特殊情况" class="headerlink" title="5. 数组的特殊情况"></a>5. 数组的特殊情况</h2><p>以上说的是非数组情况，到了数组，稍微有点不一样了，因为数组是维护了一组指针，如果随便允许把其中某个或者某些指针置为悬空指针，那么数组就需要维护哪个指针是悬空的，哪个指针是有效的。Rust拒绝这么干，所以，数组中的指针不允许直接变成悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">5</span>] = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = array[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = array[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按前面所说，以上代码中，t和s会获得array数组中第三、第四个资源所有权，但实际Rust拒绝这么干，此时编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[<span class="type">String</span>; <span class="number">5</span>]`, a non-copy array</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">21</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |     <span class="keyword">let</span> <span class="variable">t</span> = array[<span class="number">2</span>];</span><br><span class="line">   |             ^^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |             <span class="keyword">move</span> occurs because `array[_]` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |             help: consider borrowing here: `&amp;array[<span class="number">2</span>]`</span><br><span class="line"></span><br><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[<span class="type">String</span>; <span class="number">5</span>]`, a non-copy array</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">22</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> |     <span class="keyword">let</span> <span class="variable">s</span> = array[<span class="number">3</span>];</span><br><span class="line">   |             ^^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |             <span class="keyword">move</span> occurs because `array[_]` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |             help: consider borrowing here: `&amp;array[<span class="number">3</span>]`</span><br></pre></td></tr></table></figure><p>也即，对于数组中的资源，我们只能用引用访问，以下可以正常编译通过且打印如预期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">5</span>] = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = &amp;array[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;array[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, *t);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, *s);</span><br></pre></td></tr></table></figure><p>相比之前的代码，t和s都变成了引用，由于是引用，并不会转移所有权，因此array的资源都在。</p><p>如果是多个引用，则直接使用引用数组即可，例如连续引用数组的第三和第四个资源：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;huang&quot;</span>),];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span>: &amp;[<span class="type">String</span>] = &amp;array[<span class="number">2</span>..=<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &quot;</span>, t);</span><br></pre></td></tr></table></figure><p>此时打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;!&quot;</span>, <span class="string">&quot;jack&quot;</span>] </span><br></pre></td></tr></table></figure><p>这里，数组被我改成了Vec对象，其实只要是连续的对象，比如数组（即[]），Vec，String都可以用引用数组来引用，String的引用有点特殊：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span>: &amp;<span class="type">str</span> = &amp;s[<span class="number">2</span>..=<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &quot;</span>, t);</span><br></pre></td></tr></table></figure><p>这里看到，使用的是&amp;str而不是&amp;[T]，这是Rust的两类数组，&amp;[T]是普通数组引用，&amp;str相当于对字符类型的特殊数组引用，即char串引用。作为特殊的引用，Rust还给它们（&amp;[T]和&amp;str）起了个名字叫切片，即slice。关于引用后面还要专门拿出来讲，这里关注所有权这个话题就好了。</p><p>尽管数组不允许别人把它的资源拿走，只能用引用，但如果用迭代器去访问，资源的所有权还是会被拿走的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>), </span><br><span class="line">                          <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>), ];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;t = &#123;&#125;&quot;</span>, t)</span><br><span class="line">&#125;                              </span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v = &#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>上面的代码会报错，因为v的资源的所有权都被t拿走了，v已经是一个悬空指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">32</span>:<span class="number">26</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">25</span> |     <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), </span><br><span class="line">   |         - <span class="keyword">move</span> occurs because `v` has <span class="keyword">type</span> `<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">...</span><br><span class="line"><span class="number">28</span> |     <span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">   |              - `v` moved due to this implicit call to `.<span class="title function_ invoke__">into_iter</span>()`</span><br><span class="line">...</span><br><span class="line"><span class="number">32</span> |     <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">   |                          ^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure><h2 id="6-primitive类型不会有所有权转移"><a href="#6-primitive类型不会有所有权转移" class="headerlink" title="6. primitive类型不会有所有权转移"></a>6. primitive类型不会有所有权转移</h2><p>尽管前面讲了很多所有权转移的例子，但对于原始类型（比如整型，bool，char）并不会有所有权转移的问题，它们永远都是copy：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// 不会发生所有权转移，a和b都有自己的值3</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>上面的代码正常编译和运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>, b = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>所有权和引用后面还会专门讲很多，这次算是先来个前奏。慢慢积累吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust的所有权应该是Rust语言最难理解的一个，是初学者学习Rust遇到的第一个也是最大的陡坡。很多语言几乎不需要去花时间学习资源管理（Java，Go，Python等，C++当然是除外的），所以那些语言很流行，很受欢迎，因为只需要学习一下语法，关键字就能投入到项目中去了，但Rust学习单单是所有权（相当于资源管理）这一块内容，就可以成功劝退绝大部分程序员。&lt;/p&gt;
&lt;p&gt;这是Rust的劣势，决定了Rust流行不起来，也是Rust的优势，决定了Rust效率和正确率上都远优于其它语言（甚至包括C语言）。今天写个总结，把Rust所有权内容说一说。&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://www.jackhuang.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++查看类型</title>
    <link href="https://www.jackhuang.cc/2023/01/01/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.jackhuang.cc/2023/01/01/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-01-01T06:33:22.000Z</published>
    <updated>2023-01-19T07:33:06.766Z</updated>
    
    <content type="html"><![CDATA[<p>在进一步研究右值引用或者说&amp;&amp;符号之前，先稍微说一下C++中如何查看一个变量的类型。</p><span id="more"></span><h2 id="1-获取变量的类型"><a href="#1-获取变量的类型" class="headerlink" title="1. 获取变量的类型"></a>1. 获取变量的类型</h2><p>只需要用关键字decltype既可以拿到关键字的类型，例如下面的代码，d和s的类型都一样，都是const std::string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-C-标准的查看类型方法"><a href="#2-C-标准的查看类型方法" class="headerlink" title="2. C++标准的查看类型方法"></a>2. C++标准的查看类型方法</h2><p>C++标准使用的方法是std::type_info这个类来获取变量类型，但这个类无法直接构造，因为它的构造函数被deleted了，只能用C++关键字typeid来获得这个类对象。std::type_info有一个成员函数叫name，它返回变量的类型，只是这个变量类型会丢失一些关键信息，比如const或者引用，因此目前标准并没有给出很好的方法去查看变量类型是什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如上面这段代码，在xcode上打印的就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE</span><br></pre></td></tr></table></figure><p>这个信息丢失了const，甚至也很难看出这到底是什么东西，比如最简单的int类型居然也是一个迷惑的i：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下打印i，而不是const int&amp;</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>总之，C++的std::type_info（用关键字typeid）获得的信息真是没什么实用性，名字难看（可读性差），且会丢失一些重要的关键字，比如const，votlatile等。</p><p>顺便再强调一下，typeid是一个关键字，返回std::type_info对象，这个是在编译时期就确定的，因此，如果给一个父类指针，其指向子类对象，那么运行时期依然返回的是父类类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>以上，将会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PK4Base</span><br></pre></td></tr></table></figure><p>打印出来的是PK4Base，表示即p是一个指针，指向Base对象（很明显不准确），尽管实际是一个指针，其指向子类对象。因为，这一切都是在编译时期就确定name函数的返回值了。</p><h2 id="3-让编译器告诉我们类型是什么"><a href="#3-让编译器告诉我们类型是什么" class="headerlink" title="3. 让编译器告诉我们类型是什么"></a>3. 让编译器告诉我们类型是什么</h2><p>标准的std::type_info无法准确的告诉我们类型是什么，这里有一个简单但依然不完美的方法，即通过编译器在编译的时候告诉我们，缺点是必须触发编译错误，这个方法偶尔临时应急用倒是挺实用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whatis</span>;</span><br></pre></td></tr></table></figure><p>上面的代码，因为Whatis类没有定义，若尝试实例化它，编译器就会告诉我们这个需要实例化的类没有定义，并且把T类型打印出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码xcode上编译报错：</span></span><br><span class="line"><span class="comment">// Implicit instantiation of undefined template &#x27;Whatis&lt;const std::__1::basic_string&lt;char&gt; &gt;</span></span><br><span class="line">Whatis&lt;<span class="keyword">decltype</span>(d)&gt; whatisd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码xcode上编译报错：</span></span><br><span class="line"><span class="comment">// Implicit instantiation of undefined template &#x27;Whatis&lt;const Base *&gt;&#x27;</span></span><br><span class="line">Whatis&lt;<span class="keyword">decltype</span>(p)&gt; whatisp;</span><br></pre></td></tr></table></figure><p> 这种方法能让编译器准确告诉我们T是什么，但需要编译错误，也是可惜。</p><h2 id="4-使用boost告诉我们类型是什么"><a href="#4-使用boost告诉我们类型是什么" class="headerlink" title="4. 使用boost告诉我们类型是什么"></a>4. 使用boost告诉我们类型是什么</h2><p>目前最好的方法就是使用boost的boost::typeindex::type_id_with_cvr类，这个类的pretty_name方法会完美返回类型名称：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s) <span class="built_in">d</span>(<span class="string">&quot;hello rust!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Derived t;</span><br><span class="line"><span class="type">const</span> Base* p = &amp;t;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(d)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(p)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::__1::basic_string&lt;<span class="type">char</span>, std::__1::char_traits&lt;<span class="type">char</span>&gt;, std::__1::allocator&lt;<span class="type">char</span>&gt; &gt; <span class="type">const</span></span><br><span class="line">Base <span class="type">const</span>*</span><br></pre></td></tr></table></figure><p>可以看到，不需要编译失败，直接就打印出准确的类型，包含了const关键字和可阅读的指针符号。</p><p>有了这个工具，我们就可以研究&amp;&amp;符号了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在进一步研究右值引用或者说&amp;amp;&amp;amp;符号之前，先稍微说一下C++中如何查看一个变量的类型。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>快速说一下C++右值引用</title>
    <link href="https://www.jackhuang.cc/2022/12/31/%E5%BF%AB%E9%80%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://www.jackhuang.cc/2022/12/31/%E5%BF%AB%E9%80%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2022-12-31T12:43:52.000Z</published>
    <updated>2023-01-19T07:31:56.280Z</updated>
    
    <content type="html"><![CDATA[<p>希望用最简单的话把右值引用说清楚。</p><span id="more"></span><p>什么是右值引用：右值引用即资源传递，右值引用后，引用方会获得资源，被引用方，如同右值那样，被销毁，处于invalid状态。</p><p>为什么需要右值引用：在语义上表达资源传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="type">char</span>* s_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左值引用构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右值引用构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) &#123;</span><br><span class="line">        <span class="built_in">copy</span>(other.s_);</span><br><span class="line">        other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] s_;</span><br><span class="line">        s_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">strlen</span>(other);</span><br><span class="line">        s_ = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(s_, other, len);</span><br><span class="line">        s_[len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现输出</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyString&amp; s) &#123;</span><br><span class="line">    out &lt;&lt; s.<span class="built_in">what</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面的MyString类，构造函数分为左值引用构造函数和右值引用构造函数。</p><p>右值引用构造函数的实现中，需要release调other的指针，因为根据右值引用的协议，被引用的对象应该处于被销毁的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">d</span><span class="params">(std::move(s))</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// panic!</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如执行以上的代码，std::move是强制把s转为右值，从而触发调用MyString的右值引用构造函数，之后，s将会变成invalid状态，此时打印s会出现未定义状态现象。</p><p>当然这个协议完全可以不去遵守，即MyString的右值引用构造函数中不调用release()，这是C++灵活之处，编译器不会强制你遵守这个协议。但不按约定去做，右值引用存在就没有意义了。C++标准库都遵守右值引用的协议。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">d</span><span class="params">(std::move(s))</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>例如上面这段代码，s会变成长度为0的空字符串。相比我写的MyString这样更安全，也达到了资源传递的语义目的。</p><p>后面研究一下万能引用，这又是另一个话题。</p><p>新年快乐！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;希望用最简单的话把右值引用说清楚。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.jackhuang.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>今后要好好做的一些事情</title>
    <link href="https://www.jackhuang.cc/2022/12/30/%E4%BB%8A%E5%90%8E%E8%A6%81%E5%A5%BD%E5%A5%BD%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>https://www.jackhuang.cc/2022/12/30/%E4%BB%8A%E5%90%8E%E8%A6%81%E5%A5%BD%E5%A5%BD%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/</id>
    <published>2022-12-29T16:09:46.000Z</published>
    <updated>2023-01-19T07:31:39.071Z</updated>
    
    <content type="html"><![CDATA[<p>未来要做的东西：</p><p>1、打算用rust做一个学习水平的RPC系统。</p><p>2、写关于C++的博客。多年C++经验，应该是要总结点什么。</p><p>3、写关于mysql的博客。</p><p>4、学习数学。</p><p>对了，还要好好学习写作，倾尽所能，写点东西，在互联网的一个小小的角落里，刷刷存在感吧。</p><p>坚持写作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;未来要做的东西：&lt;/p&gt;
&lt;p&gt;1、打算用rust做一个学习水平的RPC系统。&lt;/p&gt;
&lt;p&gt;2、写关于C++的博客。多年C++经验，应该是要总结点什么。&lt;/p&gt;
&lt;p&gt;3、写关于mysql的博客。&lt;/p&gt;
&lt;p&gt;4、学习数学。&lt;/p&gt;
&lt;p&gt;对了，还要好好学习写作，倾尽所</summary>
      
    
    
    
    <category term="想法" scheme="https://www.jackhuang.cc/categories/%E6%83%B3%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
